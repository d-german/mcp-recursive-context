# Information Extraction in Illicit Domains

**Paper ID:** 1703.03097

## Abstract

Extracting useful entities and attribute values from illicit domains such as human trafficking is a challenging problem with the potential for widespread social impact. Such domains employ atypical language models, have `long tails' and suffer from the problem of concept drift. In this paper, we propose a lightweight, feature-agnostic Information Extraction (IE) paradigm specifically designed for such domains. Our approach uses raw, unlabeled text from an initial corpus, and a few (12-120) seed annotations per domain-specific attribute, to learn robust IE models for unobserved pages and websites. Empirically, we demonstrate that our approach can outperform feature-centric Conditional Random Field baselines by over 18\% F-Measure on five annotated sets of real-world human trafficking datasets in both low-supervision and high-supervision settings. We also show that our approach is demonstrably robust to concept drift, and can be efficiently bootstrapped even in a serial computing environment.

## Introduction

Building knowledge graphs (KG) over Web corpora is an important problem that has galvanized effort from multiple communities over two decades BIBREF0 , BIBREF1 . Automated knowledge graph construction from Web resources involves several different phases. The first phase involves domain discovery, which constitutes identification of sources, followed by crawling and scraping of those sources BIBREF2 . A contemporaneous ontology engineering phase is the identification and design of key classes and properties in the domain of interest (the domain ontology) BIBREF3 .

Once a set of (typically unstructured) data sources has been identified, an Information Extraction (IE) system needs to extract structured data from each page in the corpus BIBREF4 , BIBREF5 , BIBREF6 , BIBREF7 . In IE systems based on statistical learning, sequence labeling models like Conditional Random Fields (CRFs) can be trained and used for tagging the scraped text from each data source with terms from the domain ontology BIBREF8 , BIBREF7 . With enough data and computational power, deep neural networks can also be used for a range of collective natural language tasks, including chunking and extraction of named entities and relationships BIBREF9 .

While IE has been well-studied both for cross-domain Web sources (e.g. Wikipedia) and for traditional domains like biomedicine BIBREF10 , BIBREF11 , it is less well-studied (Section "Preprocessing" ) for dynamic domains that undergo frequent changes in content and structure. Such domains include news feeds, social media, advertising, and online marketplaces, but also illicit domains like human trafficking. Automatically constructing knowledge graphs containing important information like ages (of human trafficking victims), locations, prices of services and posting dates over such domains could have widespread social impact, since law enforcement and federal agencies could query such graphs to glean rapid insights BIBREF12 .

Illicit domains pose some formidable challenges for traditional IE systems, including deliberate information obfuscation, non-random misspellings of common words, high occurrences of out-of-vocabulary and uncommon words, frequent (and non-random) use of Unicode characters, sparse content and heterogeneous website structure, to only name a few BIBREF12 , BIBREF13 , BIBREF14 . While some of these characteristics are shared by more traditional domains like chat logs and Twitter, both information obfuscation and extreme content heterogeneity are unique to illicit domains. While this paper only considers the human trafficking domain, similar kinds of problems are prevalent in other illicit domains that have a sizable Web (including Dark Web) footprint, including terrorist activity, and sales of illegal weapons and counterfeit goods BIBREF15 .

As real-world illustrative examples, consider the text fragments `Hey gentleman im neWYOrk and i'm looking for generous...' and `AVAILABLE NOW! ?? - (4 two 4) six 5 two - 0 9 three 1 - 21'. In the first instance, the correct extraction for a Name attribute is neWYOrk, while in the second instance, the correct extraction for an Age attribute is 21. It is not obvious what features should be engineered in a statistical learning-based IE system to achieve robust performance on such text.

To compound the problem, wrapper induction systems from the Web IE literature cannot always be applied in such domains, as many important attributes can only be found in text descriptions, rather than template-based Web extractors that wrappers traditionally rely on BIBREF6 . Constructing an IE system that is robust to these problems is an important first step in delivering structured knowledge bases to investigators and domain experts.

In this paper, we study the problem of robust information extraction in dynamic, illicit domains with unstructured content that does not necessarily correspond to a typical natural language model, and that can vary tremendously between different Web domains, a problem denoted more generally as concept drift BIBREF16 . Illicit domains like human trafficking also tend to exhibit a `long tail'; hence, a comprehensive solution should not rely on information extractors being tailored to pages from a small set of Web domains.

There are two main technical challenges that such domains present to IE systems. First, as the brief examples above illustrate, feature engineering in such domains is difficult, mainly due to the atypical (and varying) representation of information. Second, investigators and domain experts require a lightweight system that can be quickly bootstrapped. Such a system must be able to generalize from few ( $\approx $ 10-150) manual annotations, but be incremental from an engineering perspective, especially since a given illicit Web page can quickly (i.e. within hours) become obsolete in the real world, and the search for leads and information is always ongoing. In effect, the system should be designed for streaming data.

We propose an information extraction approach that is able to address the challenges above, especially the variance between Web pages and the small training set per attribute, by combining two sequential techniques in a novel paradigm. The overall approach is illustrated in Figure 1 . First, a high-recall recognizer, which could range from an exhaustive Linked Data source like GeoNames (e.g. for extracting locations) to a simple regular expression (e.g. for extracting ages), is applied to each page in the corpus to derive a set of candidate annotations for an attribute per page. In the second step, we train and apply a supervised feature-agnostic classification algorithm, based on learning word representations from random projections, to classify each candidate as correct/incorrect for its attribute.

Contributions We summarize our main contributions as follows: (1) We present a lightweight feature-agnostic information extraction system for a highly heterogeneous, illicit domain like human trafficking. Our approach is simple to implement, does not require extensive parameter tuning, infrastructure setup and is incremental with respect to the data, which makes it suitable for deployment in streaming-corpus settings. (2) We show that the approach shows good generalization even when only a small corpus is available after the initial domain-discovery phase, and is robust to the problem of concept drift encountered in large Web corpora. (3) We test our approach extensively on a real-world human trafficking corpus containing hundreds of thousands of Web pages and millions of unique words, many of which are rare and highly domain-specific. Evaluations show that our approach outperforms traditional Named Entity Recognition baselines that require manual feature engineering. Specific empirical highlights are provided below.

Empirical highlights Comparisons against CRF baselines based on the latest Stanford Named Entity Resolution system (including pre-trained models as well as new models that we trained on human trafficking data) show that, on average, across five ground-truth datasets, our approach outperforms the next best system on the recall metric by about 6%, and on the F1-measure metric by almost 20% in low-supervision settings (30% training data), and almost 20% on both metrics in high-supervision settings (70% training data). Concerning efficiency, in a serial environment, we are able to derive word representations on a 43 million word corpus in under an hour. Degradation in average F1-Measure score achieved by the system is less than 2% even when the underlying raw corpus expands by a factor of 18, showing that the approach is reasonably robust to concept drift.

Structure of the paper Section "Preprocessing" describes some related work on Information Extraction. Section "Approach" provides details of key modules in our approach. Section "Evaluations" describes experimental evaluations, and Section "Conclusion" concludes the work.

## Related Work

Information Extraction (IE) is a well-studied research area both in the Natural Language Processing community and in the World Wide Web, with the reader referred to the survey by Chang et al. for an accessible coverage of Web IE approaches BIBREF17 . In the NLP literature, IE problems have predominantly been studied as Named Entity Recognition and Relationship Extraction BIBREF7 , BIBREF18 . The scope of Web IE has been broad in recent years, extending from wrappers to Open Information Extraction (OpenIE) BIBREF6 , BIBREF19 .

In the Semantic Web, domain-specific extraction of entities and properties is a fundamental aspect in constructing instance-rich knowledge bases (from unstructured corpora) that contribute to the Semantic Web vision and to ecosystems like Linked Open Data BIBREF20 , BIBREF21 . A good example of such a system is Lodifier BIBREF22 . This work is along the same lines, in that we are interested in user-specified attributes and wish to construct a knowledge base (KB) with those attribute values using raw Web corpora. However, we are not aware of any IE work in the Semantic Web that has used word representations to accomplish this task, or that has otherwise outperformed state-of-the-art systems without manual feature engineering.

The work presented in this paper is structurally similar to the geolocation prediction system (from Twitter) by Han et al. and also ADRMine, an adverse drug reaction (ADR) extraction system from social media BIBREF23 , BIBREF24 . Unlike these works, our system is not optimized for specific attributes like locations and drug reactions, but generalizes to a range of attributes. Also, as mentioned earlier, illicit domains involve challenges not characteristic of social media, notably information obfuscation.

In recent years, state-of-the-art results have been achieved in a variety of NLP tasks using word representation methods like neural embeddings BIBREF25 . Unlike the problem covered in this paper, those papers typically assume an existing KB (e.g. Freebase), and attempt to infer additional facts in the KB using word representations. In contrast, we study the problem of constructing and populating a KB per domain-specific attribute from scratch with only a small set of initial annotations from crawled Web corpora.

The problem studied in this paper also has certain resemblances to OpenIE BIBREF19 . One assumption in OpenIE systems is that a given fact (codified, for example, as an RDF triple) is observed in multiple pages and contexts, which allows the system to learn new `extraction patterns' and rank facts by confidence. In illicit domains, a `fact' may only be observed once; furthermore, the arcane and high-variance language models employed in the domain makes direct application of any extraction pattern-based approach problematic. To the best of our knowledge, the specific problem of devising feature-agnostic, low-supervision IE approaches for illicit Web domains has not been studied in prior work.

## Approach

Figure 1 illustrates the architecture of our approach. The input is a Web corpus containing relevant pages from the domain of interest, and high-recall recognizers (described in Section "Applying High-Recall Recognizers" ) typically adapted from freely available Web resources like Github and GeoNames. In keeping with the goals of this work, we do not assume that this initial corpus is static. That is, following an initial short set-up phase, more pages are expected to be added to the corpus in a streaming fashion. Given a set of pre-defined attributes (e.g. City, Name, Age) and around 10-100 manually verified annotations for each attribute, the goal is to learn an IE model that accurately extracts attribute values from each page in the corpus without relying on expert feature engineering. Importantly, while the pages are single-domain (e.g. human trafficking) they are multi-Web domain, meaning that the system must not only handle pages from new websites as they are added to the corpus, but also concept drift in the new pages compared to the initial corpus.

## Preprocessing

The first module in Figure 1 is an automated pre-processing algorithm that takes as input a streaming set of HTML pages. In real-world illicit domains, the key information of interest to investigators (e.g. names and ages) typically occurs either in the text or the title of the page, not the template of the website. Even when the information occasionally occurs in a template, it must be appropriately disambiguated to be useful. Wrapper-based IE systems BIBREF6 are often inapplicable as a result. As a first step in building a more suitable IE model, we scrape the text from each HTML website by using a publicly available text extractor called the Readability Text Extractor (RTE). Although multiple tools are available for text extraction from HTML BIBREF26 , our early trials showed that RTE is particularly suitable for noisy Web domains, owing to its tuneability, robustness and support for developers. We tune RTE to achieve high recall, thus ensuring that the relevant text in the page is captured in the scraped text with high probability. Note that, because of the varied structure of websites, such a setting also introduces noise in the scraped text (e.g. wayward HTML tags). Furthermore, unlike natural language documents, scraped text can contain many irrelevant numbers, Unicode and punctuation characters, and may not be regular. Because of the presence of numerous tab and newline markers, there is no obvious natural language sentence structure in the scraped text. In the most general case, we found that RTE returned a set of strings, with each string corresponding to a set of sentences.

To serialize the scraped text as a list of tokens, we use the word and sentence tokenizers from the NLTK package on each RTE string output BIBREF27 . We apply the sentence tokenizer first, and to each sentence returned (which often does not correspond to an actual sentence due to rampant use of extraneous punctuation characters) by the sentence tokenizer, we apply the standard NLTK word tokenizer. The final output of this process is a list of tokens. In the rest of this section, this list of tokens is assumed as representing the HTML page from which the requisite attribute values need to be extracted.

## Deriving Word Representations

In principle, given some annotated data, a sequence labeling model like a Conditional Random Field (CRF) can be trained and applied on each block of scraped text to extract values for each attribute BIBREF8 , BIBREF7 . In practice, as we empirically demonstrate in Section "Evaluations" , CRFs prove to be problematic for illicit domains. First, the size of the training data available for each CRF is relatively small, and because of the nature of illicit domains, methods like distant supervision or crowdsourcing cannot be used in an obvious timely manner to elicit annotations from users. A second problem with CRFs, and other traditional machine learning models, is the careful feature engineering that is required for good performance. With small amounts of training data, good features are essential for generalization. In the case of illicit domains, it is not always clear what features are appropriate for a given attribute. Even common features like capitalization can be misleading, as there are many capitalized words in the text that are not of interest (and vice versa).

To alleviate feature engineering and manual annotation effort, we leverage the entire raw corpus in our model learning phase, rather than just the pages that have been annotated. Specifically, we use an unsupervised algorithm to represent each word in the corpus in a low-dimensional vector space. Several algorithms exist in the literature for deriving such representations, including neural embedding algorithms such as Word2vec BIBREF25 and the algorithm by Bollegala et al. BIBREF28 , as well as simpler alternatives BIBREF29 .

Given the dynamic nature of streaming illicit-domain data, and the numerous word representation learning algorithms in the literature, we adapted the random indexing (RI) algorithm for deriving contextual word representations BIBREF29 . Random indexing methods mathematically rely on the Johnson-Lindenstrauss Lemma, which states that if points in a vector space are of sufficiently high dimension, then they may be projected into a suitable lower-dimensional space in a way which approximately preserves the distances between the points.

The original random indexing algorithm was designed for incremental dimensionality reduction and text mining applications. We adapt this algorithm for learning word representations in illicit domains. Before describing these adaptations, we define some key concepts below.

definitionDefinition Given parameters $d \in \mathbb {Z}^{+}$ and $r \in [0, 1]$ , a context vector is defined as a $d-$ dimensional vector, of which exactly $\lfloor d r \rfloor $ elements are randomly set to $+1$ , exactly $\lfloor d r \rfloor $ elements are randomly set to $-1$ and the remaining $d-2\lfloor d r \rfloor $ elements are set to 0.

We denote the parameters $d$ and $r$ in the definition above as the dimension and sparsity ratio parameters respectively.

Intuitively, a context vector is defined for every atomic unit in the corpus. Let us denote the universe of atomic units as $U$ , assumed to be a partially observed countably infinite set. In the current scenario, every unigram (a single `token') in the dataset is considered an atomic unit. Extending the definition to also include higher-order ngrams is straightforward, but was found to be unnecessary in our early empirical investigations. The universe is only partially observed because of the incompleteness (i.e. streaming, dynamic nature) of the initial corpus.

The actual vector space representation of an atomic unit is derived by defining an appropriate context for the unit. Formally, a context is an abstract notion that is used for assigning distributional semantics to the atomic unit. The distributional semantics hypothesis (also called Firth's axiom) states that the semantics of an atomic unit (e.g. a word) is defined by the contexts in which it occurs BIBREF30 .

In this paper, we only consider short contexts appropriate for noisy streaming data. In this vein, we define the notion of a $(u, v)$ -context window below:

Given a list $t$ of atomic units and an integer position $0<i\le |t|$ , a $(u, v)$ -context window is defined by the set $S-t[i]$ , where $S$ is the set of atomic units inclusively spanning positions $max(i-u, 1)$ and $min(i+v, |t|)$ 

Using just these two definitions, a naive version of the RI algorithm is illustrated in Figure 2 for the sentence `the cow jumped over the moon', assuming a $(2,2)$ -context window and unigrams as atomic units. For each new word encountered by the algorithm, a context vector (Definition "Deriving Word Representations" ) is randomly generated, and the representation vector for the word is initialized to the 0 vector. Once generated, the context vector for the word remains fixed, but the representation vector is updated with each occurrence of the word.

The update happens as follows. Given the context of the word (ranging from a set of 2-4 words), an aggregation is first performed on the corresponding context vectors. In Figure 2 , for example, the aggregation is an unweighted sum. Using the aggregated vector (denoted by the symbol $\vec{a}$ ), we update the representation vector using the equation below, with $\vec{w}_i$ being the representation vector derived after the $i^{th}$ occurrence of word $w$ : 

$$\vec{w}_{i+1} = \vec{w}_i+\vec{a}$$   (Eq. 9) 

In principle, using this simple algorithm, we could learn a vector space representation for every atomic unit. One issue with a naive embedding of every atomic unit into a vector space is the presence of rare atomic units. These are especially prevalent in illicit domains, not just in the form of rare words, but also as sequences of Unicode characters, sequences of HTML tags, and numeric units (e.g. phone numbers), each of which only occurs a few times (often, only once) in the corpus.

To address this issue, we define below the notion of a compound unit that is based on a pre-specified condition.

Given a universe $U$ of atomic units and a binary condition $R: U \rightarrow \lbrace True,False\rbrace $ , the compound unit $C_R$ is defined as the largest subset of $U$ such that $R$ evaluates to True on every member of $C_R$ .

Example: For `rare' words, we could define the compound unit high-idf-units to contain all atomic units that are below some document frequency threshold (e.g. 1%) in the corpus.

In our implemented prototype, we defined six mutually exclusive compound units, described and enumerated in Table 1 . We modify the naive RI algorithm by only learning a single vector for each compound unit. Intuitively, each atomic unit $w$ in a compound unit $C$ is replaced by a special dummy symbol $w_C$ ; hence, after algorithm execution, each atomic unit in $C$ is represented by the single vector $\vec{w}_C$ .

## Applying High-Recall Recognizers

For a given attribute (e.g. City) and a given corpus, we define a recognizer as a function that, if known, can be used to exactly determine the instances of the attribute occurring in the corpus. Formally, A recognizer $R_A$ for attribute $A$ is a function that takes a list $t$ of tokens and positions $i$ and $j >= i$ as inputs, and returns True if the tokens contiguously spanning $t[i]:t[j]$ are instances of $A$ , and False otherwise. It is important to note that, per the definition above, a recognizer cannot annotate latent instances that are not directly observed in the list of tokens.

Since the `ideal' recognizer is not known, the broad goal of IE is to devise models that approximate it (for a given attribute) with high accuracy. Accuracy is typically measured in terms of precision and recall metrics. We formulate a two-pronged approach whereby, rather than develop a single recognizer that has both high precision and recall (and requires considerable expertise to design), we first obtain a list of candidate annotations that have high recall in expectation, and then use supervised classification in a second step to improve precision of the candidate annotations.

More formally, let $R_A$ be denoted as an $\eta $ -recall recognizer if the expected recall of $R_A$ is at least $\eta $ . Due to the explosive growth in data, many resources on the Web can be used for bootstrapping recognizers that are `high-recall' in that $\eta $ is in the range of 90-100%. The high-recall recognizers currently used in the prototype described in this paper (detailed further in Section "System" ) rely on knowledge bases (e.g. GeoNames) from Linked Open Data BIBREF20 , dictionaries from the Web and broad heuristics, such as regular expression extractors, found in public Github repositories. In our experience, we found that even students with basic knowledge of GitHub and Linked Open Data sources are able to construct such recognizers. One important reason why constructing such recognizers is relatively hassle-free is because they are typically monotonic i.e. new heuristics and annotation sources can be freely integrated, since we do not worry about precision at this step.

We note that in some cases, domain knowledge alone is enough to guarantee 100% recall for well-designed recognizers for certain attributes. In HT, this is true for location attributes like city and state, since advertisements tend to state locations without obfuscation, and we use GeoNames, an exhaustive knowledge base of locations, as our recognizer. Manual inspection of the ground-truth data showed that the recall of utilized recognizers for attributes like Name and Age are also high (in many cases, 100%). Thus, although 100% recall cannot be guaranteed for any recognizer, it is still reasonable to assume that $\eta $ is high.

A much more difficult problem is engineering a recognizer to simultaneously achieve high recall and high precision. Even for recognizers based on curated knowledge bases like GeoNames, many non-locations get annotated as locations. For example, the word `nice' is a city in France, but is also a commonly occurring adjective. Other common words like `for', `hot', `com', `kim' and `bella' also occur in GeoNames as cities and would be annotated. Using a standard Named Entity Recognition system does not always work because of the language modeling problem (e.g. missing capitalization) in illicit domains. In the next section, we show how the context surrounding the annotated word can be used to classify the annotation as correct or incorrect. We note that, because the recognizers are high-recall, a successful classifier would yield both high precision and recall.

## Supervised Contextual Classifier

To address the precision problem, we train a classifier using contextual features. Rather than rely on a domain expert to provide a set of hand-crafted features, we derive a feature vector per candidate annotation using the notion of a context window (Definition "Deriving Word Representations" ) and the word representation vectors derived in Section "Deriving Word Representations" . This process of supervised contextual classification is illustrated in Figure 3 .

Specifically, for each annotation (which could comprise multiple contiguous tokens e.g. `Salt Lake City' in the list of tokens representing the website) annotated by a recognizer, we consider the tokens in the $(u, v)$ -context window around the annotation. We aggregate the vectors of those tokens into a single vector by performing an unweighted sum, followed by $l2$ -normalization. We use this aggregate vector as the contextual feature vector for that annotation. Note that, unlike the representation learning phase, where the surrounding context vectors were aggregated into an existing representation vector, the contextual feature vector is obtained by summing the actual representation vectors.

For each attribute, a supervised machine learning classifier (e.g. random forest) is trained using between 12-120 labeled annotations, and for new data, the remaining annotations can be classified using the trained classifier. Although the number of dimensions in the feature vectors is quite low compared to tf-idf vectors (hundreds vs. millions), a second round of dimensionality reduction can be applied by using (either supervised or unsupervised) feature selection for further empirical benefits (Section "Evaluations" ).

## Datasets and Ground-truths

We train the word representations on four real-world human trafficking datasets of increasing size, the details of which are provided in Table 2 . Since we assume a `streaming' setting in this paper, each larger dataset in Table 2 is a strict superset of the smaller datasets. The largest dataset is itself a subset of the overall human trafficking corpus that was scraped as part of research conducted in the DARPA MEMEX program.

Since ground-truth extractions for the corpus are unknown, we randomly sampled websites from the overall corpus, applied four high-recall recognizers described in Section "System" , and for each annotated set, manually verified whether the extractions were correct or incorrect for the corresponding attribute. The details of this sampled ground-truth are captured in Table 3 . Each annotation set is named using the format GT-{RawField}-{AnnotationAttribute}, where RawField can be either the HTML title or the scraped text (Section "Preprocessing" ). and AnnotationAttribute is the attribute of interest for annotation purposes.

## System

The overall system requires developing two components for each attribute: a high-recall recognizer and a classifier for pruning annotations. We developed four high-recall recognizers, namely GeoNames-Cities, GeoNames-States, RegEx-Ages and Dictionary-Names. The first two of these relies on the freely available GeoNames dataset BIBREF31 ; we use the entire dataset for our experiments, which involves modeling each GeoNames dictionary as a trie, owing to its large memory footprint. For extracting ages, we rely on simple regular expressions and heuristics that were empirically verified to capture a broad set of age representations. For the name attribute, we gather freely available Name dictionaries on the Web, in multiple countries and languages, and use the dictionaries in a case-insensitive recognition algorithm to locate names in the raw field (i.e. text or title).

## Baselines

We use different variants of the Stanford Named Entity Recognition system (NER) as our baselines BIBREF7 . For the first set of baselines, we use two pre-trained models trained on different English language corpora. Specifically, we use the 3-Class and 4-Class pre-trained models. We use the LOCATION class label for determining city and state annotations, and the PERSON label for name annotations. Unfortunately, there is no specific label corresponding to age annotations in the pre-trained models; hence, we do not use the pre-trained models as age annotation baselines.

It is also possible to re-train the underlying NER system on a new dataset. For the second set of baselines, therefore, we re-train the NER models by randomly sampling 30% and 70% of each annotation set in Table 3 respectively, with the remaining annotations used for testing. The features and values that were employed in the re-trained models are enumerated in Table 4 . Further documentation on these feature settings may be found on the NERFeatureFactory page. All training and testing experiments were done in ten independent trials. We use default parameter settings, and report average results for each experimental run. Experimentation using other configurations, features and values is left for future studies.

## Setup and Parameters

Parameter tuning System parameters were set as follows. The number of dimensions in Definition "Deriving Word Representations" was set at 200, and the sparsity ratio was set at 0.01. These parameters are similar to those suggested in previous word representation papers; they were also found to yield intuitive results on semantic similarity experiments (described further in Section "Discussion" ). To avoid the problem of rare words, numbers, punctuation and tags, we used the six compound unit classes earlier described in Table 1 . In all experiments where defining a context was required, we used symmetric $(2,2)$ -context windows; using bigger windows was not found to offer much benefit. We trained a random forest model with default hyperparameters (10 trees, with Gini Impurity as the split criterion) as the supervised classifier, used supervised k-best feature selection with $k$ set to 20 (Section "Supervised Contextual Classifier" ), and with the Analysis of Variance (ANOVA) F-statistic between class label and feature used as the feature scoring function.

Because of the class skew in Table 3 (i.e. the `positive' class is typically much smaller than the `negative' class) we oversampled the positive class for balanced training of the supervised contextual classifier.

Metrics The metrics used for evaluating IE effectiveness are Precision, Recall and F1-measure.

Implementation In the interests of demonstrating a reasonably lightweight system, all experiments in this paper were run on a serial iMac with a 4 GHz Intel core i7 processor and 32 GB RAM. All code (except the Stanford NER code) was written in the Python programming language, and has been made available on a public Github repository with documentation and examples. We used Python's Scikit-learn library (v0.18) for the machine learning components of the prototype.

## Results

Performance against baselines Table 5 illustrates system performance on Precision, Recall and F1-Measure metrics against the re-trained and pre-trained baseline models, where the re-trained model and our approach were trained on 30% of the annotations in Table 3 . We used the word representations derived from the D-ALL corpus. On average, the proposed system performs the best on F1-Measure and recall metrics. The re-trained NER is the most precise system, but at the cost of much less recall ( $<$ 30%). The good performance of the pre-trained baseline on the City attribute demonstrates the importance of having a large training corpus, even if the corpus is not directly from the test domain. On the other hand, the complete failure of the pre-trained baseline on the Name attribute illustrates the dangers of using out-of-domain training data. As noted earlier, language models in illicit domains can significantly differ from natural language models; in fact, names in human trafficking websites are often represented in a variety of misleading ways.

Recognizing that 30% training data may constitute a sample size too small to make reliable judgments, we also tabulate the results in Table 6 when the training percentage is set at 70. Performance improves for both the re-trained baseline and our system. Performance declines for the pre-trained baseline, but this may be because of the sparseness of positive annotations in the smaller test set.

We also note that performance is relatively well-balanced for our system; on all datasets and all metrics, the system achieves scores greater than 50%. This suggests that our approach has a degree of robustness that the CRFs are unable to achieve; we believe that this is a direct consequence of using contextual word representation-based feature vectors.

Runtimes We recorded the runtimes for learning word representations using the random indexing algorithm described earlier on the four datasets in Table 2 , and plot the runtimes in Figure 4 as a function of the total number of words in each corpus.

In agreement with the expected theoretical time-complexity of random indexing, the empirical run-time is linear in the number of words, for fixed parameter settings. More importantly, the absolute times show that the algorithm is extremely lightweight: on the D-ALL corpus, we are able to learn representations in under an hour.

We note that these results do not employ any obvious parallelization or the multi-core capabilities of the machine. The linear scaling properties of the algorithm show that it can be used even for very large Web corpora. In future, we will investigate an implementation of the algorithm in a distributed setting.

Robustness to corpus size and quality One issue with using large corpora to derive word representations is concept drift. The D-ALL corpora, for example, contains tens of different Web domains, even though they all pertain to human trafficking. An interesting empirical issue is whether a smaller corpus (e.g. D-10K or D-50K) contains enough data for the derived word representations to converge to reasonable values. Not only would this alleviate initial training times, but it would also partially compensate for concept drift, since it would be expected to contain fewer unique Web domains.

Tables 7 and 8 show that such generalization is possible. The best F1-Measure performance, in fact, is achieved for D-10K, although the average F1-Measures vary by a margin of less than 2% on all cases. We cite this as further evidence of the robustness of the overall approach.

Effects of feature selection Finally, we evaluate the effects of feature selection in Figure 5 on the GT-Text-Name dataset, with training percentage set at 30. The results show that, although performance is reasonably stable for a wide range of $k$ , some feature selection is necessary for better generalization.

## Discussion

Table 9 contains some examples (in bold) of cities that got correctly extracted, with the bold term being assigned the highest score by the contextual classifier that was trained for cities. The examples provide good evidence for the kinds of variation (i.e. concept drift) that are often observed in real-world human trafficking data over multiple Web domains. Some domains, for example, were found to have the same kind of structured format as the second row of Table 9 (i.e. Location: followed by the actual locations), but many other domains were far more heterogeneous.

The results in this section also illustrate the merits of unsupervised feature engineering and contextual supervision. In principle, there is no reason why the word representation learning module in Figure 1 cannot be replaced by a more adaptive algorithm like Word2vec BIBREF25 . We note again that, before applying such algorithms, it is important to deal with the heterogeneity problem that arises from having many different Web domains present in the corpus. While earlier results in this section (Tables 7 and 8 ) showed that random indexing is reasonably stable as more websites are added to the corpus, we also verify this robustness qualitatively using a few domain-specific examples in Table 10 . We ran the qualitative experiment as follows: for each seed token (e.g. `tall'), we searched for the two nearest neighbors in the semantic space induced by random indexing by applying cosine similarity, using two different word representation datasets (D-10K and D-ALL). As the results in Table 10 show, the induced distributional semantics are stable; even when the nearest neighbors are different (e.g. for `tall'), their semantics still tend to be similar.

Another important point implied by both the qualitative and quantitative results on D-10K is that random indexing is able to generalize quickly even on small amounts of data. To the best of our knowledge, it is currently an open question (theoretically and empirically), at the time of writing, whether state-of-the-art neural embedding-based word representation learners can (1) generalize on small quantities of data, especially in a single epoch (`streaming data') (2) adequately compensate for concept drift with the same degree of robustness, and in the same lightweight manner, as the random indexing method that we adapted and evaluated in this paper. A broader empirical study on this issue is warranted.

Concerning contextual supervision, we qualitatively visualize the inputs to the contextual city classifier using the t-SNE tool BIBREF32 . We use the ground-truth labels to determine the color of each point in the projected 2d space. The plot in Figure 6 shows that there is a reasonable separation of labels; interestingly there are also `sub-clusters' among the positively labeled points. Each sub-cluster provides evidence for a similar context; the number of sub-clusters even in this small sample of points again illustrates the heterogeneity in the underlying data.

A last issue that we mention is the generalization of the method to more unconventional attributes than the ones evaluated herein. In ongoing work, we have experimented with more domain-specific attributes such as ethnicity (of escorts), and have achieved similar performance. In general, the presented method is applicable whenever the context around the extraction is a suitable clue for disambiguation.

## Conclusion

In this paper, we presented a lightweight, feature-agnostic Information Extraction approach that is suitable for illicit Web domains. Our approach relies on unsupervised derivation of word representations from an initial corpus, and the training of a supervised contextual classifier using external high-recall recognizers and a handful of manually verified annotations. Experimental evaluations show that our approach can outperform feature-centric CRF-based approaches for a range of generic attributes. Key modules of our prototype are publicly available (see footnote 15) and can be efficiently bootstrapped in a serial computing environment. Some of these modules are already being used in real-world settings. For example, they were recently released as tools for graduate-level participants in the End Human Trafficking hackathon organized by the office of the District Attorney of New York. At the time of writing, the system is being actively maintained and updated.

Acknowledgements The authors gratefully acknowledge the efforts of Lingzhe Teng, Rahul Kapoor and Vinay Rao Dandin, for sampling and producing the ground-truths in Table 3 . This research is supported by the Defense Advanced Research Projects Agency (DARPA) and the Air Force Research Laboratory (AFRL) under contract number FA8750- 14-C-0240. The views and conclusions contained herein are those of the authors and should not be interpreted as necessarily representing the official policies or endorsements, either expressed or implied, of DARPA, AFRL, or the U.S. Government.
