# Automatic Target Recovery for Hindi-English Code Mixed Puns

**Paper ID:** 1806.04535

## Abstract

In order for our computer systems to be more human-like, with a higher emotional quotient, they need to be able to process and understand intrinsic human language phenomena like humour. In this paper, we consider a subtype of humour - puns, which are a common type of wordplay-based jokes. In particular, we consider code-mixed puns which have become increasingly mainstream on social media, in informal conversations and advertisements and aim to build a system which can automatically identify the pun location and recover the target of such puns. We first study and classify code-mixed puns into two categories namely intra-sentential and intra-word, and then propose a four-step algorithm to recover the pun targets for puns belonging to the intra-sentential category. Our algorithm uses language models, and phonetic similarity-based features to get the desired results. We test our approach on a small set of code-mixed punning advertisements, and observe that our system is successfully able to recover the targets for 67% of the puns.

## Introduction

Humour is one of the most complex and intriguing phenomenon of the human language. It exists in various forms, across space and time, in literature and culture, and is a valued part of human interactions. Puns are one of the simplest and most common forms of humour in the English language. They are also one of the most widespread forms of spontaneous humour BIBREF0 and have found their place in casual conversations, literature, online comments, tweets and advertisements BIBREF1 , BIBREF2 . Puns are a hugely versatile and commonly used literary device and it is essential to include them in any comprehensive approach to computational humour.

In this paper, we consider Hindi-English code-mixed puns and aim to automatically recover their targets. The target of a pun is its phonologically similar counterpart, the relationship to which and whose resolution (recovery) in the mind of the listener/hearer induces humour. For example, in the pun “The life of a patient of hypertension is always at steak." the word “steak" is the pun with target “stake".

With India being a diverse linguistic region, there is an ever increasing usage of code-mixed Hindi-English language (along with various others) because bilingualism and even multilingualism are quite common. Consequently, we have also seen an increase in the usage of code-mixed language in online forums, advertisements etc. Code-mixed humour, especially puns have become increasingly popular because being able to use the same punning techniques but with two languages in play has opened up numerous avenues for new and interesting wordplays. With the increasing popularity and acceptance for the usage of code-mixed language, it has become important that computers are also able to process it and even decipher complex phenomena like humour. Traditional Word Sense Disambiguation (WSD) based methods cannot be used in target recovery of code-mixed puns, because they are no longer about multiple senses of a single word but about two words from two different languages. Code-switching comes with no markers, and the punning word may not even be a word in either of the languages being used. Sometimes words from the two languages can be combined to form a word which only a bilingual speaker would understand. Hence, this task on such data calls for a different set of strategies altogether. We approach this problem in two parts. First, we analyze the types of structures in code-mixed puns and classify them into two categories namely intra-sequential and intra-word. Second, we develop a four stage pipeline to achieve our goal - Language Identification, Pun Candidate Identification, Context Lookup and Phonetic Distance Minimization. We then test our approach on a small dataset and note that our method is successfully able to recover targets for a majority of the puns.

To the best of our knowledge, this is a first attempt at dealing with code-mixed puns. The outline of the paper is as follows: Section 2 gives a brief description of the background and prior work on puns - both in the field of linguistics and in the field of computational humour, along with a brief introduction to the field of code-mixing. Section 3 defines our problem statement, our classification model on code-mixed puns, the dataset we use to test our approach, and our proposed model for the task of automatic target recovery of Hindi-English code-mixed puns. In Section 4, we analyse the performance of our model on a set of puns, and discuss the various error cases. Finally, we conclude in Section 5 with a review of our research contributions and an outline of our plans for future work.

## Puns

Puns are a form of wordplay jokes in which one sign (e.g. a word or a phrase) suggests two or more meanings by exploiting polysemy, homonymy, or phonological similarity to another sign, for an intended humorous or rhetorical effect BIBREF3 . Puns where the two meanings share the same pronunciation are known as homophonic or perfect puns, while those relying on similar but non-identical sounding words are known as heterophonic BIBREF4 or imperfect puns BIBREF5 . In this paper, we study automatic target recoverability of English-Hindi code mixed puns - which are more commonly imperfect puns, but may also be perfect puns in some cases.

Zwicky and Zwicky zwicky1986imperfect, Sobkowiak sobkowiak1991metaphonology extensively studied various phonological variations in imperfect puns such as strong asymmetry in phoneme substitution. They note that puns show more frequent changes in vowels than in consonants because of their smaller role in target recoverability.

Puns have received attention in the field of computational humour, both in generation of puns and their understanding.

Generation: One of the earliest attempts at generating humour was by Lessard and Levin lessard1992computational, when they built an antonym-based system to generate Tom Swifties. Since then, we have seen various other attempts at the task with different strategies. JAPE was a system which exploited framing and phonetic relationships to automatically generate funny punning riddles, or more specifically phonologically ambiguous riddles, having noun phrase punchlines BIBREF6 . Venour venour1999computational built a system which generated HCPPs (Homonym Common Phrase Pun), simple 2 sentence puns based on associations between words occurring in common phrases. WisCraic was a system built by McKay mckay2002generation, which generated simple one-sentence puns based on semantic associations of words. Valitutti et al. valitutti2008textual attempted to automatically generate advertisements by punning on familiar expressions, with an affective connotation.

Identification and understanding: Hempelmann hempelmann2003paronomasic studied target recoverability, arguing that a good model for it provides necessary groundwork for effective automatic pun generation. He worked on a theory which models prominent factors in punning such as phonological similarity and studied how these measures could be used to evaluate possible imperfect puns given an input word and a set of target words.

Yokogawa yokogawa2002japanese analyzed ungrammatical Japanese puns and generated target candidates by replacing ungrammatical parts of the sentence by similar expressions. Taylor and Mazlack taylor2004computationally worked on computational recognition of word-play in the restricted domain of Knock-Knock jokes. Jaech et al. jaech2016phonological developed a computational model for target recovery of puns using techniques for automatic speech recognition, and learned phone edit probabilities in puns. Miller and Gurevych Miller2015AutomaticDO, Miller et al.miller2017semeval describe different methods on pun identification and disambiguation. Word Sense Disambiguation (WSD) based techniques are most common among the methods used.

To the best of our knowledge no prior work has been attempted on code-mixed puns.

## Code-mixing

Code-mixing is the mixing of two or more languages or language varieties. Code-mixing is now recognized as a natural part of bilingual and multilingual language use. Significant linguistic efforts have been made to understand the sociological and conversational necessity behind code-switching BIBREF7 ; for example, to understand whether it is an act of identity in a social group, or a consequence of a lack of competence in either of the languages. These papers distinguish between inter-sentence, intra-sentence and intra-word code mixing.

Different types of language mixing phenomena have been discussed and defined by several linguists, with some making clear distinctions between phenomena based on certain criteria, while others use `code-mixing’ or `code-switching’ as umbrella terms to include any type of language mixing — see, e.g., Muysken muysken1995code or Gafaranga and Torras gafaranga2002interactional. In this paper, we use both these terms ‘code-mixing’ and `code-switching' interchangeably.

Coming to the work on automatic analysis of code-mixed languages, there have been studies on detecting code mixing in spoken language as well as different types of short texts, such as information retrieval queries BIBREF8 , SMS messages BIBREF9 , BIBREF10 , social media data BIBREF11 and online conversations BIBREF12 . These scholars have carried out experiments for the task of language identification using language models, dictionaries, logistic regression classification, Conditional Random Fields, SVMs, and noted that approaches using contextual knowledge were most robust. King and Abney king2013labeling used weakly semi-supervised methods to perform word-level language identification.

We however, use a dictionary based approach for the language identification task. While working with puns, ambiguity in language identification can be an important marker for identifying the pun, so it is more important for us to recognize all possible ambiguities rather than picking just one depending on probabilities. This ability to recognize ambiguities, and the simplicity of a dictionary-based language identification model makes it suited for this task.

## Methodology

We focus on the task of automatically disambiguating or recovering Hindi-English code mixed puns. For this purpose, it is first necessary to understand what these puns are.

## Classification

For the purposes of this research, we only consider puns where the ambiguity or the wordplay lies in the code-switching i.e, the pun word and its target are from different languages. For example the pun "Rivers can't hear because woh behri hoti hai." is a sentence with the pun being behri (meaning deaf) and its target being beh rahi (meaning flowing). Here, while the sentence is code-mixed, the pun word and the target both belong to the same language. We do not consider such puns for the present study.

We analyze the structure of code-mixed puns with the pun word and its target belonging to different languages and propose two broad categories to classify them in - puns where the code-mixing is intra-sentential and the other where it is intra-word. Both these categories are explained below, while we evaluate only on the former category.

Intra-sentential code-mixing is where code-switching occurs within a sentence. Here, the language varies at the word level. Also, each word of the sentence belongs to one or the other language. Table 1 gives examples of puns belonging to this category.

In this category, code mixing is present within a word. New words are formed using Portmanteau or Blending where two or more syllables/phonemes from different languages are blended together to form a single word, resulting in a word which is phonetically similar to the target word. Table 2 illustrates examples of intra-word code-mixed puns.

## Dataset

Most puns we hear or use in everyday conversations are rarely recorded. One of the most common resources to find recorded puns are advertisements, for example the highly creative and frequently released Amul advertisements in India BIBREF1 . Most of these are contextually integrated BIBREF0 with an image. While such puns may lose their humour out of context, it is still possible to recover their targets, so using these does not affect our task in any way

To create a dataset to test our model on, we collected 518 advertisements released by Amul in the years 2014, 2015, 2017 and 2018, from their official web page. Of these, 333 were puns, including 121 code-mixed puns as defined in Section 3.1. We extracted the text of these 121 code-mixed puns and asked 3 people to disambiguate them, given just the advertisement text. All three annotators were university students in 22-23 years age group, native Hindi speakers with bilingual fluency in English. The annotators were asked to identify the location of the pun in each of the advertisements and write down the target of the pun. Any disagreements between annotators were resolved by mutual discussion.

In a few cases where puns were identified to have multiple targets, we kept all such possibilities in our dataset. A few puns were identified to be non-recoverable because of the lack of contextual knowledge, while a few puns had multiple pun locations. We removed both these types from our dataset, which left us with 110 puns.

Finally, we divided these 110 annotated puns into the two categories as defined in Section 3.1 thereby getting 51 advertisements categorized as intra-sentential code-mixed puns, and the rest as intra-word code-mixed puns. We use the former as our test data.

## Model

For preprocessing the text we give as input to our system, we first tokenize the advertisement text using NLTK's BIBREF13 tokenizer and remove all punctuations. We then give the resultant tokens as input to our model, which is a 4 step process as described below:

At this step, we aim to identify the language of each of the tokens in the input text by classifying them into one of the 5 categories: English, Hindi, Named Entity (NE), Out of Vocabulary (OOV), or Ambiguous (words that could belong to both English and Hindi).

We use a dictionary-based lookup method to classify a word in English or Hindi. Since the input is in Roman script, to recognize Hindi words, we use a list of 30k transliterated Hindi words in Roman to their Devanagari counterparts BIBREF14 . For the English language, we collected news data from the archives of a leading Indian Newspaper, The Hindu. Data from 2012-2018 under the tags National, International, Sports, Cinema, Television was collected, amounting to 12,600 articles with 200k sentences and around 38k unique words. We use this data to build an English dictionary. Also, we used NLTK's BIBREF13 Named Entity Recognition module on the same data to get a dictionary of Named Entities.

We first try to classify all tokens as English, Hindi and NE using these dictionaries. Then, words which are found in both English and Hindi are marked as Ambiguous. The words which do not fall into any of these are classified as OOV.

We now identify all possible punning locations in the text. For this, we consider words on the boundaries of language change as candidates for pun locations. Then, all NEs and OOV words are added to the list of pun candidates as well. Third, if any Ambiguous words exist in the text, we consider it once as English and once as Hindi for the next steps.

In this step, we contextually lookup all the candidate locations using left context and right context to get a list of all words that may occur at that position. We use bi-gram language models we built using Knesser-Ney smoothing BIBREF15 . We used the data mentioned in the previous step to build the language model for English, and 100k sentences from Hindi monolingual data from BIBREF16 to build the language models for English and Hindi respectively. As it is highly likely that the left and the right context at a pun location belong to different languages, we look at each of those separately instead of taking an intersection of the left and the right context.

Lastly, at each pun location, we calculate the similarity of the word at that location with all the words that can occur at that location depending on the context and pick the most similar words as the possible targets.

To compare words belonging to two different languages on a phonetic basis, we convert both of them to WX notation BIBREF17 , which denotes a standard way to represent Indian languages in the Roman script. We transliterate our identified Hindi words from Devanagari to WX notation. To convert English words to the same notation, we use the CMU phonetic dictionary , which uses a 39 phoneme set to represent North American pronunciations of English words. We build a mapping between this phoneme set and WX notation. Whenever there was no exact parallel between CMU pronouncing dictionary's notation and WX, we used the word's Indian English pronunciation to find the closest match.

Once we converted all to WX notation, we use a modified version of Levenshtein Distance BIBREF18 to find most similar words. In this normalized version of Levenshtein distance, we account for a few features like aspirations (for example, /p/,/ph/) which are non-phonemic in English, vowel elongations, rhyme, same beginning or ending sounds.

In case of an OOV word, since it cannot be converted to WX notation due to non-availability of any phonetic transcription, we simply find the words with the least orthographic distance when written in Roman script, using a similar measure as used for phonetic distance with a few more normalizations (for example, considering 'w' and 'v' as similar).

## Results and discussion

We test the model explained in the previous section on our test dataset described in Section 3.2 and note that this method is correctly able to recover targets for 34 out of these 51 puns, or around 67% of the puns, which are very encouraging results for this complex task. Examples where the system performed successfully are given in Table 3 .

We do a thorough error analysis below for the cases our method fails for.

## Conclusion and Future work

To conclude, in this paper, we present a first-ever work on target recovery code-mixed puns. We study various puns where the word-play is a result of code-switching, and classify them into 2 categories - puns with intra-sentential code mixing and those with intra-word code mixing. We then propose a methodology to recover the targets for puns belonging to the former category, using only monolingual language data. We test our proposed approach on a small manually annotated dataset, and we see that our system was able to successfully recover 67% of the puns from the set.

In the future, we want to perform a more comprehensive evaluation of this approach on a larger, more diverse set of puns. We want to improve and extend our approach to be able to recover intra-word code-mixed puns along with the intra-sentential ones that it handles right now. After that, the system should be extended to be able to recover all kinds of puns in code-mixed language, regardless of whether the pun itself is monolingual or code-mixed.

## Acknowledgements

We thank the anonymous reviewers for their comments that helped improve this paper.
