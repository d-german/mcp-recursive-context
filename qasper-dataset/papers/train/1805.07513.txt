# Diverse Few-Shot Text Classification with Multiple Metrics

**Paper ID:** 1805.07513

## Abstract

We study few-shot learning in natural language domains. Compared to many existing works that apply either metric-based or optimization-based meta-learning to image domain with low inter-task variance, we consider a more realistic setting, where tasks are diverse. However, it imposes tremendous difficulties to existing state-of-the-art metric-based algorithms since a single metric is insufficient to capture complex task variations in natural language domain. To alleviate the problem, we propose an adaptive metric learning approach that automatically determines the best weighted combination from a set of metrics obtained from meta-training tasks for a newly seen few-shot task. Extensive quantitative evaluations on real-world sentiment analysis and dialog intent classification datasets demonstrate that the proposed method performs favorably against state-of-the-art few shot learning algorithms in terms of predictive accuracy. We make our code and data available for further study.

## Introduction

Few-shot learning (FSL) BIBREF0 , BIBREF1 , BIBREF2 aims to learn classifiers from few examples per class. Recently, deep learning has been successfully exploited for FSL via learning meta-models from a large number of meta-training tasks. These meta-models can be then used for rapid-adaptation for the target/meta-testing tasks that only have few training examples. Examples of such meta-models include: (1) metric-/similarity-based models, which learn contextual, and task-specific similarity measures BIBREF3 , BIBREF4 , BIBREF5 ; and (2) optimization-based models, which receive the input of gradients from a FSL task and predict either model parameters or parameter updates BIBREF6 , BIBREF7 , BIBREF8 , BIBREF9 .

In the past, FSL has mainly considered image domains, where all tasks are often sampled from one huge collection of data, such as Omniglot BIBREF10 and ImageNet BIBREF4 , making tasks come from a single domain thus related. Due to such a simplified setting, almost all previous works employ a common meta-model (metric-/optimization-based) for all few-shot tasks. However, this setting is far from the realistic scenarios in many real-world applications of few-shot text classification. For example, on an enterprise AI cloud service, many clients submit various tasks to train text classification models for business-specific purposes. The tasks could be classifying customers' comments or opinions on different products/services, monitoring public reactions to different policy changes, or determining users' intents in different types of personal assistant services. As most of the clients cannot collect enough data, their submitted tasks form a few-shot setting. Also, these tasks are significantly diverse, thus a common metric is insufficient to handle all these tasks.

We consider a more realistic FSL setting where tasks are diverse. In such a scenario, the optimal meta-model may vary across tasks. Our solution is based on the metric-learning approach BIBREF5 and the key idea is to maintain multiple metrics for FSL. The meta-learner selects and combines multiple metrics for learning the target task using task clustering on the meta-training tasks. During the meta-training, we propose to first partition the meta-training tasks into clusters, making the tasks in each cluster likely to be related. Then within each cluster, we train a deep embedding function as the metric. This ensures the common metric is only shared across tasks within the same cluster. Further, during meta-testing, each target FSL task is assigned to a task-specific metric, which is a linear combination of the metrics defined by different clusters. In this way, the diverse few-shot tasks can derive different metrics from the previous learning experience.

The key of the proposed FSL framework is the task clustering algorithm. Previous works BIBREF11 , BIBREF12 , BIBREF13 , BIBREF14 mainly focused on convex objectives, and assumed the number of classes is the same across different tasks (e.g. binary classification is often considered). To make task clustering (i) compatible with deep networks and (ii) able to handle tasks with a various number of labels, we propose a matrix-completion based task clustering algorithm. The algorithm utilizes task similarity measured by cross-task transfer performance, denoted by matrix $\textbf {S}$ . The $(i,j)$ -entry of $\textbf {S}$ is the estimated accuracy by adapting the learned representations on the $i$ -th (source) task to the $j$ -th (target) task. We rely on matrix completion to deal with missing and unreliable entries in $\textbf {S}$ and finally apply spectral clustering to generate the task partitions.

To the best of our knowledge, our work is the first one addressing the diverse few-shot learning problem and reporting results on real-world few-shot text classification problems. The experimental results show that the proposed algorithm provides significant gains on few-shot sentiment classification and dialog intent classification tasks. It provides positive feedback on the idea of using multiple meta-models (metrics) to handle diverse FSL tasks, as well as the proposed task clustering algorithm on automatically detecting related tasks.

## Methodology

We propose a task-clustering framework to address the diverse few-shot learning problem stated in Section "Problem Definition" . We have the FSL algorithm summarized in Algorithm UID12 . Figure 2 gives an overview of our idea. The initial step of the algorithm is a novel task clustering algorithm based on matrix completion, which is described in Section "Robust Task Clustering by Matrix Completion" . The few-shot learning method based on task clustering is then introduced in Section "Problem Definition"1 .

## Robust Task Clustering by Matrix Completion

Our task clustering algorithm is shown in Algorithm UID13 . The algorithm first evaluates the transfer performance by applying a single-task model $i$ to another task $j$ (Section UID12 ), which will result in a (partially observed) cross-task transfer performance matrix $\textbf {S}$ . The matrix $\textbf {S}$ is then cleaned and completed, giving a symmetry task similarity matrix $\textbf {Y}$ for spectral clustering BIBREF20 .

Using single-task models, we can compute performance scores $s_{ij}$ by adapting each $\mathrm {M}_i$ to each task $T_j (j\ne i)$ . This forms an $n \times n$ pair-wise classification performance matrix $\textbf {S}$ , called the transfer-performance matrix. Note that $\textbf {S}$ is asymmetric since usually $\textbf {S}_{ij} \ne \textbf {S}_{ji}$ .

[ht] InputInput OutputOutput

Meta-model $\mathcal {M} = \lbrace  C_{1:K}\ (K\ \textrm {task clusters})$ , $\mathcal {F} = \left\lbrace  f_1,f_2, \cdots , f_K \right\rbrace  \ (K\ \textrm {task encoders})\rbrace $ . One classifier $\mathrm {M^{\prime }}_{i}$ for each target task $\mathrm {T}^{\prime }$ . Robust Task Clustering: $C_{1:K}$ = RobustTC( $\mathcal {T}$ , $K$ ) (Algorithm UID13 ) Cluster-Model Training: Train one encoder (multi-task MNet) $f_i$ on each task cluster $C_i$ (Section UID22 ) Few-Shot Learning on Cluster-models: Train a model $\mathrm {M}_{trg}$ on task $\mathcal {F} = \left\lbrace  f_1,f_2, \cdots , f_K \right\rbrace  \ (K\ \textrm {task encoders})\rbrace $0 with the method in Section UID23 . RobustTC-FSL: Task Clustering for Few-Shot Learning 

Ideally, the transfer performance could be estimated by training a MNet on task $i$ and directly evaluating it on task $j$ . However, the limited training data usually lead to generally low transfer performance of single-task MNet. As a result we adopt the following approach to estimate $\textbf {S}$ :

We train a CNN classifier (Figure 1 (a)) on task $i$ , then take only the encoder $\mathrm {M}^{enc}_i$ from $\mathrm {M}_i$ and freeze it to train a classifier on task $j$ . This gives us a new task $j$ model, and we test this model on $D^{valid}_j$ to get the accuracy as the transfer-performance $\textbf {S}_{ij}$ . The score shows how the representations learned on task $i$ can be adapted to task $j$ , thus indicating the similarity between tasks.

In text classification tasks, transferring an encoder with fine-tuned word embeddings from one task to another is difficult as there can be a significant difference between the two vocabularies. Hence, while learning the single-task CNN classifiers, we always make the word embeddings fixed.

[t] InputInput OutputOutput $K$ task clusters $C_{1:K}$ Learning of Single-Task Models: train single-task models $\mathrm {M}_i$ for each task $\mathrm {T}_i$ Evaluation of Transfer-Performance Matrix: get performance matrix $\mathbf {\textbf {S}}$ (Section UID12 ) Score Filtering: Filter the uncertain scores in $\textbf {S}$ and construct the symmetric matrix $\textbf {Y}$ using Eq. ( 16 ) Matrix Completion: Complete the similar matrix $\textbf {X}$ from $\textbf {Y}$ using Eq. ( 18 ) Task Clustering: $C_{1:K}$ =SpectralClustering $C_{1:K}$0 RobustTC: Robust Task Clustering based on Matrix Completion 

Directly using the transfer performance for task clustering may suffer from both efficiency and accuracy issues. First, evaluation of all entries in the matrix $\textbf {S}$ involves conducting the source-target transfer learning $O(n^2)$ times, where $n$ is the number of meta-training tasks. For a large number of diverse tasks where the $n$ can be larger than 1,000, evaluation of the full matrix is unacceptable (over 1M entries to evaluate). Second, the estimated cross-task performance (i.e. some $\textbf {S}_{ij}$ or $\textbf {S}_{ji}$ scores) is often unreliable due to small data size or label noise. When the number of the uncertain values is large, they can collectively mislead the clustering algorithm to output an incorrect task-partition. To address the aforementioned challenges, we propose a novel task clustering algorithm based on the theory of matrix completion BIBREF21 . Specifically, we deal with the huge number of entries by randomly sample task pairs to evaluate the $\textbf {S}_{ij}$ and $\textbf {S}_{ji}$ scores. Besides, we deal with the unreliable entries and asymmetry issue by keeping only task pairs $(i,j)$ with consistent $\textbf {S}_{ij}$ and $O(n^2)$0 scores. as will be introduced in Eq. ( 16 ). Below, we describe our method in detail.

First, we use only reliable task pairs to generate a partially-observed similarity matrix $\textbf {Y}$ . Specifically, if $\textbf {S}_{ij}$ and $\textbf {S}_{ji}$ are high enough, then it is likely that tasks $\lbrace i,j\rbrace $ belong to a same cluster and share significant information. Conversely, if $\textbf {S}_{ij}$ and $\textbf {S}_{ji}$ are low enough, then they tend to belong to different clusters. To this end, we need to design a mechanism to determine if a performance is high or low enough. Since different tasks may vary in difficulty, a fixed threshold is not suitable. Hence, we define a dynamic threshold using the mean and standard deviation of the target task performance, i.e., $\mu _j = \text{mean}(\textbf {S}_{:j})$ and $\sigma _j=\text{std}(\textbf {S}_{:j})$ , where $\textbf {S}_{:j}$ is the $j$ -th column of $\textbf {S}_{ij}$0 . We then introduce two positive parameters $\textbf {S}_{ij}$1 and $\textbf {S}_{ij}$2 , and define high and low performance as $\textbf {S}_{ij}$3 greater than $\textbf {S}_{ij}$4 or lower than $\textbf {S}_{ij}$5 , respectively. When both $\textbf {S}_{ij}$6 and $\textbf {S}_{ij}$7 are high and low enough, we set their pairwise similarity as 1 and 0, respectively. Other task pairs are treated as uncertain task pairs and are marked as unobserved, and don't influence our clustering method. This leads to a partially-observed symmetric matrix $\textbf {S}_{ij}$8 , i.e., 

$$\small \textbf {Y}_{ij}\mathrm {=}\textbf {Y}_{ji}\mathrm {=}\left\lbrace 
\begin{array}{ll}
{2}{*}{1} & \text{if}\ \ \textbf {S}_{ij} > \mu _j + p_1 \sigma _j\ \ \\
&\text{and}\ \ \textbf {S}_{ji} > \mu _i + p_1 \sigma _i\\
{2}{*}{0} & \text{if}\ \ \textbf {S}_{ij} < \mu _j - p_2 \sigma _j\ \ \\
&\text{and}\ \ \textbf {S}_{ji} < \mu _i - p_2 \sigma _i\\
\mathrm {unobserved} & \mathrm {otherwise}
\end{array}
\right. $$   (Eq. 16) 

Given the partially observed matrix $\textbf {Y}$ , we then reconstruct the full similarity matrix $\textbf {X}\in \mathbb {R}^{n\times n}$ . We first note that the similarity matrix $\textbf {X}$ should be of low-rank (proof deferred to appendix). Additionally, since the observed entries of $\textbf {Y}$ are generated based on high and low enough performance, it is safe to assume that most observed entries are correct and only a few may be incorrect. Therefore, we introduce a sparse matrix $\textbf {E}$ to capture the observed incorrect entries in $\textbf {Y}$ . Combining the two observations, $\textbf {Y}$ can be decomposed into the sum of two matrices $\textbf {X}$ and $\textbf {E}$ , where $\textbf {X}$ is a low rank matrix storing similarities between task pairs, and $\textbf {X}\in \mathbb {R}^{n\times n}$0 is a sparse matrix that captures the errors in $\textbf {X}\in \mathbb {R}^{n\times n}$1 . The matrix completion problem can be cast as the following convex optimization problem: 

$$&\min \limits _{\textbf {X},\ \textbf {E}} & \Vert \textbf {X}\Vert _* + \lambda \Vert \textbf {E}\Vert _1\\ 
& \mbox{s.t.}& \textbf {P}_{\Omega }(\textbf {X}+\textbf {E}) = \textbf {P}_{\Omega }(\textbf {Y}), \nonumber $$   (Eq. 18) 

where $\Vert \circ \Vert _*$ denotes the matrix nuclear norm, the convex surrogate of rank function. $\Omega $ is the set of observed entries in $\textbf {Y}$ , and $\textbf {P}_{\Omega }:\mathbb {R}^{n\times n} \mapsto \mathbb {R}^{n\times n}$ is a matrix projection operator defined as 

$$[\textbf {P}_{\Omega }(\textbf {A})]_{ij} = \left\lbrace 
\begin{array}{ll}
\textbf {A}_{ij} & \text{if}\ (i,j) \in \Omega \nonumber \\
0 & \mbox{otherwise}\nonumber \end{array}
\right. $$   (Eq. 19) 

Finally, we apply spectral clustering on the matrix $\textbf {X}$ to get the task clusters.

In the Appendix A, we show a Theorem as well as its proof, implying that under mild conditions, the problem ( 18 ) can perfectly recover the underlying similarity matrix $\textbf {X}^*$ if the number of observed correct entries is at least $O(n \log ^2 n)$ . This theoretical guarantee implies that for a large number $n$ of training tasks, only a tiny fraction of all task pairs is needed to reliably infer similarities over all task pairs.

## Few-Shot Learning with Task Clusters

For each cluster $C_k$ , we train a multi-task MNet model (Figure 1 (b)) with all tasks in that cluster to encourage parameter sharing. The result, denoted as $f_k$ is called the cluster-encoder of cluster $C_k$ . The $k$ -th metric of the cluster is thus $\Lambda (x_1,x_2)=f_k(x_1)^{\intercal }f_k(x_2)$ .

To build a predictor $\mathrm {M}$ with access to only a limited number of training samples, we make the prediction probability by linearly combining prediction from learned cluster-encoders: 

$$p(y|x) = \sum _k \alpha _k P(y|x; f_k).$$   (Eq. 24) 

 where $f_k$ is the learned (and frozen) encoder of the $k$ -th cluster, $\lbrace \alpha _{k}\rbrace _{k=1}^{K}$ are adaptable parameters trained with few-shot training examples. And the predictor $P(y|x; f_k)$ from each cluster is 

$$\small P(y=y_l|x;f_k) = \frac{\exp \left\lbrace  f_k (x_l)^{\intercal }f_k (x) \right\rbrace  }{\sum _{i} \exp \left\lbrace  f_k (x_{i})^{\intercal }f_k (x) \right\rbrace  }$$   (Eq. 25) 

 $x_{l}$ is the corresponding training sample of label $y_{l}$ .

End-to-end joint optimization on training data becomes a popular methodology for deep learning systems, but it is not directly applicable to diverse FSL. One main reason is that deep networks could easily fit any task partitions if we optimize on training loss only, making the learned metrics not generalize, as discussed in Section "Related Work" . As a result, this work adopts a pipeline training approach and employing validation sets for task clustering. Combining reinforcement learning with meta-learning could be a potential solution to enable an end-to-end training for future work.

## Tasks and Data Sets

We test our methods by conducting experiments on two text classification data sets. We used NLTK toolkit for tokenization. The task are divided into meta-training tasks and meta-testing tasks (target tasks), where the meta-training tasks are used for clustering and cluster-encoder training. The meta-testing tasks are few-shot tasks, which are used for evaluating the method in Eq. ( 24 ).

## Amazon Review Sentiment Classification

First, following BIBREF14 , we construct multiple tasks with the multi-domain sentiment classification BIBREF22 data set. The dataset consists of Amazon product reviews for 23 types of products (see Appendix D for the details). For each product domain, we construct three binary classification tasks with different thresholds on the ratings: the tasks consider a review as positive if it belongs to one of the following buckets $=5$ stars, $>=4$ stars or $>=2$ stars. These buckets then form the basis of the task-setup, giving us 23 $\times $ 3 $=$ 69 tasks in total. For each domain we distribute the reviews uniformly to the 3 tasks. For evaluation, we select 12 (4 $\times $ 3) tasks from 4 domains (Books, DVD, Electronics, Kitchen) as the meta-testing (target) tasks out of all 23 domains. For the target tasks, we create 5-shot learning problems.

## Real-World Tasks: User Intent Classification for Dialog System

The second dataset is from an online service which trains and serves intent classification models to various clients. The dataset comprises recorded conversations between human users and dialog systems in various domains, ranging from personal assistant to complex service-ordering or customer-service request scenarios. During classification, intent-labels are assigned to user utterances (sentences). We use a total of 175 tasks from different clients, and randomly sample 10 tasks from them as our target tasks. For each meta-training task, we randomly sample 64% data into a training set, 16% into a validation set, and use the rest as the test set. The number of labels for these tasks varies a lot (from 2 to 100, see Appendix D for details), making regular $k$ -shot settings not essentially limited-resource problems (e.g., 5-shot on 100 classes will give a good amount of 500 training instances). Hence, to adapt this to a FSL scenario, for target tasks we keep one example for each label (one-shot), plus 20 randomly picked labeled examples to create the training data. We believe this is a fairly realistic estimate of labeled examples one client could provide easily.

Our matrix-completion method could handle a large number of tasks via task-pair sampling. However, the sizes of tasks in the above two few-shot learning datasets are not too huge, so evaluation of the whole task-similarity matrix is still tractable. In our experiments, the incomplete matrices mainly come from the score-filtering step (see Eq. 16 ). Thus there is limited randomness involved in the generation of task clusters.

To strengthen the conclusion, we evaluate our algorithm on an additional dataset with a much larger number of tasks. The results are reported in the multi-task learning setting instead of the few-shot learning setting focused in this paper. Therefore we put the results to a non-archive version of this paper for further reference.

## Experiment Setup

We compare our method to the following baselines: (1) Single-task CNN: training a CNN model for each task individually; (2) Single-task FastText: training one FastText model BIBREF23 with fixed embeddings for each individual task; (3) Fine-tuned the holistic MTL-CNN: a standard transfer-learning approach, which trains one MTL-CNN model on all the training tasks offline, then fine-tunes the classifier layer (i.e. $\mathrm {M}^{(cls)}$ Figure 1 (a)) on each target task; (4) Matching Network: a metric-learning based few-shot learning model trained on all training tasks; (5) Prototypical Network: a variation of matching network with different prediction function as Eq. 9 ; (6) Convex combining all single-task models: training one CNN classifier on each meta-training task individually and taking the encoder, then for each target task training a linear combination of all the above single-task encoders with Eq. ( 24 ). This baseline can be viewed as a variation of our method without task clustering. We initialize all models with pre-trained 100-dim Glove embeddings (trained on 6B corpus) BIBREF24 .

In all experiments, we set both $p_1$ and $p_2$ parameters in ( 16 ) to $0.5$ . This strikes a balance between obtaining enough observed entries in $\textbf {Y}$ , and ensuring that most of the retained similarities are consistent with the cluster membership. The window/hidden-layer sizes of CNN and the initialization of embeddings (random or pre-trained) are tuned during the cluster-encoder training phase, with the validation sets of meta-training tasks. We have the CNN with window size of 5 and 200 hidden units. The single-metric FSL baselines have 400 hidden units in the CNN encoders. On sentiment classification, all cluster-encoders use random initialized word embeddings for sentiment classification, and use Glove embeddings as initialization for intent classification, which is likely because the training sets of the intent tasks are usually small.

Since all the sentiment classification tasks are binary classification based on our dataset construction. A CNN classifier with binary output layer can be also trained as the cluster-encoder for each task cluster. Therefore we compared CNN classifier, matching network, and prototypical network on Amazon review, and found that CNN classifier performs similarly well as prototypical network. Since some of the Amazon review data is quite large which involves further difficulty on the computation of supporting sets, we finally use binary CNN classifiers as cluster-encoders in all the sentiment classification experiments.

Selection of the learning rate and number of training epochs for FSL settings, i.e., fitting $\alpha $ s in Eq. ( 24 ), is more difficult since there is no validation data in few-shot problems. Thus we pre-select a subset of meta-training tasks as meta-validation tasks and tune the two hyper-parameters on the meta-validation tasks.

## Experimental Results

Table 1 shows the main results on (i) the 12 few-shot product sentiment classification tasks by leveraging the learned knowledge from the 57 previously observed tasks from other product domains; and (ii) the 10 few-shot dialog intent classification tasks by leveraging the 165 previously observed tasks from other clients' data.

Due to the limited training resources, all the supervised-learning baselines perform poorly. The two state-of-the-art metric-based FSL approaches, matching network (4) and prototypical network (5), do not perform better compared to the other baselines, since the single metric is not sufficient for all the diverse tasks. On intent classification where tasks are further diverse, all the single-metric or single-model methods (3-5) perform worse compared to the single-task CNN baseline (1). The convex combination of all the single training task models is the best performing baseline overall. However, on intent classification it only performs on par with the single-task CNN (1), which does not use any meta-learning or transfer learning techniques, mainly for two reasons: (i) with the growth of the number of meta-training tasks, the model parameters grow linearly, making the number of parameters (165 in this case) in Eq.( 24 ) too large for the few-shot tasks to fit; (ii) the meta-training tasks in intent classification usually contain less training data, making the single-task encoders not generalize well.

In contrast, our RobustTC-FSL gives consistently better results compared to all the baselines. It outperforms the baselines in previous work (1-5) by a large margin of more than 6% on the sentiment classification tasks, and more than 3% on the intent classification tasks. It is also significantly better than our proposed baseline (6), showing the advantages of the usage of task clustering.

Although the RobustTC-FSL improves over baselines on intent classification, the margin is smaller compared to that on sentiment classification, because the intent classification tasks are more diverse in nature. This is also demonstrated by the training accuracy on the target tasks, where several tasks fail to find any cluster that could provide a metric that suits their training examples. To deal with this problem, we propose an improved algorithm to automatically discover whether a target task belongs to none of the task-clusters. If the task doesn't belong to any of the clusters, it cannot benefit from any previous knowledge thus falls back to single-task CNN. The target task is treated as “out-of-clusters” when none of the clusters could achieve higher than 20% accuracy (selected on meta-validation tasks) on its training data. We call this method Adaptive RobustTC-FSL, which gives more than 5% performance boost over the best RobustTC-FSL result on intent classification. Note that the adaptive approach makes no difference on the sentiment tasks, because they are more closely related so re-using cluster-encoders always achieves better results compared to single-task CNNs.

## Analysis

Figure 3 shows the effect of cluster numbers on the two tasks. RobustTC achieves best performance with 5 clusters on sentiment analysis (SA) and 20 clusters on intent classification (Intent). All clustering results significantly outperform the single-metric baselines (#cluster=1 in the figure).

Compared to previous task clustering algorithms, our RobustTC is the only one that can cluster tasks with varying numbers of class labels (e.g. in intent classification tasks). Moreover, we show that even in the setting of all binary classifications tasks (e.g. the sentiment-analysis tasks) that previous task clustering research work on, our RobustTC is still slightly better for the diverse FSL problems. Figure 3 compares with a state-of-the-art logistic regression based task clustering method (ASAP-MT-LR) BIBREF14 . Our RobustTC clusters give slightly better FSL performance (e.g. 83.12 vs. 82.65 when #cluster=5).

The top rows of Table 2 shows the ten clusters used to generate the sentiment classification results in Figure 3 . From the results, we can see that tasks with same thresholds are usually grouped together; and tasks in similar domains also tend to appear in the same clusters, even the thresholds are slightly different (e.g. t2 vs t4 and t4 vs t5).

The bottom of the table shows the weights $\alpha $ s in Eq.( 24 ) for the target tasks with the largest improvement. It confirms that our RobustTC-FSL algorithm accurately adapts multiple metrics for the target tasks.

## Related Work

Few Shot Learning FSL BIBREF0 , BIBREF1 , BIBREF2 aims to learn classifiers for new classes with only a few training examples per class. Recent deep learning based FSL approaches mainly fall into two categories: (1) metric-based approaches BIBREF3 , BIBREF4 , BIBREF5 , which aims to learn generalizable metrics and corresponding matching functions from multiple training tasks. These approaches essentially learn one metric for all tasks, which is sub-optimal when the tasks are diverse. (2) optimization-based approaches BIBREF6 , BIBREF7 , BIBREF8 , which aims to learn to optimize model parameters (by either predicting the parameter updates or directly predicting the model parameters) given the gradients computed from few-shot examples.

Previous FSL research usually adopts the $k$ -shot, $N$ -way setting, where all the few-shot tasks have the same number of $N$ class labels, and each label has $k$ training instances. Moreover, these few-shot tasks are usually constructed by sampling from one huge dataset, thus all the tasks are guaranteed to be related to each other. However, in real-world applications, the few-shot learning tasks could be diverse: there are different tasks with varying number of class labels and they are not guaranteed to be related to each other. As a result, a single meta-model or metric-model is usually not sufficient to handle all the few-shot tasks.

Task Clustering Previous task clustering methods measure the task relationships in terms of similarities among single-task model parameters BIBREF11 , BIBREF12 ; or jointly assign task clusters and train model parameters for each cluster to minimize the overall training loss BIBREF13 , BIBREF14 , BIBREF25 . These methods usually work on convex models but do not fit the deep networks, mainly because of (i) the parameters of deep networks are very high-dimensional and their similarities are not necessarily related to the functional similarities; and (ii) deep networks have flexible representation power so they may overfit to arbitrary cluster assignment if we consider training loss alone. Moreover, these methods require identical class label sets across different tasks, which does not hold in most of the realistic settings.

## Conclusion

We propose a few-shot learning approach for diverse tasks based on task clustering. The proposed method can use multiple metrics, and performs significantly better compared to previous single-metric methods when the few-shot tasks come from diverse domains. Future work includes applying the task-clustering idea to other FSL algorithms BIBREF6 , BIBREF8 , BIBREF26 , and exploring more advanced composition methods of cluster-encoders beyond linear combination BIBREF27 , BIBREF28 .
