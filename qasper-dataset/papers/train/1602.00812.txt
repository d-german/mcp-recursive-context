# The Grail theorem prover: Type theory for syntax and semantics

**Paper ID:** 1602.00812

## Abstract

As the name suggests, type-logical grammars are a grammar formalism based on logic and type theory. From the prespective of grammar design, type-logical grammars develop the syntactic and semantic aspects of linguistic phenomena hand-in-hand, letting the desired semantics of an expression inform the syntactic type and vice versa. Prototypical examples of the successful application of type-logical grammars to the syntax-semantics interface include coordination, quantifier scope and extraction.This chapter describes the Grail theorem prover, a series of tools for designing and testing grammars in various modern type-logical grammars which functions as a tool . All tools described in this chapter are freely available.

## Introduction

This chapter describes a series of tools for developing and testing type-logical grammars. The Grail family of theorem provers have been designed to work with a variety of modern type-logical frameworks, including multimodal type-logical grammars BIBREF0 , NL $_{cl}$ BIBREF1 , the Displacement calculus BIBREF2 and hybrid type-logical grammars BIBREF3 .

The tools give a transparent way of implementing grammars and testing their consequences, providing a natural deduction proof in the specific type-logical grammar for each of the readings of a sentence. None of this replaces careful reflection by the grammar writer, of course, but in many cases, computational testing of hand-written grammars will reveal surprises, showing unintended consequences of our grammar and such unintended proofs (or unintended absences of proofs) help us improve the grammar. Computational tools also help us speed up grammar development, for example by allowing us to compare several alternative solutions to a problem and investigate where they make different predictions.

This chapter describes the underlying formalism of the theorem provers, as it is visible during an interactive proof trace, and present the general strategy followed by the theorem provers. The presentation in this chapter is somewhat informal, referring the reader elsewhere for full proofs.

The rest of this chapter is structured as follows. Section "Type-logical grammars" presents a general introduction to type-logical grammars and illustrates its basic concepts using the Lambek calculus, ending the section with some problems at the syntax-semantics interface for the Lambek calculus. Section "Modern type-logical grammars" looks at recent developments in type-logical grammars and how they solve some of the problems at the syntax-semantics interface. Section "Theorem proving" looks at two general frameworks for automated theorem proving for type-logical grammars, describing the internal representation of partial proofs and giving a high-level overview of the proof search mechanism.

## Type-logical grammars

Type-logical grammars are a family of grammar formalisms built on a foundation of logic and type theory. Type-logical grammars originated when BIBREF4 introduced his Syntactic Calculus (called the Lambek calculus, L, by later authors). Though Lambek built on the work of BIBREF5 , BIBREF6 and others, Lambek's main innovation was to cast the calculus as a logic, giving a sequent calculus and showing decidability by means of cut elimination. This combination of linguistic and computational applications has proved very influential.

In its general form, a type-logical grammar consists of following components:

A sentence $w_1, \ldots , w_n$ is grammatical iff the statement $A_1,\ldots , A_n \vdash C$ is provable in our logic, for some $A_i
\in \textit {lex}(w_i)$ and for some goal formula $C$ . In other words, we use the lexicon to map words to formulas and then ask the logic whether the resulting sequence of formulas is a theorem. Parsing in a type-logical grammar is quite literally a form of theorem proving, a very pure realisation of the slogan “parsing as deduction”.

One of the attractive aspects of type-logical grammars is their simple and transparent syntax-semantics interface. Though there is a variety of logics used for the syntax of type-logical grammars (I will discuss the Lambek calculus in Section "The Lambek calculus" and two generalisations of it in Sections "Multimodal grammars" and "First-order linear logic" ), there is a large consensus over the syntax-semantics interface. Figure 1 gives a picture of the standard architecture of type-logical grammars.

The “bridge” between syntax and semantics in the figure is the Curry-Howard isomorphism between linear lambda terms and proofs in multiplicative intuitionistic linear logic.

Theorem proving occurs in two places of the picture: first when parsing a sentence in a given type-logical grammar and also at the end when we use the resulting semantics for inferences. I will have little to say about this second type of theorem proving BIBREF9 , BIBREF10 ; theorem proving for parsing will be discussed in Section "Theorem proving" .

The lexicon plays the role of translating words to syntactic formulas but also specifies the semantic term which is used to compute the semantics later. The lexicon of a categorial grammar is “semantically informed”. The desired semantics of a sentence allows us to reverse-engineer the formula and lexical lambda-term which produce it.

Many current semantic theories do not provide a semantic formula directly, but first provide a proto-semantics on which further computations are performed to produce the final semantics (eg. for anaphora resolution, presuppositions projection etc.). In the current context this means at least some inference is necessary to determine semantic and pragmatic wellformedness.

## The Lambek calculus

To make things more concrete, I will start by presenting the Lambek calculus BIBREF4 . Lambek introduced his calculus as a way to “obtain an effective rule (or algorithm) for distinguishing sentences from nonsentences”, which would be applicable both to formal and to (at least fragments of) natural languages BIBREF4 . The simplest formulas used in the Lambek calculus are atomic formulas, which normally include $s$ for sentence, $n$ for common noun, $np$ for noun phrase. We then inductively define the set of formulas of the Lambek calculus by saying that, they include the atomic formulas, and that, if $A$ and $B$ are formulas (atomic or not), then $A/B$ , $A\bullet B$ and $B\backslash A$ are also formulas.

The intended meaning of a formula $A/B$ — called $A$ over $B$ — is that it is looking for an expression of syntactic type $B$ to its right to produce an expression of syntactic type $A$ . An example would be a word like “the” which is assigned the formula $np/n$ in the lexicon, indicating that it is looking for a common noun (like “student”) to its right to form a noun phrase, meaning “the student” would be assigned syntactic type $np$ . Similarly, the intended meaning of a formula $B\backslash A$ — called $B$ under $A$ — is that it is looking for an expression of syntactic type $A$0 to its left to produce an expression of type $A$1 . This means an intransitive verb like “slept”, when assigned the formula $A$2 in the lexicon, combines with a noun phrase to its left to form a sentence $A$3 . We therefore predict that “the student slept” is a sentence, given the earlier assignment of $A$4 to “the student”. Finally, a formula $A$5 denotes the concatenation of an expression of type $A$6 to an expression of type $A$7 .

Basic statements of the Lambek calculus are of the form $A_1,\ldots ,A_n \vdash C$ (with $n
\ge 1$ ), indicating a claim that the sequence of formulas $A_1,\ldots , A_n$ is of type $C$ ; the sequent comma `,' is implicitly associative and non-commutative. Table 1 shows the natural deduction rules for the Lambek calculus. $\Gamma $ , $\Delta $ , etc. denote non-empty sequences of formulas.

A simple Lambek calculus lexicon is shown in Table 2 . I have adopted the standard convention in type-logical grammars of not using set notation for the lexicon, but instead listing multiple lexical entries for a word separately. This corresponds to treating $\textit {lex}$ as a non-deterministic function rather than as a set-valued function.

Proper names, such as “Alyssa” and “Emory” are assigned the category $np$ . Common nouns, such as “student” and “exam” are assigned the category $n$ . Adjectives, such as “difficult” or “erratic” are not assigned a basic syntactic category but rather the category $n/n$ , indicating they are looking for a common noun to their right to form a new common noun, so we predict that both “difficult exam” and “exam” can be assigned category $n$ . For more complex entries, “someone” is looking to its right for a verb phrase to produce a sentence, where $np\backslash s$ is the Lambek calculus equivalent of verb phrase, whereas “whom” is first looking to its right for a sentence which is itself missing a noun phrase to its right and then to its left for a noun.

Given the lexicon of Table 2 , we can already derive some fairly complex sentences, such as the following, and, as we will see in the next section, obtain the correct semantics.

. Every student aced some exam.

. The student who slept during the exam loves Alyssa.

One of the two derivations of Sentence "The Lambek calculus" is shown in Figure 2 . To improve readability, the figure uses a “sugared” notation: instead of writing the lexical hypothesis corresponding to “exam” as $n \vdash n$ , we have written it as $\textit {exam} \vdash n$ . The withdrawn $np$ 's corresponding to the object and the subject are given a labels $p_0$ and $q_0$ respectively; the introduction rules are coindexed with the withdrawn hypotheses, even though this information can be inferred from the rule instantiation.

We can always uniquely reconstruct the antecedent from the labels. For example, the sugared statement “ $p_0\ \textrm {aced}\ q_0 \vdash s$ ” in the proof corresponds to $np, (np\backslash s)/np, np \vdash s$ .

Although it is easy to verify that the proof of Figure 2 has correctly applied the rules of the Lambek calculus, finding such a proof from scratch may look a bit complicated (the key steps at the beginning of the proof involve introducing two $np$ hypotheses and then deriving $s/np$ to allow the object quantifier to take narrow scope). We will defer the question “given a statement $\Gamma \vdash C$ , how do we decide whether or not it is derivable?” to Section "Theorem proving" but will first discuss how this proof corresponds to the following logical formula. $
\forall x. [\mathit {student}(x) \Rightarrow \exists y. [\mathit {exam}(y) \wedge \mathit {ace}(x,y) ] ]
$ 

## The syntax-semantics interface

For the Lambek calculus, specifying the homomorphism to multiplicative intuitionistic linear logic is easy: we replace the two implications ` $\backslash $ ' and ` $/$ ' by the linear implication ` $\multimap $ ' and the product ` $\bullet $ ' by the tensor ` $\otimes $ '. In a statement $\Gamma \vdash C$ , $\Gamma $ is now a multiset of formulas instead of a sequence. In other words, the sequent comma `,' is now associative, commutative instead of associative, non-commutative. For the proof of Figure 2 of the previous section, this mapping gives the proof shown in Figure 3 .

We have kept the order of the premisses of the rules as they were in Figure 2 to allow for an easier comparison. This deep structure still uses the same atomic formulas as the Lambek calculus, it just forgets about the order of the formulas and therefore can no longer distinguish between the leftward looking implication ` $\backslash $ ' and the rightward looking implication ` $/$ '.

To obtain a semantics in the tradition of BIBREF11 , we use the following mapping from syntactic types to semantic types, using Montague's atomic types $e$ (for entity) and $t$ (for truth value). $
np^* & = e\\
n^* & = e\rightarrow t\\
s^* & = t\\
(A \multimap B)^* & = A^* \rightarrow B^*
$ 

Applying this mapping to the deep structure proof of Figure 3 produces the intuitionistic proof and the corresponding (linear) lambda term as shown in Figure 4 

The computed term corresponds to the derivational semantics of the proof. To obtain the complete meaning, we need to substitute, for each of $z_0, \ldots , z_4$ , the meaning assigned in the lexicon.

For example, “every” has syntactic type $(s/(np\backslash s))/n$ and its semantic type is $(e\rightarrow t)\rightarrow (e\rightarrow t)\rightarrow t$ . The corresponding lexical lambda term of this type is $\lambda P^{e\rightarrow t}.\lambda Q^{e\rightarrow t}. (\forall (\lambda x^e. ((\Rightarrow (P\, x)) (Q\, x))))$ , with ` $\forall $ ' a constant of type $(e\rightarrow t)\rightarrow t$ and ` $\Rightarrow $ ' a constant of type $t\rightarrow (t\rightarrow t)$ . In the more familiar Montague formulation, this lexical term corresponds to $\lambda P^{e\rightarrow t}.\lambda Q^{e\rightarrow t}. \forall x. [ (P\, x)
\Rightarrow (Q\,x)]$ , where we can see the formula in higher-order logic we are constructing more clearly. Although the derivational semantics is a linear lambda term, the lexical term assigned to “every” is not, since the variable $x$ has two bound occurrences.

The formula assigned to “some” has the same semantic type but a different term $\lambda P^{e\rightarrow t}.\lambda Q^{e\rightarrow t}. (\exists (\lambda x^e. ((\wedge (P\, x)) (Q\, x))))$ .

The other words are simple, “exam” is assigned $\mathit {exam}^{e\rightarrow t}$ , “student” is assigned $\mathit {student}^{e\rightarrow t}$ , and “aced” is assigned $\mathit {ace}^{e\rightarrow (e\rightarrow t)}$ .

So to compute the meaning, we start with the derivational semantics, repeated below. $
((z_0\,z_1) \,(\lambda x. ((z_3\,z_4)\,\lambda y. ((z_2\,y)\,x))))
$ 

Then we substitute the lexical meanings, for $z_0,\ldots ,z_4$ . $
z_0& := \lambda P^{e\rightarrow t}.\lambda Q^{e\rightarrow t}. (\forall (\lambda x^e. ((\Rightarrow (P\, x)) (Q\, x))))\\
z_1&:= \mathit {student}^{e\rightarrow t}\\
z_2& := \mathit {ace}^{e\rightarrow (e\rightarrow t)}\\
z_3& := \lambda P^{e\rightarrow t}.\lambda Q^{e\rightarrow t}. (\exists (\lambda x^e. ((\wedge (P\, x)) (Q\, x))))\\
z_4& := \mathit {exam}^{e\rightarrow t}\\
$ 

This produces the following lambda term. $
((\lambda P^{e\rightarrow t}.\lambda Q^{e\rightarrow t}. & (\forall (\lambda x^e. ((\Rightarrow (P\, x)) (Q\,
x))))\,\mathit {student}^{e\rightarrow t}) \\
\,(\lambda x. ((\lambda P^{e\rightarrow t}.\lambda Q^{e\rightarrow t}. & (\exists (\lambda x^e. ((\wedge (P\,
x)) (Q\,
x))))\,\mathit {exam}^{e\rightarrow t})\\
&\lambda y. ((\mathit {ace}^{e\rightarrow (e\rightarrow t)}\,y)\,x))))
$ 

Finally, when we normalise this lambda term, we obtain the following semantics for this sentence. $
(\forall (\lambda x^e. ((\Rightarrow (\mathit {student}^{e\rightarrow t})\, x)) (\exists (\lambda y^e. ((\wedge (\mathit {exam}^{e\rightarrow t}\,
y)) (((\mathit {ace}^{e\rightarrow (e\rightarrow t)}\,y)\,x)))))
$ 

This lambda term represents the more readable higher-order logic formula. $
\forall x. [\mathit {student}(x) \Rightarrow \exists y. [\mathit {exam}(y) \wedge \mathit {ace}(x,y) ] ]
$ 

Proofs in the Lambek calculus, and in type-logical grammars are subsets of the proofs in intuitionistic (linear) logic and these proofs are compatible with formal semantics in the tradition initiated by BIBREF11 .

For the example in this section, we have calculated the semantics of a simple example in “slow motion”: many authors assign a lambda term directly to a proof in their type-logical grammar, leaving the translation to intuitionistic linear logic implicit.

Given a semantic analysis without a corresponding syntactic proof, we can try to reverse engineer the syntactic proof. For example, suppose we want to assign the reflexive “himself” the lambda term $\lambda R^{(e\rightarrow e\rightarrow t)}\lambda x^e. ((R\,x)\, x)$ , that is, a term of type $(e\rightarrow e\rightarrow t)\rightarrow e\rightarrow t$ . Then, using some syntactic reasoning to eliminate implausible candidates like $(np\multimap n)\multimap n$ , the only reasonable deep structure formula is $(np\multimap np\multimap s)\multimap (np\multimap s)$ and, reasoning a bit further about which of the implications is left and right, we quickly end up with the quite reasonable (though far from perfect) Lambek calculus formula $((np\backslash s)/np)\backslash (np\backslash s)$ .

## Going further

Though the Lambek calculus is a beautiful and simple logic and though it gives a reasonable account of many interesting phenomena on the syntax-semantics interface, the Lambek calculus has a number of problems, which I will discuss briefly below. The driving force of research in type-logical grammars since the eighties has been to find solutions to these problems and some of these solutions will be the main theme of the next section.

The Lambek calculus generates only context-free languages BIBREF12 . There is a rather large consensus that natural languages are best described by a class of languages at least slightly larger than the context-free languages. Classical examples of phenomena better analysed using so-called mildly context-sensitive language include verb clusters in Dutch and in Swiss German BIBREF13 , BIBREF14 .

Though our example grammar correctly predicted two readings for Sentence "The Lambek calculus" above, our treatment of quantifiers doesn't scale well. For example, if we want to predict two readings for the following sentence (which is just Sentence "The Lambek calculus" where “some” and “every” have exchanged position)

. Some student aced every exam.

then we need to add an additional lexical entry both for “some” and for “every”; this is easily done, but we end up with two lexical formulas for both words. However, this would still not be enough. For example, the following sentence is also grammatical.

. Alyssa gave every student a difficult exam.

. Alyssa believes a student committed perjury.

In Sentence UID18 , “every student” does not occur in a peripheral position, and though it is possible to add a more complex formula with the correct behaviour, we would need yet another formula for Sentence UID18 . Sentence UID18 is generally considered to have two readings: a de dicto reading, where Alyssa doesn't have a specific student in mind (she could conclude this, for example, when two students make contradictory statements under oath, this reading can be felicitously followed by “but she doesn't know which”), and a de re reading where Alyssa believes a specific student perjured. The Lambek calculus cannot generate this second reading without adding yet another formula for “a”.

It seems we are on the wrong track when we need to add a new lexical entry for each different context in which a quantifier phrase occurs. Ideally, we would like a single formula for “every”, “some” and “a” which applied in all these different cases.

Another way to see this is that we want to keep the deep structure formula $n\multimap ((np\multimap s) \multimap s)$ and that we need to replace the Lambek calculus by another logic such that the correct deep structures for the desired readings of sentences like UID18 and UID18 are produced.

The grammar above also overgenerates in several ways.

“ace” implies a (very positive) form of evaluation with respect to the object. “aced the exam” is good, whereas “aced Emory”, outside of the context of a tennis match is bad. “aced logic” can only mean something like “aced the exam for the logic course”.

“during” and similar temporal adverbs imply its argument is a temporal interval: “during the exam” is good, but “during the student” is bad, and “during logic” can only mean something like “during the contextually understood logic lecture”

In the literature on semantics, there has been an influential movement towards a richer ontology of types (compared to the “flat” Montagovian picture presented above) but also towards a richer set of operations for combining terms of specific types, notably allowing type coercions BIBREF15 , BIBREF16 . So an “exam” can be “difficult” (it subject matter, or informational content) but also “take a long time” (the event of taking the exam). The theory of semantics outlined in the previous section needs to be extended if we want to take these and other observations into account.

## Modern type-logical grammars

We ended the last section with some problems with using the Lambek calculus as a theory of the syntax-semantics interface. The problems are of two different kinds.

## Multimodal grammars

Multimodal type-logical grammars BIBREF0 take the non-associative Lambek calculus as its base, but allow multiple families of connectives.

For the basic statements $\Gamma \vdash C$ of the Lambek calculus, we ask the question whether we can derive formula $C$ , the succedent, from a sequence of formulas $\Gamma $ , the antecedent. In the multimodal Lambek calculus, the basic objects are labeled binary trees. The labels come from a separate set of indices or modes $I$ . Multimodal formulas are then of the form $A/_i
B$ , $A\bullet _i B$ and $A\backslash _i B$ , and antecedent terms are of the form $\Gamma  \circ _{i} \Delta $ , with $C$0 an index from $C$1 (we have omitted the outer brackets for the rules, but the operator $C$2 is non-associative). Sequents are still written as $C$3 , but $C$4 is now a binary branching, labeled tree with formulas as its leaves.

Given a set of words $w_1,\ldots ,w_n$ and a goal formula $C$ , the question is now: is there a labeled tree $\Gamma $ with formulas $A_1,\ldots ,A_n$ as its yield, such that $\Gamma \vdash C$ is derivable and $A_i \in \textit {lex}(w_i)$ for all $i$ (the implementation of Section "Multimodal proof nets" will automatically compute such a $\Gamma $ ).

The rules of multimodal type-logical grammars are shown in Table 3 . In the rules, $\Gamma [\Delta ]$ denotes an antecedent tree $\Gamma $ with distinguished subtree $\Delta $ — the subtree notation is a non-associative version of the Lambek calculus antecedent $\Gamma ,\Delta ,\Gamma ^{\prime }$ , where $\Delta $ is a subsequence instead of a subtree as it is in $\Gamma [\Delta ]$ .

Each logical connective with mode $i$ uses a structural connective $\circ _i$ in its rule. For the $/ E$ , $\bullet I$ and $\backslash E$ rules, reading from premisses to conclusions, we build structure. For the $/I$ , $\bullet E$ and $\backslash I$ rules we remove a structural connective with the same mode as the logical connective. The natural deduction rules use explicit antecedents, although, for convenience, we will again use coindexation between the introduction rules for the implications ` $/$ ' and ` $\backslash $ ' and its withdrawn premiss (and similarly for the $\circ _i$0 rule and its two premisses).

The main advantage of adding modes to the logic is that modes allow us to control the application of structural rules lexically. This gives us fine-grained control over the structural rules in our logic.

For example, the base logic is non-associative. Without structural rules, the sequent $a/b, b/c \vdash a/c$ , which is derivable in the Lambek calculus is not derivable in its multimodal incarnation $a/_a b, b/_a c \vdash a/_a c$ . The proof attempt below, with the failed rule application marked by the `' symbol, shows us that the elimination rules and the introduction rule for this sequent do not match up correctly. $
[[/ I]]{a/_ab \circ _{a} b/_ac\vdash a/_a c
}{[\text{}]{(a/_ab \circ _{a} b/_ac) \circ _{a} c \vdash a}{[[/ E]]{a/_a b \circ _{a} (b/_a c \circ _{a} c)\vdash a}{a/_a b\vdash a/_a b & [[/ E]]{b/_a c \circ _{a} c \vdash b}{b/_a
c \vdash b/_a c & c\vdash c}}}}
$ 

This is where the structural rules, shown at the bottom of Table 3 come in. The general form, read from top to bottom, states that we take a structure $\Gamma $ containing a distinguished subtree $\Xi $ which itself has $n$ subtrees $\Delta _1,\ldots ,\Delta _n$ , and we replace this subtree $\Xi $ with a subtree $\Xi ^{\prime }$ which has the same number of subtrees, though not necessarily in the same order ( $\pi $ is a permutation on the leaves). In brief, we replace a subtree $\Xi $ by another subtree $\Xi ^{\prime }$ and possibly rearrange the leaves (subtrees) of $\Xi $ , without deleting or copying any subtrees. Examples of structural rules are the following.

The first structural rule is one of the structural rules for associativity. It is the simplest rule which will make the proof attempt above valid (with $\Gamma []$ the empty context, $\Delta _1 = a/_a
b$ , $\Delta _2 = b/_a c$ and $\Delta _3 = c$ ). This structural rule keeps the order of the $\Delta _i$ the same.

The rule above on the right is slightly more complicated. There, the positions of $\Delta _2$ and $\Delta _3$ are swapped as are the relative positions of modes 0 and 1. Rules like this are called “mixed commutativity”, they permit controlled access to permutation. One way to see this rule, seen from top to bottom, is that is “moves out” a $\Delta _3$ constituent which is on the right branch of mode 1. Rules of this kind are part of the solution to phenomena like Dutch verb clusters BIBREF17 .

Many modern type-logical grammars, such as the Displacement calculus and NL $_{cl}$ can be seen as multimodal grammars BIBREF18 , BIBREF1 .

## First-order linear logic

We have seen that multimodal type-logical grammars generalise the Lambek calculus by offering the possibility of fine-tuned controlled over the application of structural rules. In this section, I will introduce a second way of extending the Lambek calculus.

Many parsing algorithms use pairs of integers to represent the start and end position of substrings of the input string. For example, we can represent the sentence

. Alyssa believes someone committed perjury.

as follows (this is a slightly simplified version of Sentence UID18 from Section "Going further" ); we have treated “committed perjury” as a single word.

[node distance=5em] 0) 0; 1) [right of=0]1; 2) [right of=1]2; 3) [right of=2]3; 4) [node distance=10em, right of=3]4; (0) edge node[above] [label] Alyssa (1); (1) edge node[above] [label] believes $_{\rule {0pt}{1ex}}$ (2); (2) edge node[above] [label] someone $_{\rule {0pt}{1ex}}$ (3); (3) edge node[above] [label] committed perjury $_{\rule {0pt}{1ex}}$ (4);

The basic idea of first-order linear logic as a type-logical grammar is that we can code strings as pairs (or, more generally, tuples) of integers representing string positions. So for deciding the grammaticality of a sequence of words $w_1,\ldots , w_n \vdash C$ , with a goal formula $C$ , we now give a parametric translation from $\Vert 
A_i \Vert ^{i-1,i}$ for each lexical entry $w_i$ and $\Vert  C\Vert ^{0,n}$ for the conclusion formula.

Given these string positions, we can assign the noun phrase “Alyssa” the formula $np(0,1)$ , that is a noun phrase from position 0 to position 1. The verb “believes”, which occurs above between position 1 and 2, can then be assigned the complex formula $\forall x_2. [
s(2,x_2) \multimap \forall x_1. [ np(x_1,1) \multimap s(x_1,x_2)] ]$ , meaning that it first selects a sentence to its right (that is, starting at its right edge, position 2 and ending anywhere) and then a noun phrase to its left (that is, starting anywhere and ending at its left edge, position 1) to produce a sentence from the left position of the noun phrase argument to the right position of the sentence argument.

We can systematise this translation, following BIBREF19 , and obtain the following translation from Lambek calculus formulas to first-order linear logic formulas. $
\Vert  p \Vert ^{x,y} & = p(x,y) \\
\Vert  A / B \Vert ^{x,y} &= \forall z. \Vert  B \Vert ^{y,z} \multimap \Vert  A \Vert ^{x,z}
\\
\Vert  B\backslash A \Vert ^{y,z} &= \forall x. \Vert  B \Vert ^{x,y} \multimap \Vert  A \Vert ^{x,z}
\\
\Vert  A \bullet B \Vert ^{x,z} &= \exists y. \Vert  A \Vert ^{x,y} \otimes \Vert  B
\Vert ^{y,z}
$ 

Given this translation, the lexical entry for “believes” discussed above is simply the translation of the Lambek calculus formula $(np\backslash s)/s$ , with position pair $1,2$ , to first-order linear logic. Doing the same for “committed perjury” with formula $np\backslash s$ and positions $3,4$ gives $\forall z. [np(z,3) \multimap s(z,4)]$ . For “someone” we would simply translate the Lambek calculus formula $s/(np\backslash s)$ , but we can do better than that: when we translate “someone” as $\forall y_1. \forall y_2. [ (np(2,3) \multimap s(y_1,y_2)) \multimap s(y_1,y_2) ]$ , we improve upon the Lambek calculus analysis.

As we noted in Section "Going further" , the Lambek calculus cannot generate the “de re” reading, where the existential quantifier has wide scope. Figure 5 shows how the simple first-order linear logic analysis does derive this reading.

Besides the Lambek calculus, first-order linear logic has many other modern type-logical grammars as fragments. Examples include lambda grammars BIBREF20 , the Displacement calculus BIBREF2 and hybrid type-logical grammars BIBREF3 . We can see first-order linear logic as a sort of “machine language” underlying these different formalisms, with each formalism introducing its own set of abbreviations convenient for the grammar writer. Seeing first-order linear logic as an underlying language allows us to compare the analyses proposed for different formalisms and find, in spite of different starting points, a lot of convergence. In addition, as discussed in Section "First-order proof nets" , we can use first-order linear logic as a uniform proof strategy for these formalisms.

As usual, we obtain the deep structure of a syntactic derivation by defining a homomorphism from the syntactic proof to a proof in multiplicative intuitionistic linear logic. For first-order linear logic, the natural mapping simply forgets all first-order quantifiers and replaces all atomic predicates $p(x_1,\ldots ,x_n)$ by propositions $p$ . Since the first-order variables have, so far, only been used to encode string positions, such a forgetful mapping makes sense.

However, other solutions are possible. When we add semantically meaningful terms to first-order linear logic, the Curry-Howard isomorphism for the first-order quantifiers will give us dependent types and this provides a natural connection to the work using dependent types for formal semantics BIBREF21 , BIBREF22 , BIBREF23 , BIBREF24 .

## The Montagovian Generative Lexicon

In the previous sections, we have discussed two general solutions to the problems of the syntax-semantics interface of the Lambek calculus. Both solutions proposed a more flexible syntactic logic. In this section, we will discuss a different type of added flexibility, namely in the syntax-semantics interface itself.

The basic motivating examples for a more flexible composition have been amply debated in the literature BIBREF15 , BIBREF16 . Our solution is essentially the one proposed by BIBREF25 , called the Montagovian Generative Lexicon. I will only give a brief presentation of this framework. More details can be found in Chapter 6.

Like many other solutions, the first step consists of splitting Montague's type $e$ for entities into several types: physical objects, locations, informational objects, eventualities, etc. Although there are different opinions with respect to the correct granularity of types BIBREF15 , BIBREF16 , BIBREF26 , nothing much hinges on this for the present discussion.

The second key element is the move to the second-order lambda calculus, system F BIBREF27 , which allows abstraction over types as well as over terms. In our Lambek calculus, the determiner “the” was assigned the formula $np/n$ and the type of its lexical semantics was therefore $(e\rightarrow t) \rightarrow e$ , which we implement using the $\iota $ operators of type $(e\rightarrow t) \rightarrow e$ , which, roughly speaking, selects a contextually salient entity from (a characteristic function of) a set. When we replace the single type $e$ by several different types, we want to avoid listing several separate syntactically identical by semantically different entries for “the” in the lexicon, and therefore assign it a polymorphic term $\Lambda \alpha . \iota ^{(\alpha \rightarrow t)\rightarrow \alpha }$ of type $\Pi \alpha . ((\alpha \rightarrow t)\rightarrow \alpha )$ , quantifying over all types $\alpha $ . Though this looks problematic, the problem is resolved once we realise that only certain function words (quantifiers, conjunctions like “and”) are assigned polymorphic terms and that we simply use universal instantiation to obtain the value of the quantifier variable. So if “student” is a noun of type human, that is of type $h\rightarrow t$ , then “the student” will be of type $h$ , instantiating $(e\rightarrow t) \rightarrow e$0 to $(e\rightarrow t) \rightarrow e$1 . Formally, we use $(e\rightarrow t) \rightarrow e$2 reduction as follows (this is substitution of types instead of terms, substituting type $(e\rightarrow t) \rightarrow e$3 for $(e\rightarrow t) \rightarrow e$4 ). $(e\rightarrow t) \rightarrow e$5 

The final component of the Montagovian Generative Lexicon is a set of lexically specified, optional transformations. In case of a type mismatch, an optional transformation can “repair” the term.

As an example from BIBREF28 and BIBREF29 , one of the classic puzzles in semantics are plurals and collective and distributive readings. For example, verbs like “meet” have collective readings, they apply to groups of individuals collectively, so we have the following contrast, where collectives like committees and plurals like students can meet, but not singular or distributively quantified noun phrases. The contrast with verbs like “sneeze”, which force a distributive reading is clear.

. The committee met.

. All/the students met

. *A/each/the student met.

. All/the students sneezed.

. A/each/the student sneezed.

In the Montagovian Generative lexicon, we can models these fact as follows. First, we assign the plural morphology “-s” the semantics $\Lambda \alpha \lambda P^{\alpha \rightarrow t} \lambda Q^{\alpha \rightarrow t}. | Q | > 1 \wedge \forall x^{\alpha }. Q(x) \Rightarrow P(x)$ , then “students” is assigned the following term $\lambda Q^{h\rightarrow t}. | Q | > 1 \wedge \forall x^h. Q(x) \Rightarrow \textit {student}(x)$ , that is the sets of cardinality greater than one such that all its members are students. Unlike “student” which was assigned a term of type $h\rightarrow t$ , roughly a property of humans, the plural “students” is assigned a term of type $(h\rightarrow t)\rightarrow t$ , roughly a property of sets of humans. Consequently, the contrast between “the student” and “the students” is that the first is of type $h$ (a human) and the second of type $h\rightarrow t$ (a set of humans) as indicated below.

Therefore, the meaning of “the students” is the contextually determined set of humans, from the sets of more than one human such that all of them are students.

Then we distinguish the verbs “meet” and “sneeze” as follows, with the simpler verb “sneeze” simply selecting for a human subject and the collective verb “meet” selecting for a set of humans (of cardinality greater than one) as its subject.

Given these basic lexical entries, we already correctly predict that “the student met” is ill-formed semantically (there is an unresolvable type mismatch) but “the students met” and “the student sneezed” are given the correct semantics.

The interesting case is “the students sneezed” which has as its only reading that each student sneezed individually. Given that “the students” is of type $h\rightarrow t$ and that “sneezed” requires an argument of type $h$ , there is a type mismatch when we apply the two terms. However, “sneeze” has the optional distributivity operator `*', which when we apply it to the lexical semantics for “sneeze” produces the term $\lambda P^{h\rightarrow t}. \forall x^h. P(x) \Rightarrow \textit {sneeze}(x)$ , which combines with “the students” to produce the reading. $
\forall x^h. (\iota (\lambda Q^{h\rightarrow t}. | Q | > 1 \wedge \forall y^h Q(y) \Rightarrow \textit {student}(y))\, x) \Rightarrow \textit {sneeze}(x)
$ 

In other words, all of the members of the contextually determined set of more than human which are all students, sneeze.

The basic idea for the Montagovian Generative Lexicon is that lexical entries specify optional transformations which can repair certain sorts of type mismatches in the syntax-semantics interface. This adaptability allows the framework to solve many semantic puzzles.

Though a proof-of-concept application of these ideas exists, more robust and scalable applications, as well as efforts incorporate these ideas into wide-coverage semantics, are ongoing research.

## Theorem proving

When looking at the rules and examples for the different logics, the reader may have wondered: how do we actually find proofs for type-logical grammars? This question becomes especially urgent once our grammars become more complex and the consequences of our lexical entries, given our logic, become hard to oversee. Though pen and paper generally suffice to show that a given sentence is derivable for the desired reading, it is generally much more laborious to show that a given sentence is underivable or that it has only the desired readings. This is where automated theorem provers are useful: they allow more extensive and intensive testing of your grammars, producing results more quickly and with less errors (though we should be careful about too naively assuming the implementation we are using is correct: when a proof is found it is generally easy to verify its correctness by hand, but when a proof isn't found because of a programming error this can be hard to detect).

Though the natural deduction calculi we have seen so far can be used for automated theorem proving BIBREF30 , BIBREF31 , and though BIBREF4 already gave a sequent calculus decision procedure, both logics have important drawbacks for proof search.

Natural deduction proofs have a 1-1 correspondence between proofs and readings, though this is somewhat complicated to enforce for a logic with the $\bullet \textit {E}$ rule (and the related $\Diamond \textit {E}$ rule). For the sequent calculus, the product rule is just like the other rules, but sequent calculus suffers from the so-called “spurious ambiguity” problem, which means that it generates many more proofs than readings.

Fortunately, there are proof systems which combine the good aspects of natural deduction and sequent calculus, and which eliminate their respective drawbacks. Proof nets are a graphical representation of proofs first introduced for linear logic BIBREF32 . Proof nets suffer neither from spurious ambiguity nor from complications for the product rules.

Proof nets are usually defined as a subset of a larger class, called proof structures. Proof structures are “candidate proofs”: part of the search space of a naive proof search procedure which need not correspond to actual proofs. Proof nets are those proof structures which correspond to sequent proofs. Perhaps surprisingly, we can distinguish proof nets from other proof structures by looking only at graph-theoretical properties of these structures.

Proof search for type-logical grammars using proof nets uses the following general procedure.

In Sections "Multimodal proof nets" and "First-order proof nets" we will instantiate this general procedure for multimodal type-logical grammar and for first-order linear logic respectively.

## Multimodal proof nets

Table 5 presents the links for multimodal proof nets. The top row list the links corresponding to the elimination rules of natural deduction, the bottom row those corresponding to the introduction rules. There are two types of links: tensor links, with an open center, and par links, with a filled center. Par links have a single arrow pointing to the main formula of the link (the complex formula containing the principal connective). The top and bottom row are up-down symmetric with tensor and par reversed. The tensor links correspond to the logical rules which build structure when we read them from top to bottom, the par links to those rules which remove structure.

The formulas written above the central node of a link are its premisses, whereas the formulas written below it are its conclusions. Left-to-right order of the premisses as well as the conclusions is important.

A proof structure is a set of formula occurrences and a set of links such that:

each formula is at most once the premiss of a link,

each formula is at most once the conclusion of a link.

A formula which is not the premiss of any link is a conclusion of the proof structure. A formula which is not the conclusion of any link is a hypothesis of the proof structure. We say a proof structure with hypotheses $\Gamma $ and conclusions $\Delta $ is a proof structure of $\Gamma \vdash \Delta $ (we are overloading of the ` $\vdash $ ' symbol here, though this use should always be clear from the context; note that $\Delta $ can contain multiple formulas).

After the first step of lexical lookup we have a sequent $\Gamma \vdash C$ , and we can enumerate its proof structures as follows: unfold the formulas in $\Gamma , C$ , unfolding them so that the formulas in $\Gamma $ are hypotheses and the formula $C$ is a conclusion of the resulting structure, until we reach the atomic subformulas (this is step 2 of the general procedure), then identify atomic subformulas (step 3 of the general procedure, we turn to the last step, checking correctness, below). This identification step can, by the conditions on proof structures only identify hypotheses with conclusions and must leave all formulas of $\Gamma $ , including atomic formulas, as hypotheses and $C$ as a conclusion.

Figure 6 shows the lexical unfolding of the sequent $a/_a b, b/_a c \vdash a/_a c$ . It is already a proof structure, though a proof structure of $a, a/_a b, b, b/_a c, c \vdash a, a/_a c, b, c$ (to the reader familiar with the proof nets of linear logic: some other presentations of proof nets use more restricted definitions of proof structures where a “partial proof structure” such as shown in the figure is called a module).

To turn this proof structure into a proof structure of $a/_a b, b/_a c
\vdash a/_a c$ , we identify the atomic formulas. In this case, there is only a single way to do this, since $a$ , $b$ and $c$ all occur once as a hypothesis and once as a conclusion, though in general there may be many possible matchings. Figure 7 shows, on the left, the proof structure after identifying the $a$ and $b$ formulas. Since left and right (linear order), up and down (premiss, conclusion) have meaning in the graph, connecting the $c$ formulas is less obvious: $c$ is a conclusion of the $/I$ link and must therefore be below it, but a premiss of the $/E$ link and must therefore be above it. This is hard to achieve in the figure shown on the left. Though a possible solution would be to draw the figure on a cylinder, where “going up” from the topmost $a$0 we arrive at the bottom one, for ease of type-setting and reading the figure, I have chosen the representation shown in Figure 7 on the right. The curved line goes up from the $a$1 premiss of the $a$2 link and arrives from below at the $a$3 link, as desired. One way so see this strange curved connection is as a graphical representation of the coindexation of a premiss with a rule in the natural deduction rule for the implication.

Figure 7 therefore shows, on the right, a proof structure for $a/_a b, b/_a c
\vdash a/_a c$ . However, is it also a proof net, that is, does it correspond to a proof? In a multimodal logic, the answer depends on the available structural rules. For example, if no structural rules are applicable to mode $a$ then $a/_a b, b/_a c
\vdash a/_a c$ is underivable, but if mode $a$ is associative, then it is derivable.

We decide whether a proof structure is a proof net based only on properties of the graph. As a first step, we erase all formula information from the internal nodes of the graph; for administrative reasons, we still need to be able to identify which of the hypotheses and conclusion of the structure correspond to which formula occurrence. All relevant information for correctness is present in this graph, which we call an abstract proof structure.

We talked about how the curved line in proof structures (and abstract proof structure) corresponds to the coindexation of discharged hypotheses with rule names for the implication introduction rules. However, the introduction rules for multimodal type-logical grammars actually do more than just discharge a hypothesis, they also check whether the discharged hypothesis is the immediate left (for $\backslash I$ ) or right (for $/ I$ ) daughter of the root node, that is, that the withdrawn hypothesis $A$ occurs as $A\circ _i \Gamma $ (for $\backslash I$ and mode $i$ ) or $\Gamma \circ _i A$ (for $/I$ and mode $i$ ). The par links in the (abstract) proof structure represent a sort of “promise” that will produce the required structure. We check whether it is satisfied by means of contractions on the abstract proof structure.

The multimodal contractions are shown in Table 6 . All portrayed configurations contract to a single vertex: we erase the two internal vertices and the paired links and we identify the two external vertices, keeping all connections of the external vertices to the rest of the abstract proof structure as they were: the vertex which is the result of the contraction will be a conclusion of the same link as the top external vertex (or a hypothesis of the abstract proof structure in case it wasn't) and it will be a premiss of the same link as the bottom external vertex (or a conclusion of the abstract proof structure in case it wasn't).

The contraction for $/I$ checks if the withdrawn hypothesis is the right daughter of a tensor link with the same mode information $i$ , and symmetrically for the $\backslash I$ contraction. The $\bullet E$ contraction contracts two hypotheses occurring as sister nodes.

All contractions are instantiations of the same pattern: a tensor link and a par link are connected, respecting left-right and up-down the two vertices of the par link without the arrow.

To get a better feel for the contractions, we will start with its simplest instances. When we do pattern matching on the contraction for $/ I$ , we see that it corresponds to the following patterns, depending on our choice for the tensor link (the par link is always $/ I$ ). $
C/_i B &\vdash C/_i B \\
A & \vdash (A\bullet _i B)/_i B \\
A & \vdash C/_i (A\backslash _i C)
$ 

A proof structure is a proof net iff it contracts to a tree containing only tensor links using the contractions of Table 6 and any structural rewrites, discussed below — BIBREF33 present full proofs. In other words, we need to contract all par links in the proof structure according to their contraction, each contraction ensuring the correct application of the rule after which it is named. The abstract proof structure on the right of Figure 8 does not contract, since there is no substructure corresponding to the $/I$ contraction: for a valid contraction, a par link is connected to both “tentacles” of a single tensor link, and in the figure the two tentacles without arrow are connected to different tensor links. This is correct, since $a/_a b, b/_a c\vdash a/_a c$ is underivable in a logic without structural rules for $a$ .

However, we have seen that this statement becomes derivable once we add associativity of $a$ and it is easily verified to be a theorem of the Lambek calculus. How can we add a modally controlled version of associativity to the proof net calculus? We can add such a rule by adding a rewrite from a tensor tree to another tensor tree with the same set of leaves. The rewrite for associativity is shown in Figure 9 . To apply a structural rewrite, we replace the tree on the left hand side of the arrow by the one on the right hand side, reattaching the leaves and the root to the rest of the proof net.

Just like the structural rules, a structural rewrite always has the same leaves on both sides of the arrow — neither copying nor deletion is allowed, though we can reorder the leaves in any way (the associativity rule doesn't reorder the leaves).

Figure 10 shows how the contractions and the structural rewrites work together to derive $a/_a b, b/_a c \vdash a/_a c$ .

We start with a structural rewrite, which rebrackets the pair of tensor links. The two hypotheses are now the premisses of the same link, and this also produces a contractible structure for the $/I$ link. Hence, we have shown the proof structure to be a proof net.

In the Grail theorem prover, the representation of abstract proof structures looks as shown in Figure 11 (this is an automatically produced subgraph close to the graph on the left of Figure 10 , though with a non-associative mode $n$ and therefore not derivable). This graph is used during user interaction. The graphs are drawn using GraphViz, an external graph drawing program which does not guarantee respecting our desires for left, right and top/bottom, so tentacles are labeled 1, 2 and 3 (for left, right and top/bottom respectively) to allow us to make these distinctions regardless of the visual representation. Vertices are given unique identifiers for user interaction, for example to allow specifying which pair of atoms should be identified or which par link should be contracted.

Although the structural rules give the grammar writer a great deal of flexibility, such flexibility complicates proof search. As discussed at the beginning of Section "Theorem proving" , theorem proving using proof nets is a four step process, which in the current situation looks as follows: 1) lexical lookup, 2) unfolding, 3) identification of atoms, 4) graph rewriting. In the current case, both the graph rewriting and the identification of atoms are complicated and since we can interleave the atom connections and the graph rewriting it is not a priori clear which strategy is optimal for which set of structural rules. The current implementation does graph rewriting only once all atoms have been connected.

The Grail theorem prover implements some strategies for early failure. Since all proofs in multimodal type-logical grammars are a subset of the proofs in multiplicative linear logic, we can reject (partial) proof structures which are invalid in multiplicative linear logic, a condition which is both powerful and easy to check.

As a compromise between efficiency and flexibility, Grail allows the grammar writer to specify a first-order approximation of her structural rules. Unlike the test for validity in multiplicative linear logic which is valid for any set of structural rules, specifying such a first-order approximation is valid only when there is a guarantee that all derivable sequents in the multimodal grammar are a subset of their approximations derivable in first-order linear logic. Errors made here can be rather subtle and hard to detect. It is recommended to use such methods to improve parsing speed only when a grammar has been sufficiently tested and where it is possible to verify whether no valid readings are excluded, or, ideally, to prove that the subset relation holds between the multimodal logic and its first-order approximation.

The next section will discuss first-order proof nets in their own right. Though these proof nets have been used as an underlying mechanism in Grail for a long time, we have seen in Section "First-order linear logic" that many modern type-logical grammars are formulated in a way which permits a direct implementation without an explicit set of structural rules.

As to the proof search strategy used by Grail, it is an instance of the “dancing links” algorithm BIBREF35 : when connecting atomic formulas, we always link a formula which has the least possibilities and we rewrite the abstract proof structures only once a fully linked proof structure has been produced. Though the parser is not extremely fast, evaluation both on randomly generated statements and on multimodal statements extracted from corpora show that the resulting algorithm performs more than well enough BIBREF36 .

## First-order proof nets

Proof nets for first-order linear logic BIBREF37 are a simple extension of the proof nets for standard, multiplicative linear logic BIBREF38 . Compared to the multimodal proof nets of the previous section, all logical links have the main formula of the link as their conclusion but there is now a notion of polarity, corresponding to whether or not the formula occurs on the left hand side of the turnstile (negative polarity) or on the right hand side (positive polarity).

We unfold a sequent $A_1,\ldots ,A_n \vdash C$ by using the negative unfolding for each of the $A_i$ and the positive unfolding for $C$ . The links for first-order proof nets are shown in Table 7 .

Contrary to multimodal proof nets, where a tensor link was drawn with an open central node and a par link with a filled central node, here par links are drawn as a connected pair of dotted lines and tensor links as a pair of solid lines.

As before, premisses are drawn above the link and conclusions are drawn below it. With the exception of the cut and axiom links, the order of the premisses and the conclusions is important. We assume without loss of generality that every quantifier link uses a distinct eigenvariable.

A set of formula occurrences connected by links is a proof structure if every formula is at most once the premiss of a link and if every formula is exactly once the conclusion of a link. Those formulas which are not the premiss of any link are the conclusions of the proof structure — note the difference with multimodal proof nets: a proof structure has conclusions but no hypotheses and, as a consequence, each formula in the proof net must be the conclusion of exactly one (instead of at most one) link.

For polarised proof nets, unfolding the formulas according to the links of Table 7 no longer produces a proof structure, since the atomic formulas after unfolding are not the conclusions of any link. Such “partial proof structures” are called a modules. To turn a module into a proof structure, we connect atomic formulas of opposite polarity by axiom links until we obtain a complete matching of the atomic formulas, that is until every atomic formula is the conclusion of an axiom link.

The negative $\forall $ and the positive $\exists $ link, are defined using substitution of an arbitrary term $t$ for the eigenvariable of the link. In actual proof search, we use unification of these variables when the axiom links are performed.

As usual, not all proof structures are proof nets. However, since the logical rules for the quantifiers make essential use of the notion of “free occurrence of a variable”, this should be reflected in out correctness condition. BIBREF37 uses a notion of switching for proof structures which extends the switchings of BIBREF38 .

A switching is, for each of the binary par links a choice of its left or right premiss and for each of the unary par links with eigenvariable $x$ a choice of one of the formulas in the structure with a free occurrence of $x$ or of the premiss of the rule.

Given a switching, a correction graph replaces a binary par link by a connection from the conclusion of the link to the premiss chosen by the switching, and it replace a unary par link by a link from the conclusion to the formula chosen by the switching.

Finally, a proof structure is a proof net when all its correction graphs are both acyclic and connected BIBREF37 .

As an example, look at the proof structure of $a\multimap \exists x.b(x) \vdash \exists y. [a\multimap b(y)]$ shown in Figure 12 . This statement is not derivable in first-order linear logic (nor in intuitionistic logic). Consider therefore the switching connecting the binary par link to its left premiss $a$ and the link for $x$ to the formula $a\multimap b(x)$ (it has a free occurrence of $x$ , so this like is a valid switching).

This switching produces the correction graph shown in Figure 13 . It contains a cycle, drawn with bold edges, and is therefore not a proof structure (in addition, the $b$ axiom is disconnected from the rest of the structure, giving a second reason for rejecting the proof structure).

Though switching conditions for proof nets are simple and elegant, they don't lend themselves to naive application: already for the example proof structure of Figure 12 there are six possible switchings to consider and, as the reader can verify, only the switching shown in Figure 13 is cyclic (and disconnected). In general, it is often the case that all switchings but one are acyclic and connected, as it is here.

Though there are efficient ways of testing acyclicity and connectedness for multiplicative proof nets BIBREF39 , BIBREF40 and it seems these can be adapted to the first-order case (though some care needs to be taken when we allow complex terms), the theorem prover for first-order linear logic uses a extension of the contraction criterion of BIBREF41 .

Given a proof structure we erase all formulas from the vertices and keep only a set of the free variables at this vertex. We then use the contractions of Table 8 to contract the edges of the graph. The resulting vertex of each contraction has the union of the free variables of the two vertices of the redex (we remove the eigenvariable $x$ of a $\forall $ contraction, “ $\Rightarrow _u$ ”). A proof structure is a proof net iff it contracts to a single vertex using the contractions of Table 8 .

To give an example of the contractions, Figure 14 shows the contractions for the underivable proof structure of Figure 12 . The initial structure, which simply takes the proof structure of Figure 12 and replaces the formulas by the corresponding set of free variables, is shown on the left. Contracting the five solid edges using the $c$ contraction produces the structure shown in the figure on the right.

No further contractions apply: the two connected dotted links from the binary par link do not end in the same vertex, so the par contraction $p$ cannot apply. In addition, the universal contraction $u$ cannot apply either, since it requires all vertices with its eigenvariable $x$ to occur at the node from which the arrow is leaving and there is another occurrence of $x$ at the bottom node of the structure. We have therefore shown that this is not a proof net.

Since there are no structural rewrites, the contractions for first-order linear logic are easier to apply than those for multimodal type-logical grammars: it is rather easy to show confluence for the contractions (the presence of structural rules, but also the unary versions of the multimodal contractions, means confluence is not guaranteed for multimodal proof nets). We already implicitly used confluence when we argued that the proof structure in Figure 14 was not a proof net. The theorem prover uses a maximally contracted representation of the proof structure to represent the current state of proof search and this means less overhead and more opportunities for early failure during proof search.

Like before, the theorem proving uses four steps, which look as follows in the first-order case: 1) lexical lookup, 2) unfolding, 3) axiom links with unification, 4) graph contraction. Unlike the multimodal proof nets of the previous section, the graph contractions are now confluent and can be performed efficiently (the linear time solutions for the multiplicative case may be adaptable, but a naive implementation already has an $O(n^2)$ worst-case performance). After lexical lookup, theorem proving for first-order linear logic unfolds the formulas as before, but uses a greedy contraction strategy. This maximally contracted partial proof net constrains further axiom links: for example, a vertex containing a free variable $x$ cannot be linked to the conclusion of the edge of its eigenvariable (the vertex to which the arrow of the edge with variable $x$ points) or to one of its descendants, since such a structure would fail to satisfy the condition that the two vertices of a $\forall $ link for the $u$ contraction of Figure 8 are distinct. Another easily verified constraint is that two atomic formulas can only be connected by an axiom link if these formulas unify. Like for multimodal proof nets, the first-order linear logic theorem prover chooses an axiom link for one of the atoms with the fewest possibilities.

## Tools

Table 9 lists the different theorem provers which are available. Grail 0 BIBREF42 and Grail 3 BIBREF43 use the multimodal proof net calculus of Section "Multimodal proof nets" , whereas LinearOne BIBREF44 uses the first-order proof nets of Section "First-order proof nets" . GrailLight BIBREF45 is a special-purpose chart parser, intended for use with an automatically extracted French grammar for wide-coverage parsing and semantics BIBREF34 , BIBREF46 . All provers are provided under the GNU Lesser General Public License — this means, notably, there is no warranty, though I am committed to making all software as useful as possible; so contact me for any comments, feature requests or bug reports. All theorem provers can be downloaded from the author's GitHub site.

https://github.com/RichardMoot/

The columns of table Table 9 indicate whether the theorem provers provide natural deduction output, graph output (of the partial proof nets), whether there is an interactive mode for proof search, whether the implementation is complete and whether the grammar can specify its own set of structural rules; “NA” means the question doesn't apply to the given system (GrailLight doesn't use a graphs to represent proofs and first-order linear logic does not have a grammar-specific set of structural rules). The table should help you select the most adequate tool for your purposes.

LinearOne provides natural deduction output not only for first-order linear logic, but also for the Displacement calculus, hybrid type-logical grammars and lambda grammars. That is, the grammar writer can write a grammar in any of these formalisms, LinearOne will do proof search of the translation of this grammar in first-order linear logic and then translate any resulting proofs back to the source language.

The syntactic example proofs in this chapter have been automatically generated using these tools and the corresponding grammars files, as well as many other example grammars, are included in the repository.
