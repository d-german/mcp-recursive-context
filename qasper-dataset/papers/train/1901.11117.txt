# The Evolved Transformer

**Paper ID:** 1901.11117

## Abstract

Recent works have highlighted the strength of the Transformer architecture on sequence tasks while, at the same time, neural architecture search (NAS) has begun to outperform human-designed models. Our goal is to apply NAS to search for a better alternative to the Transformer. We first construct a large search space inspired by the recent advances in feed-forward sequence models and then run evolutionary architecture search with warm starting by seeding our initial population with the Transformer. To directly search on the computationally expensive WMT 2014 English-German translation task, we develop the Progressive Dynamic Hurdles method, which allows us to dynamically allocate more resources to more promising candidate models. The architecture found in our experiments -- the Evolved Transformer -- demonstrates consistent improvement over the Transformer on four well-established language tasks: WMT 2014 English-German, WMT 2014 English-French, WMT 2014 English-Czech and LM1B. At a big model size, the Evolved Transformer establishes a new state-of-the-art BLEU score of 29.8 on WMT'14 English-German; at smaller sizes, it achieves the same quality as the original"big"Transformer with 37.6% less parameters and outperforms the Transformer by 0.7 BLEU at a mobile-friendly model size of 7M parameters.

## Introduction

Over the past few years, impressive advances have been made in the field of neural architecture search. Reinforcement learning and evolution have both proven their capacity to produce models that exceed the performance of those designed by humans BIBREF0 , BIBREF1 . These advances have mostly focused on improving image models, although some effort has also been invested in searching for sequence models BIBREF2 , BIBREF3 . In these cases, it has always been to find improved recurrent neural networks (RNNs), which were long established as the de facto neural model for sequence problems BIBREF4 , BIBREF5 .

However, recent works have shown that there are better alternatives to RNNs for solving sequence problems. Due to the success of convolution-based networks, such as Convolution Seq2Seq BIBREF6 , and full attention networks, such as the Transformer BIBREF7 , feed-forward networks are now a viable option for solving sequence-to-sequence (seq2seq) tasks. The main strength of feed-forward networks is that they are faster, and easier to train than RNNs.

The goal of this work is to examine the use of neural architecture search methods to design better feed-forward architectures for seq2seq tasks. Specifically, we apply tournament selection architecture search to evolve from the Transformer, considered to be the state-of-art and widely-used, into a better and more efficient architecture. To achieve this, we construct a search space that reflects the recent advances in feed-forward seq2seq models and develop a method called progressive dynamic hurdles (PDH) that allows us to perform our search directly on the computationally demanding WMT 2014 English-German (En-De) translation task. Our search produces a new architecture – called the Evolved Transformer (ET) – which demonstrates consistent improvement over the original Transformer on four well-established language tasks: WMT 2014 English-German, WMT 2014 English-French (En-Fr), WMT 2014 English-Czech (En-Cs) and the 1 Billion Word Language Model Benchmark (LM1B). In our experiments with big size models, the Evolved Transformer is twice as efficient as the Transformer in FLOPS without loss of quality. At a much smaller – mobile-friendly – model size of $\sim $ 7M parameters, the Evolved Transformer outperforms the Transformer by 0.7 BLEU.

## Related Work

RNNs have long been used as the default option for applying neural networks to sequence modeling BIBREF4 , BIBREF5 , with LSTM BIBREF8 and GRU BIBREF9 architectures being the most popular. However, recent work has shown that RNNs are not necessary to build state-of-the-art sequence models. For example, many high performance convolutional models have been designed, such as WaveNet BIBREF10 , Gated Convolution Networks BIBREF11 , Conv Seq2Seq BIBREF6 and Dynamic Lightweight Convolution model BIBREF12 . Perhaps the most promising architecture in this direction is the Transformer architecture BIBREF7 , which relies only on multi-head attention to convey spatial information. In this work, we use both convolutions and attention in our search space to leverage the strengths of both layer types.

The recent advances in sequential feed-forward networks are not limited to architecture design. Various methods, such as BERT BIBREF13 and Radford et. al's pre-training technique BIBREF14 , have demonstrated how models such as the Transformer can improve over RNN pre-training BIBREF15 , BIBREF16 . For translation specifically, work on scaling up batch size BIBREF17 , BIBREF12 , using relative position representations BIBREF18 , and weighting multi-head attention BIBREF19 have all pushed the state-of-the-art for WMT 2014 En-De and En-Fr. However, these methods are orthogonal to this work, as we are only concerned with improving the neural network architecture itself, and not the techniques used for improving overall performance.

The field of neural architecture search has also seen significant recent progress. The best performing architecture search methods are those that are computationally intensive BIBREF2 , BIBREF20 , BIBREF21 , BIBREF22 , BIBREF1 , BIBREF0 . Other methods have been developed with speed in mind, such as DARTS BIBREF23 , ENAS BIBREF3 , SMASH BIBREF24 , and SNAS BIBREF25 . These methods radically reduce the amount of time needed to run each search by approximating the performance of each candidate model, instead of investing resources to fully train and evaluate each candidate separately. Unfortunately, these faster methods produce slightly less competitive results. Zela et. al's zela18 utilization of Hyperband BIBREF26 and PNAS's BIBREF27 incorporation of a surrogate model are examples of approaches that try to both increase efficiency via candidate performance estimation and maximize search quality by training models to the end when necessary. The progressive dynamic hurdles method we introduce here is similar to these approaches in that we train our best models individually to the end, but optimize our procedure by discarding unpromising models early on.

## Methods

We employ evolution-based architecture search because it is simple and has been shown to be more efficient than reinforcement learning when resources are limited BIBREF0 . We use the same tournament selection BIBREF28 algorithm as Real et al. real19, with the aging regularization omitted, and so encourage the reader to view their in-depth description of the method. In the interest of saving space, we will only give a brief overview of the algorithm here.

Tournament selection evolutionary architecture search is conducted by first defining a gene encoding that describes a neural network architecture; we describe our encoding in the following Search Space subsection. An initial population is then created by randomly sampling from the space of gene encoding to create individuals. These individuals are assigned fitnesses based on training the the neural networks they describe on the target task and then evaluating their performance on the task's validation set. The population is then repeatedly sampled from to produce subpopulations, from which the individual with the highest fitness is selected as a parent. Selected parents have their gene encodings mutated – encoding fields randomly changed to different values – to produce child models. These child models are then assigned a fitness via training and evaluation on the target task, as the initial population was. When this fitness evaluation concludes, the population is sampled from once again, and the individual in the subpopulation with the lowest fitness is killed, meaning it is removed from the population. The newly evaluated child model is then added to the population, taking the killed individual's place. This process is repeated and results in a population with high fitness individuals, which in our case represent well-performing architectures.

## Search Space

Our encoding search space is inspired by the NASNet search space BIBREF1 , but is altered to allow it to express architecture characteristics found in recent state-of-the-art feed-forward seq2seq networks. Crucially, we ensured that the search space can represent the Transformer, so that we can seed the search process with the Transformer itself.

Our search space consists of two stackable cells, one for the model encoder and one for the decoder (see Figure 1 ). Each cell contains NASNet-style blocks, which receive two hidden state inputs and produce new hidden states as outputs; the encoder contains six blocks and the decoder contains eight blocks, so that the Transformer can be represented exactly. The blocks perform separate transformations to each input and then combine the transformation outputs together to produce a single block output; we will refer to the transformations applied to each input as a branch. Our search space contains five branch-level search fields (input, normalization, layer, output dimension and activation), one block-level search field (combiner function) and one cell-level search field (number of cells).

In our search space, a child model's genetic encoding is expressed as: $[$ left input, left normalization, left layer, left relative output dimension, left activation, right input, right normalization, right layer, right relative output dimension, right activation, combiner function $]$ $\times $ 14 + $[$ number of cells $]$ $\times $ 2, with the first 6 blocks allocated to the encoder and the latter 8 allocated to the decoder. Given the vocabularies described in the Appendix, this yields a search space of $7.30 * 10^{115}$ models, although we do shrink this to some degree by introducing constraints (see the Appendix for more details).

## Seeding the Search Space with Transformer

While previous neural architecture search works rely on well-formed hand crafted search spaces BIBREF1 , we intentionally leave our search minimally tuned, in a effort to alleviate our manual burden and emphasize the role of the automated search method. To help navigate the large search space we create for ourselves, we find it easier to seed our initial population with a known strong model, in this case the Transformer. This anchors the search to a known good starting point and guarantees at least a single strong potential parent in the population as the generations progress. We offer empirical support for these claims in our Results section.

## Evolution with Progressive Dynamic Hurdles

The evolution algorithm we employ is adapted from the tournament selection evolutionary architecture search proposed by Real et al. real19, described above. Unlike Real et al. real19 who conducted their search on CIFAR-10, our search is conducted on a task that takes much longer to train and evaluate on. Specifically, to train a Transformer to peak performance on WMT'14 En-De requires $\sim $ 300k training steps, or 10 hours, in the base size when using a single Google TPU V.2 chip, as we do in our search. In contrast, Real et al. real19 used the less resource-intensive CIFAR-10 task BIBREF29 , which takes about two hours to train on, to assess their models during their search, as it was a good proxy for ImageNet BIBREF30 performance BIBREF1 . However, in our preliminary experimentation we could not find a proxy task that gave adequate signal for how well each child model would perform on the full WMT'14 En-De task; we investigated using only a fraction of the data set and various forms of aggressive early stopping.

To address this problem we formulated a method to dynamically allocate resources to more promising architectures according to their fitness. This method, which we refer to as progressive dynamic hurdles (PDH), allows models that are consistently performing well to train for more steps. It begins as ordinary tournament selection evolutionary architecture search with early stopping, with each child model training for a relatively small $s_0$ number of steps before being evaluated for fitness. However, after a predetermined number of child models, $m$ , have been evaluated, a hurdle, $h_0$ , is created by calculating the the mean fitness of the current population. For the next $m$ child models produced, models that achieve a fitness greater than $h_0$ after $s_0$ train steps are granted an additional $s_1$ steps of training and then are evaluated again to determine their final fitness. Once another $m$ models have been considered this way, another hurdle, $h_1$ , is constructed by calculating the mean fitness of all members of the current population that were trained for the maximum number of steps. For the next $m$ child models, training and evaluation continues in the same fashion, except models with fitness greater than $m$0 after $m$1 steps of training are granted an additional $m$2 number of train steps, before being evaluated for their final fitness. This process is repeated until a satisfactory number of maximum training steps is reached. Algorithm 1 (Appendix) formalizes how the fitness of an individual model is calculated with hurdles and Algorithm 2 (Appendix) describes tournament selection augmented with progressive dynamic hurdles.

Although different child models may train for different numbers of steps before being assigned their final fitness, this does not make their fitnesses incomparable. Tournament selection evolution is only concerned with relative fitness rank when selecting which subpopulation members will be killed and which will become parents; the margin by which one candidate is better or worse than the other members of the subpopulation does not matter. Assuming no model overfits during its training and that its fitness monotonically increases with respect to the number of train steps it is allocated, a comparison between two child models can be viewed as a comparison between their fitnesses at the lower of the two's cumulative train steps. Since the model that was allocated more train steps performed, by definition, above the fitness hurdle for the lower number of steps and the model that was allocated less steps performed, by definition, at or below that hurdle at the lower number of steps, it is guaranteed that the model with more train steps was better when it was evaluated at the lower number of train steps.

The benefit of altering the fitness algorithm this way is that poor performing child models will not consume as many resources when their fitness is being computed. As soon as a candidate's fitness falls below a tolerable amount, its evaluation immediately ends. This may also result in good candidates being labeled as bad models if they are only strong towards the latter part of training. However, the resources saved as a result of discarding many bad models improves the overall quality of the search enough to justify potentially also discarding some good ones; this is supported empirically in our Results section.

## Datasets

We use three different machine translation datasets to perform our experiments, all of which were taken from their Tensor2Tensor implementations. The first is WMT English-German, for which we mimic Vaswani et al.'s vaswani17 setup, using WMT'18 En-De training data without ParaCrawl BIBREF31 , yielding 4.5 million sentence pairs. In the same fashion, we use newstest2013 for development and test on newstest2014. The second translation dataset is WMT En-Fr, for which we also replicate Vaswani et.al's vaswani17 setup. We train on the 36 million sentence pairs of WMT'14 En-Fr, validate on newstest2013 and test on newstest2014. The final translation dataset is WMT English-Czech (En-Cs). We used the WMT'18 training dataset, again without ParaCrawl, and used newstest2013 and newstest2014 as validation and test sets. For all tasks, tokens were split using a shared source-target vocabulary of about 32k word-pieces BIBREF32 .

All datasets were generated using Tensor2Tensor's “packed" scheme; sentences were shuffled and concatenated together with padding to form uniform 256 length inputs and targets, with examples longer than 256 being discarded. This yielded batch sizes of 4096 tokens per GPU or TPU chip; accordingly, 16 TPU chip configurations had $\sim $ 66K tokens per batch and 8 GPU chip configurations had $\sim $ 33K tokens per batch.

For language modeling we used the 1 Billion Word Language Model Benchmark (LM1B) BIBREF33 , also using its “packed" Tensor2Tensor implementation. Again the tokens are split into a vocabulary of approximately 32k word-pieces and the sentences are shuffled.

## Training Details and Hyperparameters

All of our experiments used Tensor2Tensor's Transformer TPU hyperparameter settings. These are nearly identical to those used by Vaswani et al. vaswani17, but modified to use the memory-efficient Adafactor BIBREF34 optimizer. Aside from using the optimizer itself, these hyperparameters set the warmup to a constant learning rate of $10^{-2}$ over 10k steps and then uses inverse-square-root learning-rate decay. For our experiments, we make only one change, which is to alter this decay so that it reaches 0 at the final step of training, which for our non-search experiments is uniformly 300k. We found that the our search candidate models, the Transformer, and the Evolved Transformer all benefited from this and so experimented with using linear decay, single-cycle cosine decay BIBREF35 and a modified inverse-square-root decay to 0 at 300k steps: $lr = step^{-0.00303926} - .962392$ ; every decay was paired with the same constant $10^{-2}$ warmup. We used WMT En-De validation perplexity to gauge model performance and found that the Transformer preferred the modified inverse-square-root decay. Therefore, this is what we used for both all our Transformer trainings and the architecture searches themselves. The Evolved Transformer performed best with cosine decay and so that is what we used for all of its trainings. Besides this one difference, the hyperparameter settings across models being compared are exactly the same. Because decaying to 0 resulted in only marginal weight changes towards the end of training, we did not use checkpoint averaging.

Per-task there is one additional hyperparameter difference, which is dropout rate. For ET and all search child models, dropout was applied uniformly after each layer, approximating the Transformer's more nuanced dropout scheme. For En-De and En-Cs, all “big" sized models were given a higher dropout rate of 0.3, keeping in line with Vaswani et al. vaswani17, and all models with an input embedding size of 768 are given a dropout rate of 0.2. Aside from this, hyperparameters are identical across all translation tasks.

For decoding we used the same beam decoding configuration used by Vaswani et al. vaswani17. That is a beam size of 4, length penalty ( $\alpha $ ) of 0.6, and maximum output length of input length + 50. All BLEU is calculated using case-sensitive tokenization and for WMT'14 En-De we also use the compound splitting that was used in Vaswani et al. vaswani17.

Our language model training setup is identical to our machine translation setup except we remove label smoothing and lower the intra-attention dropout rate to 0. This was taken from the Tensor2Tensor hyperparameters for LM1B[2].

## Search Configurations

All of the architecture searches we describe were run on WMT'14 En-De. They utilized the search space and tournament selection evolution algorithm described in our Methods section. Unless otherwise noted, each search used 200 workers, which were equipped with a single Google TPU V.2 chip for training and evaluation. We maintained a population of size 100 with subpopulation sizes for both killing and reproducing set to 30. Mutations were applied independently per encoding field at a rate of 2.5%. For fitness we used the negative log perplexity of the validation set instead of BLEU because, as demonstrated in our Results section, perplexity is more consistent and that reduced the noise of our fitness signal.

## Results

In this section, we will first benchmark the performance of our search method, progressive dynamic hurdles, against other evolutionary search methods BIBREF21 , BIBREF0 . We will then benchmark the Evolved Transformer, the result of our search method, against the Transformer BIBREF7 .

## Search Techniques

We tested our evolution algorithm enhancements – using PDH and seeding the initial population with the Transformer – against control searches that did not use these techniques; without our enhancements, these controls function the same way as Real et. al's real19 searches, without aging regularization. Each search we describe was run 3 times and the top model from each run was retrained on a single TPU V.2 chip for 300k steps. The performance of the models after retraining is given in Table 1 .

Our proposed search (Table 1 row 1), which used both PDH and Transformer seeding, was run first, with hurdles created every 1k models ( $m = 1000$ ) and six 30k train step (1 hour) increments ( $s=<30, 30, 30, 30, 30, 30>$ ). To test the effectiveness of seeding with the Transformer, we ran an identical search that was instead seeded with random valid encodings (Table 1 row 2). To test the effectiveness of PDH, we ran three controls (Table 1 rows 3-5) that each used a fixed number of train steps for each child model instead of hurdles (Table 1 column 2). For these we used the step increments (30k), the maximum number of steps our proposed search ultimately reaches (180k), and the total number of steps each top model receives when fully trained to gauge its final performance (300k). To determine the number of child models each of these searches would be able to train, we selected the value that would make the total amount of resources used by each control search equal to the maximum amount of resources used for our proposed searches, which require various amounts of resources depending on how many models fail to overcome hurdles. In the three trials we ran, our proposed search's total number of train steps used was 422M $\pm $ 21M, with a maximum of 446M. Thus the number of child models allotted for each non-PDH control search was set so that the total number of child model train steps used would be 446M.

As demonstrated in Table 1, the search we propose, with PDH and Transformer seeding, has the best performance on average. It also is the most consistent, having the lowest standard deviation. Of all the searches conducted, only a single control run – “30K no hurdles" (Table 1 row 3) – produced a model that was better than any of our proposed search's best models. At the same time, the “30K no hurdles" setup also produced models that were significantly worse, which explains its high standard deviation. This phenomenon was a chief motivator for our developing this method. Although aggressive early stopping has the potential to produce strong models for cheap, searches that utilize it can also venture into modalities in which top fitness child models are only strong early on. Without running models for longer, whether or not this is happening cannot be detected. The 180K and 300K no hurdles searches did have insight into long term performance, but in a resource-inefficient manner that hurt these searches by limiting the number of generations they produced; for the “180k no hurdles" run to train as many models as PDH would require 1.08B train steps, over double what PDH used in our worst case.

Searching with random seeding also proved to be ineffective, performing considerably worse than every other configuration. Of the five searches run, random seeding was the only one that had a top model perplexity higher than the Transformer, which is 4.75 $\pm $ 0.01 in the same setup.

After confirming the effectiveness of our search procedure, we launched a larger scale version of our search using 270 workers. We trained 5k models per hurdle ( $m=5000$ ) and used larger step increments to get a closer approximation to 300k step performance: $s = <60, 60, 120>$ . The setup was the same as the Search Techniques experiments, except after 11k models we lowered the mutation rate to 0.01 and introduced the NONE value to the normalization mutation vocabulary.

The search ran for 15K child models, requiring a total of 979M train steps. Over 13K models did not make it past the first hurdle, drastically reducing the resources required to view the 240 thousandth train step for top models, which would have cost 3.6B train steps for the same number of models without hurdles. After the search concluded, we then selected the top 20 models and trained them for the full 300k steps, each on a single TPU V.2 chip. The model that ended with the best perplexity is what we refer to as the Evolved Transformer (ET). Figure 3 shows the ET architecture. The most notable aspect of the Evolved Transformer is the use of wide depth-wise separable convolutions in the lower layers of the encoder and decoder blocks. The use of depth-wise convolution and self-attention was previously described in QANet BIBREF37 , however the overall architectures of the Evolved Transformer and QANet are different in many ways: e.g., QANet has smaller kernel sizes and no branching structures. The performance and analysis of the Evolved Transformer will be shown in the next section.

## The Evolved Transformer: Performance and Analysis

To test the effectiveness of the found architecture – the Evolved Transformer – we compared it to the Transformer in its Tensor2Tensor training regime on WMT'14 En-De. Table 2 shows the results of these experiments run on the same 8 NVIDIA P100 hardware setup that was used by Vaswani et al. vaswani17. Observing ET's improved performance at parameter-comparable “base" and “big" sizes, we were also interested in understanding how small ET could be shrunk while still achieving the same performance as the Transformer. To create a spectrum of model sizes for each architecture, we selected different input embedding sizes and shrank or grew the rest of the model embedding sizes with the same proportions. Aside from embedding depths, these models are identical at all sizes, except the “big" 1024 input embedding size, for which all 8 head attention layers are upgraded to 16 head attention layers, as was done in Vaswani et al. vaswani17.

ET demonstrates stronger performance than the Transformer at all sizes, with the largest difference of 0.7 BLEU at the smallest, mobile-friendly, size of $\sim $ 7M parameters. Performance on par with the “base" Transformer was reached when ET used just 71.4% of its FLOPS and performance of the “big" Transformer was exceeded by the ET model that used 44.8% less FLOPS. Figure 4 shows the FLOPS vs. BLEU performance of both architectures.

To test ET's generalizability, we also compared it to the Transformer on an additional three well-established language tasks: WMT'14 En-Fr, WMT'14 En-Cs, and LM1B. Upgrading to 16 TPU V.2 chips, we doubled the number of synchronous workers for these experiments, pushing both models to their higher potential BIBREF17 . We ran each configuration 3 times, except WMT En-De, which we ran 6 times; this was a matter of resource availability and we gave priority to the task we searched on. As shown in Table 3 , ET performs at least one standard deviation above the Transformer in each of these tasks. Note that the Transformer mean BLEU scores in both Tables 2 and 3 for WMT'14 En-Fr and WMT'14 En-De are higher than those originally reported by Vaswani et al. BIBREF7 .

As can be seen in Tables 2 and 3 , the Evolved Transformer is much more effective than the Transformer when its model size is small. When the model size becomes large, its BLEU performance saturates and the gap between the Evolved Transformer and the Transformer becomes smaller. One explanation for this behavior is that overfitting starts to occur at big model sizes, but we expect that data augmentation BIBREF17 or hyperparameter tuning could improve performance. The improvement gains in perplexity by ET, however, are still significant for big model sizes; it is worth emphasizing that perplexity is also a reliable metric for measuring machine translation quality BIBREF32 .

To understand what mutations contributed to ET's improved performance we conducted two rounds of ablation testing. In the first round, we began with the Transformer and applied each mutation to it individually to measure the performance change each mutation introduces in isolation. In the second round, we began with ET and removed each mutation individually to again measure the impact of each single mutation. In both cases, each model was trained 3 times on WMT En-De for 300k steps with identical hyperparameters, using the inverse-square-root decay to 0 that the Transformer prefers. Each training was conducted on a single TPU V.2 chip. The results of these experiments are presented in Table 4 of the Appendix; we use validation perplexity for comparison because it was our fitness metric.

In all cases, the augmented ET models outperformed the the augmented Transformer models, indicating that the gap in performance between ET and the Transformer cannot be attributed to any single mutation. The mutation with the seemingly strongest individual impact is the increase from 3 to 4 decoder blocks. However, even when this mutation is introduced to the Transformer and removed from ET, the resulting augmented ET model still has a higher fitness than the augmented Transformer model.

Some mutations seem to only hurt model performance such as converting the encoder's first multi-head attention into a Gated Linear Unit. However, given how we formulate the problem – finding an improved model with a comparable number of parameters to the Transformer – these mutations might have been necessary. For example, when the Transformer decoder block is repeated 4 times, the resulting model has 69.6M parameters, which is outside of our allowed parameter range. Thus, mutations that shrank ET's total number of parameters, even at a slight degradation of performance, were necessary so that other more impactful parameter-expensive mutations, such as adding an additional decoder block, could be used. If model size is not of concern, some of these mutations could potentially be reverted to further improve performance. Likewise, parameter efficient layers, such as the depthwise-separable convolutions, could potentially be swapped for their less efficient counterparts, such as standard convolution.

## Conclusion

We presented the first neural architecture search conducted to find improved feed-forward sequence models. We first constructed a large search space inspired by recent advances in seq2seq models and used it to search directly on the computationally intensive WMT En-De translation task. To mitigate the size of our space and the cost of training child models, we proposed using both our progressive dynamic hurdles method and seeding our initial population with a known strong model, the Transformer.

When run at scale, our search found the Evolved Transformer. In a side by side comparison against the Transformer in an identical training regime, the Evolved Transformer showed consistent stronger performance on both translation and language modeling. On WMT En-De, the Evolved Transformer was twice as efficient FLOPS-wise as the Transformer big model and at a mobile-friendly size, the Evolved Transformer demonstrated a 0.7 BLEU gain over the Transformer architecture.

## Acknowledgements

We would like to thank Ashish Vaswani, Jakob Uszkoreit, Niki Parmar, Noam Shazeer, Lukasz Kaiser and Ryan Sepassi for their help with Tensor2Tensor and for sharing their understanding of the Transformer. We are also grateful to David Dohan, Esteban Real, Yanping Huang, Alok Aggarwal, Vijay Vasudevan, and Chris Ying for lending their expertise in architecture search and evolution.

## Search Algorithms

In the following, we describe the algorithm that we use to calculate child model fitness with hurdles (Algorithm "Search Algorithms" ) and evolution architecture search with progressive dynamic hurdles (Algorithm UID28 ). [h!] Calculate Model Fitness with Hurdles inputs: $model$ : the child model $s$ : vector of train step increments $h$ : queue of hurdles append $-\infty $ to $h$ TRAIN_N_STEPS( $model$ , $s_0$ ) $fitness \leftarrow $ EVALUATE( $model$ ) $i \leftarrow 0$ $s$0 $s$1 $s$2 TRAIN_N_STEPS( $s$3 , $s$4 ) $s$5 EVALUATE( $s$6 ) $s$7 return $s$8 

## Search Space Information

In our search space, a child model's genetic encoding is expressed as: $[$ left input, left normalization, left layer, left relative output dimension, left activation, right input, right normalization, right layer, right relative output dimension, right activation, combiner function $]$ $\times $ 14 + $[$ number of cells $]$ $\times $ 2, with the first 6 blocks allocated to the encoder and the latter 8 allocated to the decoder. In the following, we will describe each of the components.

## Ablation studies of the Evolved Transformer

To understand what mutations contributed to ET's improved performance we conducted two rounds of ablation testing. In the first round, we began with the Transformer and applied each mutation to it individually to measure the performance change each mutation introduces in isolation. In the second round, we began with ET and removed each mutation individually to again measure the impact of each single mutation. In both cases, each model was trained 3 times on WMT En-De for 300k steps with identical hyperparameters, using the inverse-square-root decay to 0 that the Transformer prefers. Each training was conducted on a single TPU V.2 chip. The results of these experiments are presented in Table 4 ; we use validation perplexity for comparison because it was our fitness metric.

To highlight the impact of each augmented model's mutation, we present not only their perplexities but also the difference between their mean perplexity and their unaugmented base model mean perplexity in the "Mean Diff" columns:

base model mean perplexity - augmented mean perplexity

This delta estimates the change in performance each mutation creates in isolation. Red highlighted cells contain evidence that their corresponding mutation hurt overall performance. Green highlighted cells contain evidence that their corresponding mutation helped overall performance.

In half of the cases, both the augmented Transformer's and the augmented Evolved Transformer's performances indicate that the mutation was helpful. Changing the number of attention heads from 8 to 16 was doubly indicated to be neutral and changing from 8 head self attention to a GLU layer in the decoder was doubly indicated to have hurt performance. However, this and other mutations that seemingly hurt performance may have been necessary given how we formulate the problem: finding an improved model with a comparable number of parameters to the Transformer. For example, when the Transformer decoder block is repeated 4 times, the resulting model has 69.6M parameters, which is outside of our allowed parameter range. Thus, mutations that shrank ET's total number of parameters, even at a slight degradation of performance, were necessary so that other more impactful parameter-expensive mutations, such as adding an additional decoder block, could be used.

Other mutations have inconsistent evidence about how useful they are. This ablation study serves only to approximate what is useful, but how effective a mutation is also depends on the model it is being introduced to and how it interacts with other encoding field values.
