# Fast Multi-language LSTM-based Online Handwriting Recognition

**Paper ID:** 1902.10525

## Abstract

We describe an online handwriting system that is able to support 102 languages using a deep neural network architecture. This new system has completely replaced our previous Segment-and-Decode-based system and reduced the error rate by 20%-40% relative for most languages. Further, we report new state-of-the-art results on IAM-OnDB for both the open and closed dataset setting. The system combines methods from sequence recognition with a new input encoding using B\'ezier curves. This leads to up to 10x faster recognition times compared to our previous system. Through a series of experiments we determine the optimal configuration of our models and report the results of our setup on a number of additional public datasets.

## Introduction

In this paper we discuss online handwriting recognition: Given a user input in the form of an ink, i.e. a list of touch or pen strokes, output the textual interpretation of this input. A stroke is a sequence of points INLINEFORM0 with position INLINEFORM1 and timestamp INLINEFORM2 .

Figure FIGREF1 illustrates example inputs to our online handwriting recognition system in different languages and scripts. The left column shows examples in English with different writing styles, with different types of content, and that may be written on one or multiple lines. The center column shows examples from five different alphabetic languages similar in structure to English: German, Russian, Vietnamese, Greek, and Georgian. The right column shows scripts that are significantly different from English: Chinese has a much larger set of more complex characters, and users often overlap characters with one another. Korean, while an alphabetic language, groups letters in syllables leading to a large “alphabet” of syllables. Hindi writing often contains a connecting ‘Shirorekha’ line and characters can form larger structures (grapheme clusters) which influence the written shape of the components. Arabic is written right-to-left (with embedded left-to-right sequences used for numbers or English names) and characters change shape depending on their position within a word. Emoji are non-text Unicode symbols that we also recognize.

Online handwriting recognition has recently been gaining importance for multiple reasons: (a) An increasing number of people in emerging markets are obtaining access to computing devices, many exclusively using mobile devices with touchscreens. Many of these users have native languages and scripts that are not as easily typed as English, e.g. due to the size of the alphabet or the use of grapheme clusters which make it difficult to design an intuitive keyboard layout BIBREF0 . (b) More and more large mobile devices with styluses are becoming available, such as the iPad Pro, Microsoft Surface devices, and Chromebooks with styluses.

Early work in online handwriting recognition looked at segment-and-decode classifiers, such as the Newton BIBREF1 . Another line of work BIBREF2 focused on solving online handwriting recognition by making use of Hidden Markov Models (HMMs) BIBREF3 or hybrid approaches combining HMMs and Feed-forward Neural Networks BIBREF4 . The first HMM-free models were based on Time Delay Neural Networks (TDNNs) BIBREF5 , BIBREF6 , BIBREF7 , and more recent work focuses on Recurrent Neural Network (RNN) variants such as Long-Short-Term-Memory networks (LSTMs) BIBREF8 , BIBREF9 .

How to represent online handwriting data has been a research topic for a long time. Early approaches were feature-based, where each point is represented using a set of features BIBREF6 , BIBREF10 , BIBREF1 , or using global features to represent entire characters BIBREF6 . More recently, the deep learning revolution has swept away most feature engineering efforts and replaced them with learned representations in many domains, e.g. speech BIBREF11 , computer vision BIBREF12 , and natural language processing BIBREF13 .

Together with architecture changes, training methodologies also changed, moving from relying on explicit segmentation BIBREF7 , BIBREF1 , BIBREF14 to implicit segmentation using the Connectionist Temporal Classification (CTC) loss BIBREF15 , or Encoder-Decoder approaches trained with Maximum Likelihood Estimation BIBREF16 . Further recent work is also described in BIBREF17 .

The transition to more complex network architectures and end-to-end training can be associated with breakthroughs in related fields focused on sequence understanding where deep learning methods have outperformed “traditional” pattern recognition methods, e.g. in speech recognition BIBREF18 , BIBREF19 , OCR BIBREF20 , BIBREF21 , offline handwriting recognition BIBREF22 , and computer vision BIBREF23 .

In this paper we describe our new online handwriting recognition system based on deep learning methods. It replaces our previous segment-and-decode system BIBREF14 , which first over-segments the ink, then groups the segments into character hypotheses, and computes features for each character hypothesis which are then classified as characters using a rather shallow neural network. The recognition result is then obtained using a best path search decoding algorithm on the lattice of hypotheses incorporating additional knowledge sources such as language models. This system relies on numerous pre-processing, segmentation, and feature extraction heuristics which are no longer present in our new system. The new system reduces the amount of customization required, and consists of a simple stack of bidirectional LSTMs (BLSTMs), a single Logits layer, and the CTC loss BIBREF24 (Sec. SECREF2 ) trained for each script (Sec. SECREF3 ). To support potentially many languages per script (see Table TABREF5 ), language-specific language models and feature functions are used during decoding (Sec. SECREF38 ). E.g. we have a single recognition model for Arabic script which is combined with specific language models and feature functions for our Arabic, Persian, and Urdu language recognizers. Table TABREF5 shows the full list of scripts and languages that we currently support.

The new models are more accurate (Sec. SECREF4 ), smaller, and faster (Table TABREF68 ) than our previous segment-and-decode models and eliminate the need for a large number of engineered features and heuristics.

We present an extensive comparison of the differences in recognition accuracy for eight languages (Sec. SECREF5 ) and compare the accuracy of models trained on publicly available datasets where available (Sec. SECREF4 ). In addition, we propose a new standard experimental protocol for the IBM-UB-1 dataset BIBREF25 (Sec. SECREF50 ) to enable easier comparison between approaches in the future.

The main contributions of our paper are as follows:

## End-to-end Model Architecture

Our handwriting recognition model draws its inspiration from research aimed at building end-to-end transcription models in the context of handwriting recognition BIBREF24 , optical character recognition BIBREF21 , and acoustic modeling in speech recognition BIBREF18 . The model architecture is constructed from common neural network blocks, i.e. bidirectional LSTMs and fully-connected layers (Figure FIGREF12 ). It is trained in an end-to-end manner using the CTC loss BIBREF24 .

Our architecture is similar to what is often used in the context of acoustic modeling for speech recognition BIBREF19 , in which it is referred to as a CLDNN (Convolutions, LSTMs, and DNNs), yet we differ from it in four points. Firstly, we do not use convolution layers, which in our own experience do not add value for large networks trained on large datasets of relatively short (compared to speech input) sequences typically seen in handwriting recognition. Secondly, we use bidirectional LSTMs, which due to latency constraints is not feasible in speech recognition systems. Thirdly, our architecture does not make use of additional fully-connected layers before and after the bidirectional LSTM layers. And finally, we train our system using the CTC loss, as opposed to the HMMs used in BIBREF19 .

This structure makes many components of our previous system BIBREF14 unnecessary, e.g. for feature extraction and segmentation. The heuristics that were hard-coded into our previous system, e.g. stroke-reordering and character hypothesis building, are now implicitly learned from the training data.

The model takes as input a time series INLINEFORM0 of length INLINEFORM1 encoding the user input (Sec. SECREF13 ) and passes it through several bidirectional LSTM layers BIBREF26 which learn the structure of characters (Sec. SECREF34 ).

The output of the final LSTM layer is passed through a softmax layer (Sec. SECREF35 ) leading to a sequence of probability distributions over characters for each time step.

For CTC decoding (Sec. SECREF44 ) we use beam search to combine the softmax outputs with character-based language models, word-based language models, and information about language-specific characters as in our previous system BIBREF14 .

## Input Representation

In our earlier paper BIBREF14 we presented results on our datasets with a model similar to the one proposed in BIBREF24 . In that model we used 23 per-point features (similarly to BIBREF6 ) as described in our segment-and-decode system to represent the input. In further experimentation we found that in substantially deeper and wider models, engineered features are unnecessary and their removal leads to better results. This confirms the observation that learned representations often outperform handcrafted features in scenarios in which sufficient training data is available, e.g. in computer vision BIBREF27 and in speech recognition BIBREF28 . In the experiments presented here, we use two representations:

The simplest representation of stroke data is as a sequence of touch points. In our current system, we use a sequence of 5-dimensional points INLINEFORM0 where INLINEFORM1 are the coordinates of the INLINEFORM2 th touchpoint, INLINEFORM3 is the timestamp of the touchpoint since the first touch point in the current observation in seconds, INLINEFORM4 indicates whether the point corresponds to a pen-up ( INLINEFORM5 ) or pen-down ( INLINEFORM6 ) stroke, and INLINEFORM7 indicates the start of a new stroke ( INLINEFORM8 otherwise).

In order to keep the system as flexible as possible with respect to differences in the writing surface, e.g. area shape, size, spatial resolution, and sampling rate, we perform some minimal preprocessing:

Normalization of INLINEFORM0 and INLINEFORM1 coordinates, by shifting in INLINEFORM2 such that INLINEFORM3 , and shifting and scaling the writing area isometrically such that the INLINEFORM4 coordinate spans the range between 0 and 1. In cases where the bounding box of the writing area is unknown we use a surrogate area 20% larger than the observed range of touch points.

Equidistant linear resampling along the strokes with INLINEFORM0 , i.e. a line of length 1 will have 20 points.

We do not assume that words are written on a fixed baseline or that the input is horizontal. As in BIBREF24 , we use the differences between consecutive points for the INLINEFORM0 coordinates and the time INLINEFORM1 such that our input sequence is INLINEFORM2 for INLINEFORM3 , and INLINEFORM4 for INLINEFORM5 .

However simple, the raw input data has some drawbacks, i.e.

Resolution: Not all input devices sample inputs at the same rate, resulting in different point densities along the input strokes, requiring resampling which may inadvertently normalize-out details in the input.

Length: We choose the (re-)sampling rate such as to represent the smallest features well, which leads to over-sampling in less interesting parts of the stroke, e.g. in straight lines.

Model complexity: The model has to learn to map small consecutive steps to larger global features.

Bézier curves are a natural way to describe trajectories in space, and have been used to represent online handwriting data in the past, yet mostly as a means of removing outliers in the input data BIBREF29 , up-sampling sparse data BIBREF6 , or for rendering handwriting data smoothly on a screen BIBREF30 . Since a sequence of Bézier curves can represent a potentially long point sequence compactly, irrespective of the original sampling rate, we experiment with representing a sequence of input points as a sequence of parametric cubic polynomials, and using these as inputs to the recognition model.

These Bézier curves for INLINEFORM0 , INLINEFORM1 , and INLINEFORM2 are cubic polynomials in INLINEFORM3 , i.e..: DISPLAYFORM0 

We start by normalizing the size of the entire ink such that the INLINEFORM0 values are within the range INLINEFORM1 , similar to how we process it for raw points. The time values are scaled linearly to match the length of the ink such that DISPLAYFORM0 

in order to obtain values in the same numerical range as INLINEFORM0 and INLINEFORM1 . This sets the time difference between the first and last point of the stroke to be equal to the total spatial length of the stroke.

For each stroke in an ink, the coefficients INLINEFORM0 , INLINEFORM1 , and INLINEFORM2 are computed by minimizing the sum of squared errors (SSE) between each observed point INLINEFORM3 and its corresponding closest point (defined by INLINEFORM4 ) on the Bézier curve: DISPLAYFORM0 

Where INLINEFORM0 is the number of points in the stroke. Given a set of coordinates INLINEFORM1 , computing the coefficients corresponds to solving the following linear system of equations: DISPLAYFORM0 

which can be solved exactly for INLINEFORM0 , and in the least-squares sense otherwise, e.g. by solving the normalized equations DISPLAYFORM0 

for the coefficients INLINEFORM0 . We alternate between minimizing the SSE in eq. ( EQREF24 ) and finding the corresponding points INLINEFORM1 , until convergence. The coordinates INLINEFORM2 are updated using a Newton step on DISPLAYFORM0 

which is zero when INLINEFORM0 is orthogonal to the direction of the curve INLINEFORM1 .

If (a) the curve cannot fit the points well (SSE error is too large) or if (b) the curve has too sharp bends (arc length longer than 3 times the endpoint distance) we split the curve into two parts. We determine the split point in case (a) by finding the triplet of consecutive points with the smallest angle, and in case (b) as the point closest to the maximum local curvature along the entire Bézier curve. This heuristic is applied recursively until both the curve matching criteria are met.

As a final step, to remove spurious breakpoints, consecutive curves that can be represented by a single curve are stitched back together, resulting in a compact set of Bézier curves representing the data within the above constraints. For each consecutive pair of curves, we try to fit a single curve using the combined set of underlying points. If the fit agrees with the above criteria, we replace the two curves by the new one. This is applied repeatedly until no merging happens anymore.

Since the Bézier coefficients INLINEFORM0 , INLINEFORM1 , and INLINEFORM2 may vary significantly in range, each curve is fed to the network as a 10-dimensional vector consisting of:

the vector between the endpoints (Figure FIGREF28 , blue vector, 2 values),

the distance between the control points and the endpoints relative to the distance between the endpoints (green dashed lines, 2 values),

the two angles between each control point and the endpoints (green arcs, 2 values),

the time coefficients INLINEFORM0 , INLINEFORM1 and INLINEFORM2 (not shown),

a boolean value indicating whether this is a pen-up or pen-down curve (not shown).

Due to the normalization of the INLINEFORM0 , INLINEFORM1 , and INLINEFORM2 coordinates, as well as the constraints on the curves themselves, most of the resulting values are in the range INLINEFORM3 .

The input data is of higher dimension than the raw inputs described in Sec. UID14 , i.e. 10 vs. 5 dimensional, but the input sequence itself is roughly INLINEFORM0 shorter, making them a good choice for latency-sensitive models.

In most of the cases, as highlighted through the experimental sections in this paper, the curve representations contribute to better recognition accuracy and speed of our models. However, there are also situations where the curve representation introduces mistakes: punctuation marks become more similar to each other and sometimes are wrongly recognized, capitalization errors appear from time to time and in some cases the candidate recognitions corresponding to higher language model scores are preferred.

## Bidirectional Long-Short-Term-Memory Recurrent Neural Networks

LSTMs BIBREF31 have become one of the most commonly used RNN cells because they are easy to train and give good results BIBREF32 . In all experiments we use bidirectional LSTMs, i.e. we process the input sequence forward and backward and merge the output states of each layer before feeding them to the next layer. The exact number of layers and nodes is determined empirically for each script. We give an overview of the impact of the number of nodes and layers in section SECREF4 . We also list the configurations for several scripts in our production system, as of this writing.

## Softmax Layer

The output of the LSTM layers at each timestep is fed into a softmax layer to get a probability distribution over the INLINEFORM0 possible characters in the script (including spaces, punctuation marks, numbers or other special characters), plus a blank label required by the CTC loss and decoder.

## Decoding

The output of the softmax layer is a sequence of INLINEFORM0 time steps of INLINEFORM1 classes that we decode using CTC decoding BIBREF15 . The logits from the softmax layer are combined with language-specific prior knowledge (cp. Sec. SECREF38 ). For each of these additional knowledge sources we learn a weight (called “decoder weight” in the following) and combine them linearly (cp. Sec. SECREF3 ). The learned combination is used as described in BIBREF33 to guide the beam search during decoding.

This combination of different knowledge sources allows us to train one recognition model per script (e.g. Latin script, or Cyrillic script) and then use it to serve multiple languages (see Table TABREF5 ).

## Feature Functions: Language Models and Character Classes

Similarly to our previous work BIBREF14 , we define several scoring functions, which we refer to as feature functions. The goal of these feature functions is to introduce prior knowledge about the underlying language into the system. The introduction of recurrent neural networks has reduced the need for many of them and we now use only the following three:

Character Language Models: For each language we support, we build a 7-gram language model over Unicode codepoints from a large web-mined text corpus using Stupid back-off BIBREF35 . The final files are pruned to 10 million 7-grams each. Compared to our previous system BIBREF14 , we found that language model size has a smaller impact on the recognition accuracy, which is likely due to the capability of recurrent neural networks to capture dependencies between consecutive characters. We therefore use smaller language models over shorter contexts.

Word Language Models: For languages using spaces to separate words, we also use a word-based language model trained on a similar corpus as the character language models BIBREF36 , BIBREF37 , using 3-grams pruned to between 1.25 million and 1.5 million entries.

Character Classes: We add a scoring heuristic which boosts the score of characters from the language's alphabet. This feature function provides a strong signal for rare characters that may not be recognized confidently by the LSTM, and which the other language models might not weigh heavily enough to be recognized. This feature function was inspired by our previous system BIBREF14 .

In Section SECREF4 we provide an experimental evaluation of how much each of these feature functions contributes to the final result for several languages.

## Training

The training of our system happens in two stages, on two different datasets:

Using separate datasets is important because the neural network learns the local appearance as well as an implicit language model from the training data. It will be overconfident on its training data and thus learning the decoder weights on the same dataset could result in weights biased towards the neural network model.

## Connectionist Temporal Classification Loss

As our training data does not contain frame-aligned labels, we rely on the CTC loss BIBREF15 for training which treats the alignment between inputs and labels as a hidden variable. CTC training introduces an additional blank label which is used internally for learning alignments jointly with character hypotheses, as described in BIBREF15 .

We train all neural network weights jointly using the standard TensorFlow BIBREF34 implementation of CTC training using the Adam Optimizer BIBREF39 with a batch size of 8, a learning rate of INLINEFORM0 , and gradient clipping such that the gradient INLINEFORM1 -norm is INLINEFORM2 . Additionally, to improve the robustness of our models and prevent overfitting, we train our models using random dropout BIBREF40 , BIBREF41 after each LSTM layer with a dropout rate of INLINEFORM3 . We train until the error rate on the evaluation dataset no longer improves for 5 million steps.

## Bayesian Optimization for Tuning Decoder Weights

To optimize the decoder weights, we rely on the Google Vizier service and its default algorithm, specifically batched Gaussian process bandits, and expected improvement as the acquisition function BIBREF38 .

For each recognizer training we start 7 Vizier studies, each performing 500 individual trials, and then we pick the configuration that performed best across all of these trials. We experimentally found that using 7 separate studies with different random initializations regularly leads to better results than running a single study once. We found that using more than 500 trials per study does not lead to any additional improvement.

For each script we train these weights on a subset of the languages for which we have sufficient data, and transfer the weights to all the other languages. E.g. for the Latin-script languages, we train the decoder weights on English and German, and use the resulting weights for all languages in the first row of Table TABREF5 .

## Experimental Evaluation

In the following, where possible, we present results for public datasets in a closed data scenario, i.e. training and testing models on the public dataset using a standard protocol. In addition we present evaluation results for public datasets in an open data scenario against our production setup, i.e. in which the model is trained on our own data. Finally, we show experimental results for some of the major languages on our internal datasets. Whenever possible we compare these results to the state of the art and to our previous system BIBREF14 .

## IAM-OnDB

The IAM-OnDB dataset BIBREF42 is probably the most used evaluation dataset for online handwriting recognition. It consists of 298 523 characters in 86 272 word instances from a dictionary of 11 059 words written by 221 writers. We use the standard IAM-OnDB dataset separation: one training set, two validations sets and a test set containing 5 363, 1 438, 1 518 and 3 859 written lines, respectively. We tune the decoder weights using the validation set with 1 438 items and report error rates on the test set.

We perform a more extensive study of the number of layers and nodes per layer for both the raw and curve input formats to determine the optimal size of the bidirectional LSTM network (see Figure FIGREF48 , Table TABREF47 ). We first run experiments without additional feature functions (Figure FIGREF48 , solid lines), then re-compute the results with tuned weights for language models and character classes (Figure FIGREF48 , dashed lines). We observe that for both input formats, using 3 or 5 layers outperforms more shallow networks, and using more layers gives hardly any improvement. Furthermore, using 64 nodes per layer is sufficient, as wider networks give only small improvements, if at all.

Finally, we show a comparison of our old and new systems with the literature on the IAM-OnDB dataset in Table TABREF49 . Our method establishes a new state of the art result when relying on closed data using IAM-OnDB, as well as when relying on our in-house data that we use for our production system, which was not tuned for the IAM-OnDB data and for which none of the IAM-OnDB data was used for training.

To better understand where the improvements come from, we discuss the differences between the previous state-of-the-art system (Graves et al. BLSTM BIBREF24 ) and this work across four dimensions: input pre-processing and feature extraction, neural network architecture, CTC training and decoding, and model training methodology.

Our input pre-processing (Sec SECREF13 ) differs only in minor ways: the INLINEFORM0 -coordinate used is not first transformed using a high-pass filter, we don't split text-lines using gaps and we don't remove delayed strokes, nor do we do any skew and slant correction or other pre-processing.

The major difference comes from feature extraction. In contrast to the 25 features per point uesd in BIBREF24 , we use either 5 features (raw) or 10 features (curves). While the 25 features included both temporal (position in the time series) and spatial features (offline representation), our work uses only the temporal structure. In contrast also to our previous system BIBREF14 , using a more compact representation (and reducing the number of points for curves) allows a feature representation, including spatial structure, to be learned in the first or upper layers of the neural network.

The neural network architecture differs both in internal structure of the LSTM cell as well as in the architecture configuration. Our internal structure differs only in that we do not use peephole connections BIBREF44 .

As opposed to relying on a single bidirectional LSTM layer of width 100, we experiment with a number of configuration variants as detailed in Figure FIGREF48 . We note that it is particularly important to have more than one layer in order to learn a meaningful representation without feature extraction.

We use the CTC forward-backward training algorithm as described in BIBREF24 , and implemented in TensorFlow. The training hyperparameters are described in Section SECREF44 .

The CTC decoding algorithm incorporates feature functions similarly to how the dictionary is incorporated in the previous state-of-the-art system. However, we use more feature functions, our language models are trained on a different corpus, and the combination weights are optimized separately as described in Sec SECREF45 .

## IBM-UB-1

Another publicly-accessible English-language dataset is the IBM-UB-1 dataset BIBREF25 . From the available datasets therein, we use the English query dataset, which consists of 63 268 handwritten English words. As this dataset has not been used often in the academic literature, we propose an evaluation protocol. We split this dataset into 4 parts with non-overlapping writer IDs: 47 108 items for training, 4 690 for decoder weight tuning, 6 134 for validation and 5 336 for testing.

We perform a similar set of experiments as we did for IAM-OnDB to determine the right depth and width of our neural network architecture. The results of these experiments are shown in Figure FIGREF52 . The conclusion for this dataset is similar to the conclusions we drew for the IAM-OnDB: using networks with 5 layers of bidirectional LSTMs with 64 cells each is sufficient for good accuracy. Less deep and less wide networks perform substantially worse, but larger networks only give small improvements. This is true regardless of the input processing method chosen.

We give some exemplary results and a comparison with our current production system as well as results for our previous system in Table TABREF53 . We note that our current system is about 38% and 32% better (relative) in CER and WER, respectively, when compared to the previous segment-and-decode approach. The lack of improvement in error rate when evaluating on our production system is due to the fact that our datasets contain spaces while the same setup trained solely on IBM-UB-1 does not.

## Additional public datasets

We provide an evaluation of our production system trained on our in-house datasets applied to a number of publicly available benchmark datasets from the literature. Note that for all experiments presented in this section we evaluate our current live system without any tuning specifec to the tasks at hand.

The ICDAR-2013 Competition for Online Handwriting Chinese Character Recognition BIBREF45 introduced a dataset for classifying the most common Chinese characters. We report the error rates in comparison to published results from the competition and more recent work done by others in Table TABREF56 .

We evaluate our live production system on this dataset. Our system was not tuned to the task at hand and was trained as a multi-character recognizer, thus it is not even aware that each sample only contains a single character. Further, our system supports 12 363 different characters while the competition data only contains 3 755 characters. Note that our system did not have access to the training data for this task at all.

Whenever our system returns more than one character for a sample, we count this as an error (this happened twice on the entire test set of 224 590 samples). Despite supporting almost four times as many characters than needed for the CASIA data and not having been tuned to the task, the accuracy of our system is still competitive with systems that were tuned for this data specifically.

In the ICFHR2018 Competition on Vietnamese Online Handwritten Text Recognition using VNOnDB BIBREF50 , our production system was evaluated against other systems. The system used in the competition is the one reported and described in this paper. Due to licensing restrictions we were unable to do any experiments on the competition training data, or specific tuning for the competition, which was not the case for the other systems mentioned here.

We participated in the two tasks that best suited the purpose of our system, specifically the "Word" (ref. table TABREF58 ) and the "Text line" (ref. table TABREF59 ) recognition levels. Even though we can technically process paragraph level inputs, our system was not built with this goal in mind.

In contrast to us, the other teams used the training and validation sets to tune their systems:

The IVTOV team's system is very similar to our system. It makes use of bidirectional LSTM layers trained end-to-end with the CTC loss. The inputs used are delta INLINEFORM0 and INLINEFORM1 coordinates, together with pen-up strokes (boolean feature quantifying whether a stroke has ended or not). They report using a two-layer network of 100 cells each and additional preprocessing for better handling the dataset.

The MyScript team submitted two systems. The first system has an explicit segmentation component along with a feed-forward network for recognizing character hypotheses, similar in formulation to our previous system BIBREF14 . In addition, they also make use of a bidirectional LSTM system trained end-to-end with the CTC loss. They do not provide additional details on which system is which.

We note that the modeling stacks of the systems out-performing ours in this competition are not fundamentally different (to the best of our knowledge, according to released descriptions). We therefore believe that our system might perform comparably if trained on the competition training dataset as well.

On our internal testset of Vietnamese data, our new system obtains a CER of 3.3% which is 54% relative better than the old Segment-and-Decode system which had a CER of 7.2% (see also Table FIGREF69 ).

## Tuning neural network parameters on our internal data

Our in-house datasets consist of various types of training data, the amount of which varies by script. Sources of training data include data collected through prompting, commercially available data, artificially inflated data, and labeled/self-labeled anonymized recognition requests (see BIBREF14 for a more detailed description). The number of training samples varies from tens of thousands to several million per script, depending on the complexity and usage.

The best configuration for our production systems were identified by running multiple experiments over a range of layer depths and widths on our Latin script datasets. For the Latin script experiments shown in Figure FIGREF63 , the training set we used was a mixture of data from all the Latin-script languages we support and evaluation is done on an English validation dataset, also used for the English evaluation in Table TABREF68 .

Similarly to experiments depicted in Figure FIGREF48 and Figure FIGREF52 , increasing the depth and width of the network architecture brings diminishing returns fairly quickly. However, overfitting is less pronounced, particularly when relying on Bézier curve inputs, highlighting that our datasets are more complex in nature.

In all our experiments using our production datasets, the Bézier curve inputs outperformed the raw inputs both in terms of accuracy and recognition latency, and are thus used throughout in our production models. We hypothesize that this is due to the implicit normalization of sampling rates and thus line smoothness of the input data. The input data of our production datasets come from a wide variety of data sources including data collection and crowd sourcing from many different types of devices, unlike academic datasets such as IBM-UB-1 or IAM-OnDB which were collected under standardized conditions.

## System Performance and Discussion

The setup described throughout this paper that obtained the best results relies on input processing with Bézier spline interpolation (Sec. UID18 ), followed by 4–5 layers of varying width bidirectional LSTMs, followed by a final softmax layer. For each script, we experimentally determined the best configuration through multiple training runs.

We performed an ablation study with the best configurations for each of the eight most important scripts by number of users and compare the results with our previous work BIBREF14 (Table TABREF68 ). The largest relative improvement comes from the overall network architecture stack, followed by the use of the character language model and the other feature functions.

In addition, we show the relative improvement in error rates on the languages for which we have evaluation datasets of more than 2 000 items (Figure FIGREF69 ). The new architecture performs between 20%–40% (relative) better over almost all languages.

## Differences Between IAM-OnDB, IBM-UB-1 and our internal datasets

To understand how the different datasets relate to each other, we performed a set of experiments and evaluations with the goal of better characterizing the differences between the datasets.

We trained a recognizer on each of the three training sets separately, then evaluated each system on all three test sets (Table TABREF65 ). The neural network architecture is the same as the one we determined earlier (5 layers bidirectional LSTMs of 64 cells each) with the same feature functions, with weights tuned on the corresponding tuning dataset. The inputs are processed using Bézier curves.

To better understand the source of discrepancy when training on IAM-OnDB and evaluating on IBM-UB-1, we note the different characteristics of the datasets:

IBM-UB-1 has predominantly cursive writing, while IAM-OnDB has mostly printed writing

IBM-UB-1 contains single words, while IAM-OnDB has lines of space-separated words

This results in models trained on the IBM-UB-1 dataset not being able to predict spaces as they are not present in the dataset's alphabet. In addition, the printed writing style of IAM-OnDB makes recognition harder when evaluating cursive writing from IBM-UB-1. It is likely that the lack of structure through words-only data makes recognizing IAM-OnDB on a system trained on IBM-UB-1 harder than vice-versa.

Systems trained on IBM-UB-1 or IAM-OnDB alone perform significantly worse on our internal datasets, as our data distribution covers a wide range of use-cases not necessarily relevant to, or present, in the two academic datasets: sloppy handwriting, overlapping characters for handling writing on small input surfaces, non-uniform sampling rates, and partially rotated inputs.

The network trained on the internal dataset performs well on all three datasets. It performs better on IAM-OnDB than the system trained only thereon, but worse for IBM-UB-1. We believe that using only cursive words when training allows the network to better learn the sample characteristics, than when learning about space separation and other structure properties not present in IBM-UB-1.

## Conclusion

We describe the online handwriting recognition system that we currently use at Google for 102 languages in 26 scripts. The system is based on an end-to-end trained neural network and replaces our old Segment-and-Decode system. Recognition accuracy of the new system improves by 20% to 40% relative depending on the language while using smaller and faster models. We encode the touch inputs using a Bézier curve representation which performs at least as well as raw touch inputs but which also allows for a faster recognition because the input sequence representation is shorter.

We further compare the performance of our system to the state of the art on publicly available datasets such as IAM-OnDB, IBM-UB-1, and CASIA and improve over the previous best published result on IAM-OnDB.
