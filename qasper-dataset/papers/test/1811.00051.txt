# Generating Texts with Integer Linear Programming

**Paper ID:** 1811.00051

## Abstract

Concept-to-text generation typically employs a pipeline architecture, which often leads to suboptimal texts. Content selection, for example, may greedily select the most important facts, which may require, however, too many words to express, and this may be undesirable when space is limited or expensive. Selecting other facts, possibly only slightly less important, may allow the lexicalization stage to use much fewer words, or to report more facts in the same space. Decisions made during content selection and lexicalization may also lead to more or fewer sentence aggregation opportunities, affecting the length and readability of the resulting texts. Building upon on a publicly available state of the art natural language generator for Semantic Web ontologies, this article presents an Integer Linear Programming model that, unlike pipeline architectures, jointly considers choices available in content selection, lexicalization, and sentence aggregation to avoid greedy local decisions and produce more compact texts, i.e., texts that report more facts per word. Compact texts are desirable, for example, when generating advertisements to be included in Web search results, or when summarizing structured information in limited space. An extended version of the proposed model also considers a limited form of referring expression generation and avoids redundant sentences. An approximation of the two models can be used when longer texts need to be generated. Experiments with three ontologies confirm that the proposed models lead to more compact texts, compared to pipeline systems, with no deterioration or with improvements in the perceived quality of the generated texts.

## Introduction

The Semantic Web BIBREF0 , BIBREF1 and the growing popularity of Linked Data (data that are published using Semantic Web technologies) have renewed interest in concept-to-text natural language generation (nlg), especially text generation from ontologies BIBREF2 , BIBREF3 , BIBREF4 , BIBREF5 , BIBREF6 , BIBREF7 , BIBREF8 , BIBREF9 , BIBREF10 . An ontology provides a conceptualization of a knowledge domain (e.g., consumer electronics, diseases) by defining the classes and subclasses of the individuals (entities) in the domain, the possible relations between them etc. The current standard to specify Semantic Web ontologies is owl BIBREF11 , BIBREF12 , a formal language based on description logics BIBREF13 , rdf, and rdf schema BIBREF14 . Given an owl ontology for a knowledge domain, one can publish on the Web machine-readable statements about the domain (e.g., available products, known diseases, their features or symptoms), with the statements having formally defined semantics based on the ontology. nlg can then produce texts describing classes or individuals of the ontology (e.g., product descriptions, information about diseases) from the same statements. This way the same information becomes more easily accessible to both computers (which read the machine-readable statements) and end-users (who read the texts), which is one of the main goals of the Semantic Web.

nlg systems typically employ a pipeline architecture BIBREF15 . Firstly, content selection chooses the logical facts (axioms, in the case of an owl ontology) to be expressed in the text to be generated. The purpose of the next stage, text planning, ranges from simply ordering the facts to be expressed, in effect also ordering the sentences that will express them, to making more complex decisions about the rhetorical structure of the text. Lexicalization then selects the words and syntactic structures to express each fact as a single sentence. Sentence aggregation may then combine shorter sentences into longer ones. Another component generates appropriate referring expressions (pronouns, noun phrases etc.), and surface realization produces the final text, based on internal representations of the previous decisions. Each stage of the pipeline in effect performs a local optimization, constrained by decisions of the previous stages, and largely unaware of the consequences of its own decisions on the subsequent stages.

The pipeline architecture has engineering advantages (e.g., it is easier to specify and monitor the input and output of each stage), but produces texts that may be suboptimal, since the decisions of the generation stages are actually co-dependent BIBREF16 , BIBREF17 , BIBREF18 . Content selection, for example, may greedily select the most important facts among those that are relevant to the purpose of the text, but these facts may require too many words to express, which may be undesirable when space is limited or expensive. Selecting other facts, possibly only slightly less important, may allow the lexicalization stage to use much fewer words, or to report more facts in the same space. Decisions made during content selection and lexicalization (facts to express, words and syntactic structures to use) may also lead to more or fewer sentence aggregation opportunities, affecting the length and readability of the texts. Some of these issues can be addressed by over-generating at each stage (e.g., producing several alternative sets of facts at the end of content selection, several alternative lexicalizations etc.) and employing a final ranking component to select the best combination BIBREF19 . This over-generate and rank approach, however, may also fail to find an optimal solution, and generates an exponentially large number of candidate solutions when several components are pipelined.

In this article, we present an Integer Linear Programming (ilp) model that, unlike pipeline architectures, jointly considers choices available in content selection, lexicalization, and sentence aggregation to avoid greedy local decisions and produce more compact texts, i.e., texts that report more facts per word. Compact texts are desirable, for example, when generating short product descriptions to be included as advertisements in Web search results BIBREF20 , BIBREF21 . Question answering may also involve generating a natural language summary of facts (e.g., rdf triples) related to a question, without exceeding a maximum text length BIBREF22 ; the more compact the summary, the more facts can be reported in the available space, increasing the chances of reporting the information sought by the user. Compact texts are also desirable when showing texts on devices with small screens BIBREF23 or as subtitles BIBREF24 .

If an importance score is available for each fact, our model can take it into account to maximize the total importance (instead of the total number) of the expressed facts per word. The model itself, however, does not produce importance scores; we assume that the scores are produced by a separate process BIBREF25 , BIBREF26 , not included in our content selection. For simplicity, in the experiments of this article we treat all the facts as equally important. An extended version of our ilp model also considers a limited form of referring expression generation, where the best name must be chosen per individual or class among multiple alternatives. The extended model also avoids sentences that report information that is obvious (to humans) from the names of the individuals and classes (e.g., “A red wine is a kind of wine with red color”). Experiments with three owl ontologies from very different knowledge domains (wines, consumer electronics, diseases) confirm that our models lead to more compact texts, compared to pipeline systems with the same components, with no deterioration or with improvements in the perceived quality of the generated texts. Although solving ilp problems is in general np-hard BIBREF27 , off-the-shelf ilp solvers can be used. The available solvers guarantee finding a globally optimum solution, and they are very fast in practice in the ilp problems we consider, when the the number of available facts (per individual or class being described) is small. We also present an approximation of our ilp models, which is more efficient when the number of available facts is larger and longer texts need to be generated.

Our ilp models (and approximations) have been embedded in Naturalowl BIBREF10 , an nlg system for owl, as alternatives to the system's original pipeline architecture. We base our work on Naturalowl, because it is the only open-source nlg system for owl that implements all the processing stages of a typical nlg system BIBREF15 , it is extensively documented, and has been tested with several ontologies. The processing stages and linguistic resources of Naturalowl are typical of nlg systems BIBREF28 . Hence, we believe that our work is, at least in principle, also applicable to other nlg systems. Our ilp models do not directly consider text planning, but rely on the (external to the ilp model) text planner of Naturalowl. We hope to include more text planning and referring expression generation decisions directly in our ilp model in future work. We also do not consider surface realization, since it is not particularly interesting in Naturalowl; all the decisions have in effect already been made by the time this stage is reached.

The remainder of this article is structured as follows. Section "Background Information about NaturalOWL" below provides background information about Naturalowl. Section "Our Integer Linear Programming Models" defines our ilp models. Section "Computational Complexity and Approximations" discusses the computational complexity of our ilp models, along with the more efficient approximation that can be used when then number of available facts is large. Section "Experiments" presents our experiments. Section "Related Work" discusses previous related work. Section "Conclusions and Future Work" concludes and proposes future work.

## Background Information about NaturalOWL

Naturalowl produces texts describing classes or individuals (entities) of an owl ontology (e.g., descriptions of types of products or particular products). Given an owl ontology and a particular target class or individual to describe, Naturalowl first scans the ontology for owl statements relevant to the target. If the target is the class StEmilion, for example, a relevant owl statement may be the following. 

 SubclassOf(:StEmilion

 ObjectIntersectionOf(:Bordeaux

 ObjectHasValue(:locatedIn :stEmilionRegion)

 ObjectHasValue(:hasColor :red)

 ObjectHasValue(:hasFlavor :strong)

 ObjectHasValue(:madeFrom :cabernetSauvignonGrape)

 ObjectMaxCardinality(1 :madeFrom)))

The statement above defines StEmilion as the intersection of: (i) the class of Bordeaux wines; (ii) the class of all individuals whose locatedIn property has (for each individual) stEmilionRegion among its values (owl properties are generally many-valued); (iii)–(v) the classes of individuals whose hasColor, hasFlavor, and madeFromGrape property values include red, strong, and cabernetSauvignonGrape, respectively, without excluding wines that have additional values in these properties; and (vi) the class of individuals whose madeFromGrape property has exactly one value; hence, a St. Emilion wine is made exclusively from Cabernet Sauvignon grapes.

Naturalowl then converts each relevant statement into (possibly multiple) message triples of the form $\left<S, R, O\right>$ , where $S$ is an individual or class, $O$ is another individual, class, or datatype value, and $R$ is a relation (property) that connects $S$ to $O$ . For example, the ObjectHasValue(:madeFrom :cabernetSauvignonGrape) part of the owl statement above is converted to the message triple $<$ :StEmilion, :madeFrom, :cabernetSauvignonGrape $>$ . Message triples are similar to rdf triples, but they are easier to express as sentences. Unlike rdf triples, the relations ( $R$ ) of the message triples may include relation modifiers. For example, the ObjectMaxCardinality(1 :madeFrom) part of the owl statement above is turned into the message triple $<$ :StEmilion, maxCardinality(:madeFrom), 1 $S$0 , where maxCardinality is a relation modifier. Message triples may also contain conjunctions or disjunctions as their $S$1 , as in $S$2 :ColoradoTickFever, :hasSymptom, and(:fatigue, :headache, :myalgia) $S$3 . We use the terms `fact' and `message triple' as synonyms in the remainder of this article.

Having produced the message triples, Naturalowl consults a user model to select the most important ones, and orders the selected triples according to manually authored text plans. Later processing stages convert each message triple to an abstract sentence representation, aggregate sentences to produce longer ones, and produce appropriate referring expressions (e.g., pronouns). The latter three stages require a sentence plan for each relation ( $R$ ), while the last stage also requires natural language names (nl names) for the individuals and classes of the ontology. Rougly speaking, a sentence plan specifies how to generate a sentence to express a message triple involving a particular relation ( $R$ ), whereas an nl name specifies how to generate a noun phrase to refer to a class or individual by name. We provide more information about sentence plans and nl names in the following subsections. If sentence plans and nl names are not supplied, Naturalowl automatically produces them by tokenizing the owl identifiers of the relations, individuals, and classes of the ontology, acting as a simple ontology verbalizer BIBREF29 , BIBREF30 , BIBREF6 , BIBREF31 , BIBREF32 , BIBREF33 , BIBREF34 , BIBREF7 , BIBREF35 , BIBREF8 . The resulting texts, however, are of much lower quality BIBREF10 . For example, the resulting text from the owl statement above would be:

St Emilion is Bordeaux. St Emilion located in St Emilion Region. St Emilion has color Red. St Emilion has flavor Strong. St Emilion made from grape exactly 1: Cabernet Sauvignon Grape. 

By contrast, when appropriate sentence plans and nl names are provided, Naturalowl produces the following text:

St. Emilion is a kind of red, strong Bordeaux from the St. Emilion region. It is made from exactly one grape variety: Cabernet Sauvignon grapes. 

In this article, we assume that appropriate sentence plans and nl names are supplied for each ontology. They can be manually constructed using a Protégé plug-in that accompanies Naturalowl BIBREF10 . Semi-automatic methods can also be used to extract and rank candidate sentence plans and nl names from the Web, with a human selecting the best among the most highly ranked ones; in this case, it has been shown that high quality sentence plans and nl names can be constructed in a matter of a few hours (at most) per ontology BIBREF36 .

## The Natural Language Names of NaturalOWL

In Naturalowl, an nl name is a sequence of slots. The contents of the slots are concatenated to produce a noun phrase that names a class or individual. Each slot is accompanied by annotations specifying how to fill it in; the annotations may also provide linguistic information about the contents of the slot. For example, we may specify that the English nl name of the class :TraditionalWinePiemonte is the following.

[ ] $^{1}_{\textit {article}, \, \textit {indef}, \, \textit {agr}=3}$ [traditional] $^{2}_{\textit {adj}}$ [wine] $^{3}_{\textit {headnoun}, \, \textit {sing}, \, \textit {neut}}$ [from] $^{4}_{\textit {prep}}$ [ ] $^{5}_{\textit {article}, \, \textit {def}}$ [Piemonte] $^{6}_{\textit {noun}, \, \textit {sing}, \, \textit {neut}}$ [region] $^{7}_{\textit {noun}, \, \textit {sing}, \, \textit {neut}}$ 

The first slot is to be filled in with an indefinite article, whose number should agree with the third slot. The second slot is to be filled in with the adjective `traditional'. The third slot with the neuter noun `wine', which will also be the head (central) noun of the noun phrase, in singular number, and similarly for the other slots. Naturalowl makes no distinctions between common and proper nouns, but it can be instructed to capitalize particular nouns (e.g., `Piemonte'). In the case of the message triple $<$ :wine32, instanceOf, :TraditionalWinePiemonte $>$ , the nl name above would allow a sentence like “This is a traditional wine from the Piemonte region” to be produced.

The slot annotations allow Naturalowl to automatically adjust the nl names. For example, the system also generates comparisons to previously encountered individuals or classes, as in “Unlike the previous products that you have seen, which were all traditional wines from the Piemonte region, this is a French wine”. In this particular example, the head noun (`wine') had to be turned into plural. Due to number agreement, its article also had to be turned into plural; in English, the plural indefinite article is void, hence the article of the head noun was omitted. As a further example, we may specify that the nl name of the class FamousWine is the following.

[ ] $^{1}_{\textit {article}, \, \textit {indef}, \, \textit {agr}=3}$ [famous] $^{2}_{\textit {adj}}$ [wine] $^{3}_{\textit {headnoun}, \, \textit {sing}, \, \textit {neut}}$ 

If the triples $<$ :wine32, instanceOf, :TraditionalWinePiemonte $>$ and $<$ :wine32, instanceOf, :FamousWine $>$ were to be expressed, Naturalowl would then produce the single, aggregated sentence “This is a famous traditional wine from the Piemonte region”, instead of two separate sentences “This is a traditional wine from the Piemonte region” and “It is a famous wine”. The annotations of the slots, which indicate for example which words are adjectives and head nouns, are used by the sentence aggregation component to appropriately combine the two sentences. The referring expression generation component also uses the slot annotations to identify the gender of the head noun, when a pronoun has to be generated (e.g., `it' when the head noun is neuter).

We can now define more precisely nl names. An nl name is a sequence of one or more slots. Each slot is accompanied by annotations requiring it to be filled in with exactly one of the following:

(1) An article, definite or indefinite, possibly to agree with a noun slot.

(2) A noun flagged as the head. The number of the head noun must also be specified.

(3) An adjective flagged as the head. For example, the nl name of the individual :red may consist of a single slot, to be filled in with the adjective `red', which will also be the head of the nl name. The number and gender of the head adjective must be specified.

(4) Any other noun or adjective, (5) a preposition, or (6) any fixed (canned) string.

Exactly one head (noun or adjective) must be specified per nl name. For nouns and adjectives, the nl name may require a particular inflectional form to be used (e.g., in a particular number, case, or gender), or it may require an inflectional form that agrees with another noun or adjective slot. Multiple nl names can also be provided for the same individual or class, to produce more varied texts.

When providing nl names, an individual or class can also be declared to be anonymous, indicating that Naturalowl should avoid referring to it by name. For example, in a museum ontology, there may be a particular coin whose owl identifier is :exhibit49. We may not wish to provide an nl name for this individual (it may not have an English name); and we may want Naturalowl to avoid referring to the coin by tokenizing its identifier (“exhibit 49”). By declaring the coin as anonymous, Naturalowl would use only the nl name of its class (e.g., “this coin”), simply “this”, or a pronoun.

## The Sentence Plans of NaturalOWL

In Naturalowl, a sentence plan for a relation $R$ specifies how to construct a sentence to express any message triple of the form $\left<S, R, O\right>$ . Like nl names, sentence plans are sequences of slots with annotations specifying how to fill the slots in. The contents of the slots are concatenated to produce the sentence. For example, the following is a sentence plan for the relation :madeFrom.

[ $\mathit {ref}(S)$ ] $^{1}_{\textit {nom}}$ [make] $^{2}_{\textit {verb}, \, \textit {passive}, \, \textit {present}, \, \textit {agr}=1, \, \textit {polarity}=+}$ [from] $^{3}_{prep}$ [ $\mathit {ref}(O)$ ] $^{4}_{\textit {acc}}$ 

Given the message triple $<$ :StEmilion, :madeFrom, :cabernetSauvignonGrape $>$ , the sentence plan would lead to sentences like “St. Emilion is made from Cabernet Sauvignon grapes”, or “It is made from Cabernet Sauvignon grapes”, assuming that appropriate nl names have been provided for :StEmilion and :cabernetSauvignonGrape. Similarly, given $<$ :Wine, :madeFrom, :Grape $>$ , the sentence plan above would lead to sentences like “Wines are made from grapes” or “They are made from grapes”, assuming again appropriate nl names. As another example, the following sentence plan can be used with the relations :hasColor and :hasFlavor.

[ $\mathit {ref}(S)$ ] $^{1}_{\textit {nom}}$ [be] $^{2}_{\textit {verb}, \, \textit {active}, \, \textit {present}, \, \textit {agr}=1, \, \textit {polarity}=+}$ [ $\mathit {ref}(O)$ ] $^{3}_{\textit {nom}}$ 

For the message triples $<$ :StEmilion, :hasColor, :red $>$ and $<$ :StEmilion, :hasFlavor, :strong $>$ , it would produce the sentences “St. Emilion is red” and “St. Emilion is strong”, respectively.

The first sentence plan above, for :madeFrom, has four slots. The first slot is to be filled in with an automatically generated referring expression (e.g., pronoun or name) for $S$ , in nominative case. The verb of the second slot is to be realized in passive voice, present tense, and positive polarity (as opposed to expressing negation) and should agree (in number and person) with the referring expression of the first slot ( $\textit {agr}=1$ ). The third slot is filled in with the preposition `from', and the fourth slot with an automatically generated referring expression for $O$ , in accusative case.

Naturalowl has built-in sentence plans for domain-independent relations (e.g., isA, instanceOf). For example, $<$ :StEmilion, isA, :Bordeaux $>$ is expressed as “St. Emilion is a kind of Bordeaux” using the following built-in sentence plan; the last slot requires the nl name of $O$ without article.

[ $\mathit {ref}(S)$ ] $^1_{\textit {nom}}$ [be] $^2_{\textit {verb}, \, \textit {active}, \, \textit {present}, \, \textit {agr}=1, \, \textit {polarity}=+}$ [“a kind of”] $^3_{\textit {string}}$ [ $\mathit {name}(O)$ ] $^4_{\textit {noarticle}, \textit {nom}}$ 

Notice that the sentence plans are not simply slotted string templates (e.g., “ $X$ is made from $Y$ ”). Their linguistic annotations (e.g., pos tags, agreement, voice, tense, cases) along with the annotations of the nl names allow Naturalowl to produce more natural sentences (e.g., turn the verb into plural when the subject is in plural), produce appropriate referring expressions (e.g., pronouns in the correct cases and genders), and aggregate shorter sentences into longer ones. For example, the annotations of the nl names and sentence plans allow Naturalowl to produce the aggregated sentence “St. Emilion is a kind of red Bordeaux made from Cabernet Sauvignon grapes” from the triples $<$ :StEmilion, isA, :Bordeaux $>$ , $<$ :StEmilion, :hasColor, :red $>$ , $<$ :StEmilion, :madeFrom, :cabernetSauvignonGrape $>$ , instead of three sentences.

We can now define more precisely sentence plans. A sentence plan is a sequence of slots. Each slot is accompanied by annotations requiring it to be filled in with exactly one of the following:

(1) A referring expression for the $S$ (a.k.a. the owner) of the triple, in a particular case.

(2) A verb in a particular polarity and inflectional form (e.g., tense, voice), possibly to agree with another slot.

(3) A noun or adjective in a particular form, possibly to agree with another slot.

(4) A preposition, or (5) a fixed string.

(6) A referring expression for the $O$ (a.k.a. the filler) of the triple, in a particular case.

Multiple sentence plans can be provided per relation, to produce more varied texts and increase sentence aggregation opportunities. Sentence plans for message triples that involve relation modifiers (e.g., $<$ :StEmilion, maxCardinality(:madeFrom), 1 $>$ ) are automatically produced from the sentence plans for the corresponding relations without modifiers (e.g., $<$ :StEmilion, :madeFrom, :cabernetSauvignonGrape $>$ ).

## Importance Scores

Some message triples can lead to sentences that sound redundant, because they report relations that are obvious (to humans) from the nl names of the individuals or classes, as in the sentence “A red wine is a kind of wine with red color”. The sentence of our example reports the following two message triples:

 $<$ :RedWine, isA, :Wine $>$ , $<$ :RedWine, :hasColor, :Red $>$ 

Expressed separately, the two triples would lead to the sentences “A red wine is a kind of wine” and “A red wine has red color”, but Naturalowl aggregates them into a single sentence. It is obvious that a red wine is a wine with red color and, hence, the two triples above should not be expressed. Similarly, the following triple leads to the sentence “A white Bordeaux wine is a kind of Bordeaux”, which again seems redundant.

 $<$ :WhiteBordeaux, isA, :Bordeaux $>$ 

Naturalowl allows message triples to be assigned importance scores indicating how important (or interesting) it is to convey each message triple to different user types or particular users. Assigning a zero importance score to a message triple instructs Naturalowl to avoid expressing it. The importance scores can be constructed manually or by invoking an external user modeling component BIBREF10 . An additional mechanism of Naturalowl assigns zero importance scores to message triples like the ones above, which report relations that are obvious from the nl names; this is achieved by using heuristics discussed elsewhere BIBREF36 . In the experiments of this article, we use the zero importance scores that Naturalowl automatically assigns to some message triples, but we treat all the other message triples as equally important for simplicity.

## Our Integer Linear Programming Models

We now discuss our Integer Linear Programming (ilp) models, starting from the first, simpler version, which considers choices available in content selection, lexicalization, and sentence aggregation. Figure 1 illustrates the main decisions of the model. For content selection, the model decides which of the available facts (message triples) should be expressed. For lexicalization, it decides which sentence plan should be used for each fact that will be expressed, assuming that multiple sentence plans are available per fact. For sentence aggregation, it decides which simple sentences (each reporting a single fact) should be aggregated to form longer sentences, by partitioning the simple sentences (or equivalently the message triples they express) into groups (shown as buckets in Fig. 1 ). After using the ilp model, the aggregation rules of Naturalowl BIBREF10 are applied separately to the simple sentences of each group (bucket) to obtain a single aggregated sentence per group. To keep the ilp model simpler, the model itself does not control which particular aggregation rules will be applied to each group. The number of groups (buckets) is fixed, equal to the maximum number of (aggregated) sentences that the model can generate per text. To avoid generating very long aggregated sentences, the number of simple sentences that can be placed in each group (bucket) cannot exceed a fixed upper limit (the same for all groups). Groups left empty produce no sentences.

Our second, extended ilp model is very similar, but also performs a limited form of referring expression generation by selecting among multiple alternative nl names; it also takes into account that using a particular nl name may make expressing some other facts redundant (Section "Importance Scores" ). By contrast, the first, simpler ilp model assumes that a single nl name is available per individual and class (hence, no choice of nl names is needed) and does not try to avoid expressing redundant facts. In both models, a single (selected, or the only available one) nl name is picked per individual or class (unless the individual or class is marked as anonymous, see Section "The Natural Language Names of NaturalOWL" ), and it is used throughout the particular text being generated. Neither of the two models considers other referring expression generation decisions (e.g., whether to use a pronoun or a demonstrative noun phrase like “this wine”, as opposed to repeating the nl name of a wine). The existing referring expression generation component of Naturalowl BIBREF10 is subsequently invoked (after using the ilp models) to decide if the picked nl name, a pronoun, or a demonstrative noun phrase should be used wherever a reference to an individual or class is needed in the text being generated.

A further limitation of our models is that they do not directly consider text planning, relying on the (external to the ilp models) text planner of Naturalowl instead. The text planner is invoked (before using the ilp models) to partition the available message triples (the triples about the individual or class to be described) into topical sections; for example, message triples about the size, weight, and material of an electronic product may be placed in one section, and triples about the functions and features of the product in another one. This step is needed, because our ilp models never aggregate together sentences expressing facts from different topical sections, to avoid producing aggregated sentences that sound unnatural. The text planner is also invoked after using one of the ilp models, to order each group of simple sentences that the model has decided to aggregate. As already noted, each aggregated sentence is produced by applying the aggregation rules of Naturalowl to a group (bucket) of simple sentences, but the rules presuppose that the simple sentences to be aggregated are already ordered, which is why the text planer is invoked at this point. After applying the aggregation rules to each group of (ordered) simple sentences, the text planner is also used to order the topical sections, and the (now aggregated) sentences within each section.

## Our First ILP Model

Let us now focus on our first ilp model. As already noted, this model assumes that there is a single nl name per individual and class (excluding anonymous ones). Furthermore, the model assumes that all the nl names are short and approximately equally long.

Let $F = \lbrace f_1, \dots , f_n\rbrace $ be the set of all the available facts $f_{i}$ about the target individual or class $S$ to be described. Recall that we use the term `fact' as a synonym of `message triple'. For each fact $f_i = \left<S, R_i, O_i\right>$ , we assume that a set $P_{i} = \lbrace p_{i1}, p_{i2}, \dots \rbrace $ of alternative sentence plans is available; facts with the same relation ( $R_i$ ) have the same set of sentence plans ( $P_i$ ). Recall, also, that each sentence plan $p_{ik}$ specifies how to express $f_i$ as an alternative single sentence, and that a sentence plan is a sequence of slots, along with instructions specifying how to fill the slots in.

We call elements the unordered slots of a sentence plan along with their instructions, but with $S_i$ and $O_i$ accompanied by the individuals, classes, or datatype values they refer to. In the first example of Section "The Sentence Plans of NaturalOWL" , there are four elements: [ $\mathit {ref}(S$ = :StEmilion $)$ ], [make] $_{\textit {present}, \; \textit {passive}}$ , [from], [ $\mathit {ref}(O$ = :cabernetSauvignonGrape $)$ ]. When all the nl names are short and approximately equally long, we can roughly estimate the length (in words) of a sentence that will be produced to report a single fact, before actually producing the sentence, by counting the elements of the sentence plan that will be used to produce the sentence. Furthermore, we can roughly estimate the length of an aggregated sentence, i.e., a sentence that will be obtained by aggregating the simpler sentences (each reporting a single fact) of a group (bucket of Fig. 1 ), by counting the distinct elements (no duplicates) of the sentence plans that will be used to produce the simple sentences of the group, because duplicate elements (originating from more than one simple sentences) are typically expressed only once in the aggregated sentence.

In the following aggregation example, there are initially two simple sentences, produced by sentence plans identical to the first one of Section "The Sentence Plans of NaturalOWL" , except for the different prepositions. The sentence plans of the two simple sentences have four elements each: [ $\mathit {ref}(S$ = :BancroftChardonnay $)$ ], [make] $_{\textit {present}, \; \textit {passive}}$ , [by], [ $\mathit {ref}(O$ = :Mountadam $)$ ] and [ $\mathit {ref}(S$ = :BancroftChardonnay $)$ ], [make] $_{\textit {present}, \; \textit {passive}}$ , [in], [ $\mathit {ref}(O$ = :Bancroft $)$ ]. The distinct elements of the two sentence plans are only six, indicating that the aggregated sentence will be shorter than the two initial sentences together (eight elements in total).

Bancroft Chardonnay is made by Mountadam. It is made in Bancroft. $\Rightarrow $ 

Bancroft Chardonnay is made by Mountadam in Bancroft.

By contrast, if a slightly different sentence plan involving the verb `produce' is used in the first simple sentence, the aggregated sentence will be longer, as shown below. The sentence plans of the two simple sentences again have eight elements in total, but their distinct elements are seven ([ $\mathit {ref}(S$ = :BancroftChardonnay $)$ ], [produce] $_{\textit {present}, \; \textit {passive}}$ , [by], [ $\mathit {ref}(O$ = :Mountadam $)$ ], [make] $_{\textit {present}}$ , [in], [ $\mathit {ref}(O$ = :Bancroft $)$ ]), correctly predicting that the aggregated sentence will now be longer.

Bancroft Chardonnay is produced by Mountadam. It is made in Bancroft. $\Rightarrow $ 

Bancroft Chardonnay is produced by Mountadam and made in Bancroft.

The number of distinct elements is only an approximate estimate of the length of the aggregated sentence, because some of the names of the classes and individuals (e.g., `Bancroft Chardonnay') and some of the verb forms (e.g., `is made') are multi-word, but it allows the ilp model to roughly predict the length of an aggregated sentence by considering only sentence plans, before actually producing or aggregating any sentences.

The previous examples also show that selecting among alternative sentence plans affects the length of the generated text, not only because different sentence plans may require more or fewer words to express the same fact, but also because different combinations of sentence plans may produce more or fewer aggregation opportunities (e.g., shared verbs). Content selection also affects the length of the text, not only because different facts may require more or fewer words to report, but also because the selected facts may or may not have combinations of sentence plans that provide aggregation opportunities, and the aggregation opportunities may allow saving fewer or more words. For example, consider the following facts. Let us assume that all four facts are equally important, and that we want to generate a text expressing only four of them.

 <:MountadamRiesling, isA, :Riesling>

 <:MountadamRiesling, :hasBody, :Medium>

 <:MountadamRiesling, :hasMaker, :Mountadam>

 <:MountadamRiesling, :hasFlavor, :Delicate>

 <:MountadamRiesling, :hasSugar, :Dry>

A pipeline approach to generation, where the content selection decisions are made greedily without considering their effects on the later stages of lexicalization (in our case, sentence plan selection) and aggregation, might select the first four of the facts (perhaps randomly, since all facts are equally important). Assuming that lexicalization also does not consider the effects of its choices (selected sentence plans) on sentence aggregation, we may end up with the following text, before and after aggregation.

This is a Riesling. It is medium. It is produced by Mountadam. It has a delicate flavor. $\Rightarrow $ 

This is a medium Riesling, produced by Mountadam. It has a delicate flavor. 

On the other hand, a global approach that jointly considers the decisions of content selection, lexicalization, and aggregation might prefer to express the fifth fact instead of the fourth, and to use sentence plans that allow more compressive aggregations, leading to a much shorter text, as shown below.

This is a Riesling. It is medium. It is dry. It is delicate. $\Rightarrow $ This is a medium dry delicate Riesling. 

The length of the resulting text is important when space is limited or expensive, as already discussed, which is why we aim to produce compact texts, i.e., texts that report as many facts per word as possible (or texts that maximize the importance of the reported facts divided by the words used, when facts are not equally important). More precisely, given an individual or class of an owl ontology and a set of available facts about it, we aim to produce a text that:

expresses as many of the available facts as possible (or a text that maximizes the total importance of the reported facts, when facts are not equally important),

using as few words as possible.

By varying weights associated with Goals 1 and 2, we obtain different compact texts, aimed towards expressing more of the available facts at the expense of possibly using more words, or aimed towards using fewer words at the expense of possibly expressing fewer of the available facts.

We can now formally define our first ilp model. Let $s_1, \dots , s_m$ be disjoint subsets (buckets of Fig. 1 ) of $F = \lbrace f_1, \dots , f_n\rbrace $ (the set of available facts), each containing 0 to $n$ facts. A single aggregated sentence is generated from each subset $s_{j}$ by aggregating the simple sentences (more precisely, their selected sentence plans) that express the facts of $s_j$ . An empty $s_j$ generates no sentence. Hence, the resulting text can be at most $m$ aggregated sentences long. Let us also define: 

$$a_{i} &=& \left\lbrace 
\begin{array}{l l}
1, & \text{if fact $f_{i}$ is selected}\\
0, & \text{otherwise}\\
\end{array} \right.
\\

l_{ikj} &=& \left\lbrace 
\begin{array}{l l}
1, & \text{if sentence plan $p_{ik}$ is used to express fact $f_{i}$,
and $f_{i}$ is in subset $s_{j}$}\\
0, & \text{otherwise}\\
\end{array} \right.
\\

b_{tj} &=& \left\lbrace 
\begin{array}{l l}
1, & \text{if element $e_{t}$ is used in subset $s_{j}$}\\
0, & \text{otherwise}\\
\end{array} \right.$$   (Eq. 24) 

and let $B$ be the set of all the distinct elements (no duplicates) from all the available sentence plans $p_{ik}$ that can express the facts of $F$ . As already noted, the length of an aggregated sentence resulting from a subset $s_j$ can be roughly estimated by counting the distinct elements of the sentence plans that were chosen to express the facts of $s_j$ .

The objective function of our first ilp model (Eq. 25 below) maximizes the total importance of the selected facts (or simply the number of selected facts, if all facts are equally important), and minimizes the number of distinct elements in each subset $s_{j}$ , i.e., the approximate length of the corresponding aggregated sentence; an alternative explanation is that by minimizing the number of distinct elements in each $s_j$ , we favor subsets that aggregate well. By $a$ and $b$ we jointly denote all the $a_{i}$ and $b_{tj}$ variables. $|\sigma |$ denotes the cardinality of a set $\sigma $ . The two parts of the objective function are normalized to $[0, 1]$ by dividing by the total number of available facts $|F|$ and the number of subsets $s_j$0 times the total number of distinct elements $s_j$1 . We multiply $s_j$2 with the importance score $s_j$3 of the corresponding fact $s_j$4 . We assume that the importance scores range in $s_j$5 ; in our experiments, all the importance scores are set to 1, with the exception of redundant message triples that are assigned zero importance scores (Section "Importance Scores" ). The parameters $s_j$6 are used to tune the priority given to expressing many important facts vs. generating shorter texts; we set $s_j$7 + $s_j$8 = 1.

Constraint 26 ensures that for each selected fact, exactly one sentence plan is selected and that the fact is placed in exactly one subset; if a fact is not selected, no sentence plan for the fact is selected and the fact is placed in no subset. In Constraint , $B_{ik}$ is the set of distinct elements $e_t$ of the sentence plan $p_{ik}$ . This constraint ensures that if $p_{ik}$ is selected in a subset $s_{j}$ , then all the elements of $p_{ik}$ are also present in $s_{j}$ . If $p_{ik}$ is not selected in $s_{j}$ , then some of its elements may still be present in $s_j$ , if they appear in another selected sentence plan of $e_t$0 . In Constraint , $e_t$1 is the set of sentence plans that contain element $e_t$2 . If $e_t$3 is used in a subset $e_t$4 , then at least one of the sentence plans of $e_t$5 must also be selected in $e_t$6 . If $e_t$7 is not used in $e_t$8 , then no sentence plan of $e_t$9 may be selected in $p_{ik}$0 . Constraint limits the number of elements that a subset $p_{ik}$1 can contain to a maximum allowed number $p_{ik}$2 , in effect limiting the maximum (estimated) length of an aggregated sentence. Constraint ensures that facts from different topical sections will not be placed in the same subset $p_{ik}$3 , to avoid unnatural aggregations. 

$$\max _{a,b}{\lambda _1 \cdot \sum _{i=1}^{|F|}{\frac{a_{i} \cdot \mathit {imp}(f_{i})}{|F|}}
- \lambda _2 \cdot \sum _{j=1}^{m}\sum _{t=1}^{|B|}{\frac{b_{tj}}{m \cdot |B|}}}$$   (Eq. 25) 

subject to:

$$a_{i} = \sum _{j=1}^{m}\sum _{k=1}^{|P_{i}|}{l_{ikj}}, \mbox{for} \; i=1,\dots ,n
\\

\sum _{e_{t} \in B_{ik}}{b_{tj}} \ge |B_{ik}| \cdot l_{ikj}, \mbox{for} \left\lbrace 
\begin{array}{l}
i=1,\dots ,n \\
j=1,\dots ,m\\
k=1,\dots ,|P_{i}|\\
\end{array} \right.
\\

\sum _{p_{ik} \in P(e_t)}{l_{ikj}} \ge b_{tj} , \mbox{for} \left\lbrace 
\begin{array}{l}
t=1,\dots ,|B|\\
j=1,\dots ,m\\
\end{array} \right.
\\

\sum _{t=1}^{|B|}{b_{tj}} \le B_{max} , \mbox{for} \; j=1,\dots ,m
\\

\sum _{k=1}^{|P_{i}|}{l_{ikj}} + \sum _{k^{\prime }=1}^{|P_{i^{\prime }}|}{l_{i^{\prime }k^{\prime }j}} \le 1 , \mbox{for} \left\lbrace 
\begin{array}{l}
j=1,\dots ,m, \; i = 2, \dots , n\\
i^{\prime } = 1, \dots , n-1 ; i \ne i^{\prime } \\
\textit {section}(f_i) \ne \textit {section}(f_i^{\prime }) \\
\end{array} \right.$$   (Eq. 26) 

## Our Extended ILP Model

The ilp model of the previous section assumes that a single nl name is available for each individual or class (excluding anonymous ones). By contrast, our extended ilp model assumes that multiple alternative nl names are available. The reader is reminded that an nl name specifies how to generate a noun phrase naming an individual or class, and that it is a sequence of slots, along with instructions specifying how to fill them in.

For an individual or class acting as the $O$ of a fact $\left<S, R, O\right>$ to be expressed, the extended ilp model always selects the shortest available nl name. It takes, however, into account the length of the (shortest) nl name of $O$ when estimating the length of a sentence that will express $\left<S, R, O\right>$ . By contrast, the model of the previous section ignored the lengths of the nl names when estimating sentence lengths, assuming that all the nl names are short and approximately equally long, an assumption that does not always hold. For example, the Disease Ontology, one of the ontologies of our experiments, includes an individual with an nl name that produces the noun phrase “paralysis of the legs due to thrombosis of spinal arteries”, and another individual with an nl name that produces simply “inflammation”. Hence, a sentence that uses the former nl name to express a fact whose $O$ is the former individual will be much longer than a sentence that uses the latter nl name to express another fact whose $O$ is the latter individual, even if both sentences are produced by the same sentence plan.

The extended model also considers the possibility of $O$ being a conjunction or disjunction of classes, individuals, datatype values (Section "Background Information about NaturalOWL" ), as in the last fact below.

 <:BrazilianHemorrhagicFever, :isA, :ViralInfectiousDisease>

 <:BrazilianHemorrhagicFever, :hasMaterialBasisIn, :SabiaVirus>

 <:BrazilianHemorrhagicFever, :transmittedBy, :rodents>

 <:BrazilianHemorrhagicFever, :hasSymptom,

 and(:fatigue, :muscleAches, :dizziness)>

In the ilp model of the previous section, we made no distinction between $O$ s that are single classes, individuals, or datatype values, and $O$ s that are conjunctions or disjunctions, assuming that the number of conjuncts or disjuncts, respectively, is always small and does not affect much the length of the resulting sentence. In some ontologies, though, the number of conjuncts or disjuncts varies greatly. In the Disease Ontology, the number of conjuncts in the hasSymptom relation ranges from 1 to 14. Let us assume that we wish to generate a text for BrazilianHemorrhagicFever, that we are limited to expressing two facts, and that all facts are equally important. The model of the previous section might, for example, select the first and last of the facts above, possibly because their sentence plans are short (in elements), leading to the following sentence.

The Brazilian hemorrhagic fever is a viral infectious disease that causes fatigue, muscle aches and dizziness.

By contrast, the extended ilp model takes into account that the conjunction in the $O$ of the last fact above requires five words. Hence, it might select the first and third facts instead, producing the following shorter sentence.

The Brazilian hemorrhagic fever is a viral infectious disease transmitted by rodents. 

Note, also, that selecting the first and second facts, which only have single individuals or classes as $O$ s, would lead to the following sentence, which is longer, because of the length of “the Sabia virus”.

The Brazilian hemorrhagic fever is a viral infectious disease caused by the Sabia virus.

Selecting among the alternative nl names of the $S$ of a fact $\left<S,R,O\right>$ is more complicated, because a longer nl name (e.g., producing “the Napa Region Bancroft Chardonay wine”) may also convey some of the other available facts, without requiring separate sentences for them, thus saving words. Consider, for example, the following facts and assume that we wish to generate a text expressing all of them.

 <:BancroftChardonnay, isA, :Chardonnay>

 <:BancroftChardonnay, :locatedIn, :NapaRegion>

 <:BancroftChardonnay, :hasMaker, :Bancroft>

 <:BancroftChardonnay, :hasFlavor, :Moderate>

 <:BancroftChardonnay, :hasSugar, :Dry>

Let us also assume that BancroftChardonnay has three alternative nl names, which produce “Bancroft Chardonnay”, “the Napa Region Bancroft Chardonnay wine”, and “the moderate tasting and dry Bancroft Chardonnay wine”, respectively. For each alternative nl name of $S$ , we invoke the mechanism of Naturalowl (Section "Importance Scores" ) that detects redundant facts (message triples with zero importance scores). In our example, if we choose to refer to $S$ as “Bancroft Chardonnay”, we do not need to produce separate sentences for the first and third facts above, since they are already indirectly expressed by the nl name of $S$ , and similarly for the other two nl names of $S$ , as shown below.

 $S$ called “Bancroft Chardonnay”:

Bancroft Chardonnay is moderate and dry. It is produced in the Napa Region.

It is a Chardonnay. It is produced by Bancroft. 

 $S$ called “the Napa Region Bancroft Chardonnay wine”:

The Napa Region Bancroft Chardonnay wine is moderate and dry.

It is a Chardonnay. It is produced by Bancroft in the Napa Region. 

 $S$ called “the moderate tasting and dry Bancroft Chardonnay wine”:

The moderate tasting and dry Bancroft Chardonnay wine is produced in the Napa Region.

It is a moderate, dry Chardonnay. It is produced by Bancroft.

Selecting the nl name that produces the shortest noun phrase (“Bancroft Chardonnay”) does not lead to the shortest text. The shortest text is obtained when the second nl name is selected. Selecting the third nl name above, which leads to the largest number of facts made redundant (meaning facts that no longer need to be expressed as separate sentences), also does not lead to the shortest text, as shown above.

To further increase the range of options that the extended ilp model considers and help it to produce more compact texts, when using the extended ilp model we allow alternative nl names to be provided also for individuals or classes declared as `anonymous' (Section "The Natural Language Names of NaturalOWL" ); possibly anonymous is now a better term. In other words, the system can refer to an individual or class declared to be possibly anonymous, by using a demonstrative pronoun (“this”) or a demonstrative noun phrase mentioning the parent class (e.g., “this Chardonnay”), as with anonymous individuals and classes before, but it can also use an nl name of the individual or class (if provided), i.e., declaring an individual or class as possibly anonymous licenses the use of a demonstrative or demonstrative noun phrase, without excluding the use of an nl name. Continuing our example, let us assume that BancroftChardonnay has been declared as possibly anonymous. Then the following texts are also possible.

Demonstrative used for $S$ :

This is a moderate, dry Chardonnay. It is produced by Bancroft in the Napa Region. 

Demonstrative noun phrase used for $S$ :

This Chardonnay is moderate and dry. It is produced by Bancroft in the Napa Region.

It is a Chardonnay.

As illustrated above, a demonstrative noun phrase that mentions the ancestor class (e.g., “this Chardonnay”) is also taken to express the corresponding fact about the ancestor class (e.g., <:BancroftChardonnay, isA, :Chardonnay>). Notice, also, that using a demonstrative or demonstrative noun phrase does not necessarily lead to the shortest text. In our example, the shortest text is still obtained using the second nl name.

Before moving on to the formulation of the extended ilp model, let us discuss how it estimates the lengths of (possibly aggregated) sentences. In the ilp model of the previous section, we roughly estimated the length of an aggregated sentence resulting from a subset (bucket) $s_j$ by counting the distinct elements of the sentence plans chosen to express the facts of $s_j$ . For example, let us assume that the distinct elements [ $\mathit {ref}(S$ = :StEmilion $)$ ], [make] $_{\textit {present}, \; \textit {passive}}$ , [from], and [ $\mathit {ref}(O$ = :cabernetSauvignonGrape $)$ ] are used in a single subset $s_j$ . The ilp model of the previous section did not consider the lengths of the noun phrases that will be produced by the nl names of :StEmilion and :cabernetSauvignonGrape of the elements [ $\mathit {ref}(S$ = :StEmilion $)$ ] and [ $s_j$0 = :cabernetSauvignonGrape $s_j$1 ]. Also, it did not take into account that the element [make] $s_j$2 actually produces two words (“is made”).

The extended model defines a function $length(e_{t})$ that maps each distinct element $e_{t}$ to the length (in words) of the text it produces (e.g., “is made”). More specifically, if $e_{t}$ is an element referring to a single individual or class acting as the $O$ of a message triple (e.g., [ $\mathit {ref}(O$ = :cabernetSauvignonGrape $)$ ]), then $length(e_{t})$ is the length (in words) of the (shortest) nl name of $O$ ; if $O$ is a conjunction or disjunction, then $length(e_{t})$ is the sum of the lengths of the (shortest) nl names of all the conjuncts or disjuncts. However, if $e_{t}$0 is an element referring to $e_{t}$1 (e.g., [ $e_{t}$2 = :StEmilion $e_{t}$3 ]), then $e_{t}$4 , because the nl name of $e_{t}$5 will be used only once at the beginning of the text, and each subsequent reference to $e_{t}$6 will be via a pronoun of length 1 (e.g., “St. Emilion is red and strong. It is made from Cabernet Sauvignon grapes.”); the first occurrence of the nl name is counted separately, directly in the objective function discussed below. The estimated length of a (possibly aggregated) sentence is the sum of the estimated lengths ( $e_{t}$7 ) of the distinct elements of the sentence plan(s) that produced it. Overall, the extended model estimates more accurately the length of the text that will be produced, though the actual text length may still be slightly different; for example, connectives or complementizers (e.g., `and', `that') may be added during aggregation.

We can now formally define our extended ilp model. As in the simpler model of Section "Our First ILP Model" , $F$ is the set of available facts $f_i$ about the individual or class $S$ we wish to generate a text for, and $s_1, \dots , s_m$ are disjoint subsets of $F$ (buckets of Fig. 1 ) showing which simple sentences (each expressing a single fact of $F$ ) will be aggregated together. Let $N = \lbrace n_{1}, n_{2}, \dots \rbrace $ be a set of alternative nl names for $S$ . Recall that we model only the choice of nl name for $S$ , assuming that the shortest nl name is always used for the $O_i$ of each fact $f_i$0 . Each $f_i$1 variable now indicates if the corresponding fact $f_i$2 is explicitly expressed by generating a sentence: 

$$a_{i} = \left\lbrace 
\begin{array}{l l}
1, & \text{if the fact $f_{i}$ is expressed as a sentence}\\
0, & \text{otherwise}\\
\end{array} \right.$$   (Eq. 30) 

By contrast, $d_i$ is more general; $d_i = 1$ if the corresponding fact $f_i$ is conveyed either explicitly (by generating a sentence for $f_i$ ) or implicitly (via an nl name): 

$$d_{i} = \left\lbrace 
\begin{array}{l l}
1, & \text{if the fact $f_{i}$ is expressed as a sentence or via an \textsc {nl} name }\\
0, & \text{otherwise}\\
\end{array} \right.$$   (Eq. 31) 

The distinction between $a_i$ and $d_i$ is necessary, because when a fact $f_{i}$ is expressed as a sentence, a sentence plan for $f_i$ is also selected. For example, a fact $f_{i} =$ <:BancroftChardonnay, :hasMaker, :Bancroft> can be expressed as a sentence in the final text (e.g., “This is produced by Bancroft. It comes from the Napa Region.”) or through an nl name (e.g., “Bancroft Chardonnay is produced in the Napa Region.”). In both texts, $f_{i}$ is expressed ( $d_i = 1$ ), but in the former text $a_i = 1$ , whereas in the latter one $a_i = 0$ .

The $l_{ikj}$ and $b_{tj}$ variables are as in the ilp model of the previous section (Eq. and ). For the extended model, we also define: 

$$m_{r} = \left\lbrace 
\begin{array}{l l}
1, & \text{if the \textsc {nl} name $n_{r}$ is used for $S$}\\
0, & \text{otherwise}\\
\end{array} \right.$$   (Eq. 32) 

Similarly to the previous model's objective function ( 25 ), the extended model's objective function ( 33 ) maximizes the total importance of the expressed facts (or simply the number of expressed facts, if all facts are equally important), and minimizes the length of the distinct elements in each subset $s_{j}$ and the length of the (single, initial occurrence of the) nl name used to express $S$ , i.e., the approximate length of the resulting text. By $d$ , $b$ , and $m$ we jointly denote all the $d_{i}$ , $b_{tj}$ , and $m_{r}$ variables. The left part of the objective is the same as in the previous model, with the variables $a_{i}$ replaced by $d_i$ . In the right part, we multiply the $S$0 and $S$1 variables with the functions $S$2 and $S$3 , which calculate the lengths (in words) of the corresponding element ( $S$4 ) and nl name ( $S$5 ), respectively. The two parts of the objective function are normalized to $S$6 by dividing by the total number of available facts $S$7 and the number of subsets $S$8 times the total length of distinct elements $S$9 plus the total length of the $d$0 available nl names. Again, the parameters $d$1 are used to tune the priority given to expressing many important facts vs. generating shorter texts; we set $d$2 + $d$3 = 1. 

$$\max _{d,b,m}{\lambda _1 \cdot \sum _{i=1}^{|F|}{\frac{d_{i} \cdot \mathit {imp}(f_{i})}{|F|}}
- \lambda _2 \cdot (\frac{\sum _{j=1}^{m}\sum _{t=1}^{|B|}{b_{tj} \cdot length(e_{t})} + \sum _{r=1}^{|R|}{m_{r} \cdot length(n_{r})}}{m \cdot \sum _{t=1}^{|B|}{length(e_{t})} + \sum _{r=1}^{|R|}{length(n_{r})}})}$$   (Eq. 33) 

subject to:

$$a_{i} = \sum _{j=1}^{m}\sum _{k=1}^{|P_{i}|}{l_{ikj}}, \mbox{for} \; i=1,\dots ,n
\\

\sum _{e_{t} \in B_{ik}}{b_{tj}} \ge |B_{ik}| \cdot l_{ikj}, \mbox{for} \left\lbrace 
\begin{array}{l}
i=1,\dots ,n \\
j=1,\dots ,m\\
k=1,\dots ,|P_{i}|\\
\end{array} \right.
\\

\sum _{p_{ik} \in P(e_t)}{l_{ikj}} \ge b_{tj} , \mbox{for} \left\lbrace 
\begin{array}{l}
t=1,\dots ,|B|\\
j=1,\dots ,m\\
\end{array} \right.
\\

\sum _{t=1}^{|B|}{b_{tj} \cdot length(e_{t})} \le W_{max} , \mbox{for} \; j=1,\dots ,m
\\

\sum _{k=1}^{|P_{i}|}{l_{ikj}} + \sum _{k^{\prime }=1}^{|P_{i^{\prime }}|}{l_{i^{\prime }k^{\prime }j}} \le 1 , \mbox{for} \left\lbrace 
\begin{array}{l}
j=1,\dots ,m, \; i = 2, \dots , n\\
i^{\prime } = 1, \dots , n-1 ; i \ne i^{\prime } \\
\textit {section}(f_i) \ne \textit {section}(f_i^{\prime }) \\
\end{array} \right.$$   (Eq. 34) 

$$\sum _{r=1}^{|N|}{m_{r}} = 1
\\

d_{i} = a_i + \sum _{m_{r} \in R(f_{i})}{m_{r}}, \mbox{for} \; i=1,\dots ,n$$   (Eq. 35) 

Constraints 34 – serve the same purpose as in the previous model (Eq. 26 –), except that Constraint now limits the number of words (instead of elements) that a subset $s_{j}$ can contain to a maximum allowed number $W_{max}$ . Constraint 35 ensures that exactly one nl name is selected from the available nl names of $S$ . In Constraint , $R(f_{i})$ is the set of nl names that (indirectly) express the fact $f_{i}$ . If $f_i$ is to be expressed (i.e., $d_{i}=1$ ), then either one of the nl names in $R(f_{i})$ must be selected, or a sentence for $f_i$ must be generated ( $a_i = 1$ ), not both. If $W_{max}$0 is not to be expressed, then none of the nl names in $W_{max}$1 may be selected, nor should a sentence be generated for $W_{max}$2 .

## Computational Complexity and Approximations

The models of Sections "Our First ILP Model" and "Our Extended ILP Model" are formulated as ilp problems, more precisely binary ilp problems since all their variables are binary. Solving binary ilp problems is in general np-hard BIBREF27 . We also note that content selection, as performed by our models, is similar to the 0-1 multiple Knapsack problem, which is also np-hard. In both cases, we have $n$ items (facts), $m$ knapsacks (fact subsets, buckets) of a certain capacity, and we wish to fill the knapsacks with $m$ disjoint subsets of the available items, so that the total importance of the selected items (items placed in the knapsacks) is maximum. However, in our models each item (fact) is further associated with a set of (sentence plan) elements, subsets of which are possibly shared (in a subset, bucket) with other items (facts), and the capacity of the knapsacks is specified in distinct elements. Furthermore, the elements of each item depend on the selected sentence plans, there are additional constraints to comply with topical sections, and the objective function of our models also tries to minimize the total length of the resulting text. Hence, our models do not correspond directly to the 0-1 multiple Knapsack problem.

A possible approach to solve ilp models in polynomial time is to relax the constraint that variables are integer (or binary) and solve the resulting Linear Programming model (lp relaxation) using, for example, the Simplex algorithm BIBREF38 . The resulting values of the variables are then rounded to the closest integral values. The solution is not guaranteed to be optimal for the original ilp problem, nor feasible (some constraints of the original problem may be violated). The solution of the lp relaxation, though, is the same as the solution of the original ilp problem if the problem can be formulated as $\max _x c^{T}x$ with constraints $Ax = b$ , where $c$ , $A$ , $m$ have integer values and the matrix $A$ is totally unimodular BIBREF39 , BIBREF40 . An integer matrix is totally unimodular if every square, nonsingular submatrix is unimodular (i.e., its determinant is 0, 1, or -1). Unfortunately, this is not the case in our ilp models.

In practice, off-the-shelf solvers that solve the original ilp problem (not the lp relaxation) are very fast when the number of variables is small. Our experiments show that solving the first ilp model is reasonably fast, provided that the number of fact subsets (buckets) is $m \le 4$ . Indeed, $m$ seems to be the greatest factor to the model's complexity; the number of variables in the model grows exponentially to $m$ , while the effect of the other parameters (e.g., number of available facts $|F|$ ) is weaker. We did not examine experimentally how the solving times of the extended ilp model relate to the number of subsets $m$ ; however, the variables in the extended model also grow exponentially to the number of fact subsets $m$ .

When the number of variables is too large to solve the first ilp model efficiently, we use an approximation of the model, which considers each fact subset (bucket, aggregated sentence of the final text) separately (Fig. 2 ). We start with the full set of available facts ( $F$ ) and use the first ilp model with $m=1$ to produce the first (aggregated) sentence of the final text. We then remove the facts expressed by the first (aggregated) sentence from $F$ , and use the ilp model, again with $m=1$ , to produce the second (aggregated) sentence etc. This process is repeated until we produce the maximum number of allowed aggregated sentences, or until we run out of available facts.

Since the approximation of the first ilp model does not consider all the fact subsets jointly, it does not guarantee finding a globally optimal solution for the entire text. Nevertheless, experiments (presented below) that compare the approximation to the original first ilp model show no apparent decline in text quality nor in the ability to produce compact texts. Solving times now grow almost linearly to both the number of subsets $m$ and the number of available facts $|F|$ . Furthermore, $|F|$ decreases in every subsequent solving of the model (to produce the next aggregated sentence of the text), which reduces the time needed by the solver. Our experiments indicate that the approximation can guarantee practical running times even for $m \ge 5$ , while still outperforming the pipeline approach in terms of producing more compact texts.

The same approximation (considering each fact subset separately) can be applied to our extended ilp model. We did not experiment with the approximation of the extended model, however, because the only ontology we considered that required $m \ge 5$ and, hence, an approximation (Consumer Electronics Ontology) did not require the extended model (the lengths of the nl names did not vary significantly, and we could not think of alternative nl names for the products being described).

## Experiments

We now present the experiments we performed to evaluate our ilp models. We first discuss the ontologies and systems that were used in our experiments.

## The Ontologies of our Experiments

We experimented with three owl ontologies: (1) the Wine Ontology, which provides information about wines, wine producers etc.; (2) the Consumer Electronics Ontology, intended to help exchange information about consumer electronics products; and (3) the Disease Ontology, which describes diseases, including their symptoms, causes etc. The Wine Ontology is one of the most commonly used examples of owl ontologies and involves a wide variety of owl constructs; hence, it is a good test case for systems that produce texts from owl. The Consumer Electronics and Disease Ontologies were constructed by biomedical and e-commerce experts to address real-life information needs; hence, they constitute good real-world test cases from different domains.

The Wine Ontology contains 63 wine classes, 52 wine individuals, a total of 238 classes and individuals (including wineries, regions, etc.), and 14 relations (properties). Manually authored, high-quality domain-dependent generation resources (text plans, sentence plans, nl names etc.) for Naturalowl are available for this ontology from our previous work BIBREF10 .

The Consumer Electronics Ontology comprises 54 classes and 441 individuals (e.g., printer types, paper sizes, manufacturers), but no information about particular products. In previous work BIBREF10 , we added 60 individuals (20 digital cameras, 20 camcorders, 20 printers). The 60 individuals were randomly selected from a publicly available dataset of 286 digital cameras, 613 camcorders, and 58 printers that complies with the Consumer Electronics Ontology. From these 60 individuals, we generate texts for the 30 `development' individuals (10 cameras, 10 camcorders, 10 printers), for which high-quality manually authored domain-dependent generation resources are available from our previous work.

The Disease Ontology currently contains information about 6,286 diseases, all represented as classes. Apart from is-a relations, synonyms, and pointers to related terms, however, all the other information is represented using strings containing quasi-English sentences with relation names used mostly as verbs. For example, there is an axiom in the ontology stating that the Rift Valley Fever (doid_1328) is a kind of viral infectious disease (doid_934). All the other information about the Rift Valley Fever is provided in a string, shown below as `Definition'. The tokens that contain underscores (e.g., results_in) are relation names. The ontology declares all the relation names, but uses them only inside `Definition' strings. Apart from diseases, it does not define any of the other entities mentioned in the `Definition' strings (e.g., symptoms, viruses).

Name: Rift Valley Fever (doid_1328)

is-a: viral infectious disease (doid_934)

Definition: A viral infectious disease that results_in infection, has_material_basis_in Rift Valley fever virus, which is transmitted_by Aedes mosquitoes. The virus affects domestic animals (cattle, buffalo, sheep, goats, and camels) and humans. The infection has_symptom jaundice, has_symptom vomiting blood, has_symptom passing blood in the feces, has_symptom ecchymoses (caused by bleeding in the skin), has_symptom bleeding from the nose or gums, has_symptom menorrhagia and has_symptom bleeding from venepuncture sites. 

We defined as individuals all the non-disease entities mentioned in the `Definition' strings, also adding statements to formally express the relations mentioned in the original `Definition' strings. For example, the resulting ontology contains the following definition of Rift Valley Fever, where :infection, :Rift_Valley_fever_virus, :Aedes_mosquitoes, :jaundice etc. are new individuals.

 SubClassOf(:DOID_1328

 ObjectIntersectionOf(:DOID_934

 ObjectHasValue(:results_in :infection)

 ObjectHasValue(:has_material_basis_in :Rift_Valley_fever_virus)

 ObjectHasValue(:transmitted_by :Aedes_mosquitoes)

 ObjectHasValue(:has_symptom :jaundice)

 ObjectHasValue(:has_symptom :vomiting_blood)

 ObjectHasValue(:has_symptom :passing_blood_in_the_feces)

 ObjectHasValue(:has_symptom

 :ecchymoses_(caused_by_bleeding_in_the_skin))

 ObjectHasValue(:has_symptom :bleeding_from_the_nose_or_gums)

 ObjectHasValue(:has_symptom :menorrhagia)

 ObjectHasValue(:has_symptom :bleeding_from_venepuncture_sites)))

The new form of the ontology was produced automatically, using patterns that searched the definition strings for relation names (e.g., results_in), sentence breaks, and words introducing secondary clauses (e.g., “that”, “which”). Some sentences of the original definition strings that did not include declared relation names (e.g., “The virus affects...and humans” in the `Definition' string of Rift Valley Fever) were discarded, because they could not be automatically converted to appropriate owl statements.

The new form of the Disease Ontology contains 6,746 classes, 15 relations, and 1,545 individuals. From the 6,746 classes (all describing diseases), 5,014 classes participate only in is-a and synonym relations; hence, texts for them would not be particularly interesting. From the remaining 1,732 classes, we generate texts for the 200 randomly selected `development' classes of Evaggelakaki Evaggelakaki2014, for which manually authored domain-dependent generation resources for Naturalowl are available.

## The Systems of our Experiments

We call pipeline the original Naturalowl, which uses a pipeline architecture. Two modified versions of Naturalowl, called ilpnlg and ilpnlgextend, use our first and extended ilp models, respectively. All the systems of our experiments share the same linguistic resources (e.g., text plans, sentence plans, nl names, aggregation rules), ontologies, and importance scores; all facts are assigned an importance of 1, except for facts that are automatically assigned zero importance scores (Section "Importance Scores" ).

pipeline has a parameter $M$ specifying the number of facts to report per generated text. During content selection, pipeline ranks all the available facts ( $F$ ) by decreasing importance, and selects the $M$ most important ones (or all of them if $M > |F|$ ) selecting randomly among facts with the same importance when needed. In the experiments that follow, we generated texts with pipeline for different values of $M$ . For each $M$ value, the texts of pipeline were generated $T$ times, each time using a different (randomly selected) alternative sentence plan of each relation, and a different (randomly selected) nl name of each individual or class (when multiple alternative nl names were available). For the pipeline model, we assume that the sentence plans and nl names are uniformly distributed with each being equally probable to be selected. For the aggregation of the selected facts, pipeline uses the text planner from the original Naturalowl. The text planner is invoked after content selection to partition the selected facts into topical sections, and to order the topical sections and the facts within each topical section. The aggregation rules are then applied to all the facts of each topical section (also considering their selected sentence plans). From the $T$ generated texts, pipeline returns the one which is estimated to have the highest facts per word ratio. Rather than use the actual length of each produced text to calculate the facts per words ratio, the number of words is instead estimated as the sum of distinct elements in each sentence of the text, to better align the objective of pipeline to that of ilpnlg.

We also generated the texts (for different values of $M$ ) using a variant of pipeline, dubbed pipelinestoch, which selects randomly amongst available facts, in addition to sentence plans and nl names. However, unlike pipeline, the probability of each sentence plan or nl name is based on their respective length (in distinct elements), with the shortest ones being more probable to be selected. The fact's probabilities are similarly estimated by the length of the shortest sentence plan and nl name available to them. In regards to aggregation, pipelinestoch constructs fact subsets (corresponding to sentences in the final text) with the objective of minimizing the number of distinct elements in each subset, similarly to ilpnlg. Each subset is initialized with random facts (sampled based on the length of their available resources) and subsequent facts are randomly placed in each subset, with probabilities estimated on the number of elements each fact has in common with the facts already in that particular subset. As with pipeline, for each $M$ the texts are generated $T$ times, and the one with the highest facts per word ratio is used for the evaluation.

A greedier variant of pipeline, pipelineshort always selects the shortest (in elements) sentence plan among the available ones and the shortest (in words) nl name. In pipelineshort, if a subset of facts has the same importance, they are additionally ranked by increasing length of the shortest sentence plan and nl name available to each; this way the fact with the potential to generate the shortest sentence will be selected first.

Our final baseline, pipelinebeam extends the output of pipelineshort by employing beam search to select alternative facts, sentence plans, nl names and fact subsets. During content selection, pipelinebeam selects the subset of $M$ facts with the shortest sentence plans and nl names available to them (similarly to pipelineshort), and subsequently replaces a single random (based on the length of the available resources) fact from this subset with a random non-selected fact. This process is repeated until $K-1$ additional fact subsets are constructed; all differing from the initial subset by one (replaced) fact. In a similar way, $K$ different sentence plan assignments, $K$ different nl name assignment and $K$ different fact subset assignments are also constructed, differing from the respective assignments of pipelineshort by one substitution each. The combination of these assignments result in $K$ $\times $ $K$ $\times $ $K$ $K-1$0 $K-1$1 different texts for each $K-1$2 . As in the other baselines, the text amongst these with the highest estimated facts per words ratio is used for the evaluation.

To better compare the output of the pipeline baselines, we set the number of generated texts $T$ that pipeline, pipelinestoch and pipelineshort generate to $K$ $\times $ $K$ $\times $ $K$ $\times $ $K$ as pipelinebeam.

All the systems use the same text planner (from the original Naturalowl) which is invoked before content selection to partition the facts into topical sections, and to order the topical sections and the facts within each topical section. Each of the systems described above have different strategies to partition the selected facts after content selection in sentences. The selected facts retain the order given from the text planner, and the sentences inherit the minimum order of their included facts. Afterwards, aggregation rules are applied to all the facts of each fact subset (also considering their selected sentence plans). the text planner is first invoked (before using the ilp models) to partition all the available facts ( $F$ ) into topical sections. It is also invoked after using one of the ilp models, to order the sentences in each group (bucket) that the ilp model has decided to aggregate; as already noted, the aggregation rules presuppose that the sentences to be aggregated are already ordered, which is why the text planer is invoked at this point. After applying the aggregation rules to each group of (ordered) sentences, ilpnlg and ilpnlgextend invoke the text planner again to order the topical sections and the (now aggregated) sentences within each topical section.

ilpnlg assumes that there is a single nl name per individual or class (excluding anonymous ones) and, hence, cannot be used when multiple alternative nl names are available. By contrast, ilpnlgextend can handle multiple alternative nl names. For each text, it selects a single nl name per individual and class (as discussed in Section "Our Extended ILP Model" ), which is then replaced by a demonstrative, demonstrative noun phrase, or pronoun, whenever the referring expression generation component of the original Naturalowl decides to. pipeline and pipelineshort can also handle multiple nl names, but pipeline selects randomly among the alternative nl names, and pipelineshort selects always the shortest one. Like ilpnlgextend, for each text pipeline and pipelineshort select a single nl name per individual and class, which is then replaced by a demonstrative, demonstrative noun phrase, or pronoun, whenever the referring expression generation component of the original Naturalowl decides to.

A variant of pipelineshort, called pipelineshort*, always selects the shortest (now in words) sentence plan among the available ones, and the nl name of $S$ (the individual or class the text is generated for) that indirectly expresses the largest number of available facts $f_i = \left<S,R_i,O_i\right>$ (Section "Importance Scores" ), thus not requiring sentences to express them. For $O_i$ , pipelineshort* selects the same (shortest in words) nl name as ilpnlgextend and pipelineshort. Otherwise, pipelineshort* is identical to pipelineshort. pipelineshort* is a more appropriate baseline for ilpnlgextend than pipelineshort, because like ilpnlgextend it estimates the lengths of sentences and nl names in words, and it takes into account that nl names may indirectly express some of the available facts.

Finally, ilpnlgapprox denotes a system that is identical to ilpnlg (it uses our first ilp model), but with the approximation of Section "Computational Complexity and Approximations" , whereby each (possibly aggregated) sentence of the text is generated separately.

## Overview of the Experiments

Before presenting the details of our experiments, let us first provide an overview. We started by comparing ilpnlg to pipeline and pipelineshort on the Wine Ontology, where experiments showed that ilpnlg leads to more compact texts, i.e., texts with higher facts per word ratios, with no deterioration in the perceived quality of the resulting texts, compared to the texts of pipeline and pipelineshort.

We then tried to repeat the same experiments on the Consumer Electronics Ontology, but ilpnlg was too slow in many cases, because of the larger number of available facts per product ( $|F|$ ) and the larger ( $m=10$ ) number of subsets (buckets) required to express all (or many) of the available facts. To address this problem, we developed the approximation (Section "Computational Complexity and Approximations" ) of ilpnlg, which is used in ilpnlgapprox. The approximation was much more efficient and achieved higher facts per word ratios than pipeline and pipelineshort, with no deterioration in the perceived quality of the texts. In texts expressing many facts, the perceived quality of the texts of ilpnlgapprox was actually higher, comparing to the texts of pipeline and pipelineshort.

We then moved on to the Disease Ontology, to experiment with an additional domain. Since the Disease Ontology only required $m=4$ fact subsets to express all the available facts per disease, ilpnlgapprox was not required, and ilpnlg was used instead. We found that ilpnlg did not always perform better than pipeline and pipelineshort (in terms of facts per word ratios), because the lengths of the nl names of the Disease Ontology vary a lot, and there are also several facts $\left<S,R,O\right>$ whose $O$ is a conjunction, sometimes with many conjuncts. To address these issues, we extended ilpnlg to ilpnlgextend, which consistently produced more compact texts than pipeline and pipelineshort* on the Disease Ontology.

Lastly, we returned to the Wine Ontology to see how ilpnlgextend performs with multiple alternative nl names. For this experiment, we created alternative nl names for the individuals and classes of the Wine Ontology; we could not do the same for the Consumer Electronics and Disease Ontologies, because the names of electronic products tend to be unique and we did not have the expertise to create alternative names of diseases. Indeed, ilpnlgextend produced more compact texts than pipeline and pipelineshort* from the Wine Ontology, when multiple nl names were available.

## Experiments with the Wine Ontology

In a first set of experiments, we used the Wine Ontology, along with the manually authored domain-dependent generation resources (e.g., text plans, nl names, sentence plans) we had constructed for this ontology in previous work BIBREF10 . We added more sentence plans to ensure that three sentence plans were available per relation. A single nl name was available per individual and class in these experiments. We generated English texts for the 52 wine individuals of the ontology; we did not experiment with texts describing classes, because we could not think of multiple alternative sentence plans for many of their axioms. For each wine individual, there were 5 available facts on average and a maximum of 6 facts.

We generated texts with ilpnlg, pipeline, and pipelineshort for the 52 individuals. With pipeline and pipelineshort, we generated texts for $M = 2, 3, 4, 5, 6$ ; recall that $M$ is the number of selected facts per text, and that for each $M$ value the texts of pipeline and pipelineshort are generated three times, with randomly selected sentence plans (Section "The Systems of our Experiments" ). With ilpnlg, we repeated the generation of the texts of the 52 individuals using different $\lambda _1$ values ( $\lambda _2 = 1 - \lambda _1$ ), which led to texts expressing from zero to all of the available facts. We set the maximum number of fact subsets to $m = 3$ , which was the maximum number of sentences (after aggregation) in the texts of pipeline and pipelineshort. All three systems were allowed to form aggregated sentences with up to $B_{max} = 22$ distinct elements; this was the number of distinct elements of the longest aggregated sentence in our previous experiments BIBREF10 , where pipeline was allowed to combine up to three simple (expressing one fact each) sentences to form an aggregated one.

For each $M$ value (in the case of pipeline and pipelineshort) and for each $\lambda _1$ value (in the case of ilpnlg), we measured the average (over the 52 texts) number of facts each system reported per text (horizontal axis of Fig. 3 ), and the average (again over the 52 texts) number of facts each system reported per text divided by the average (over the 52 texts) number of words (vertical axis of Fig. 3 , with error bars showing 95% confidence intervals). As one would expect, pipelineshort expressed on average more facts per word (Fig. 3 ) than pipeline, but the differences were small.

For $\lambda _1 \le 0.1$ (far left of Fig. 3 ), ilpnlg produces empty texts, because it focuses on minimizing the number of distinct elements of each text. For $\lambda _1 \ge 0.2$ , it performs better than pipeline and pipelineshort. For $\lambda _1 \approx 0.3$ , it obtains the highest average facts per word ratio by selecting the facts and sentence plans that lead to the most compressive aggregations. For greater values of $\lambda _1$ , it selects additional facts whose sentence plans do not aggregate that well, which is why the ratio declines. When $M$ is small, the two pipeline systems often select facts and sentence plans that offer few aggregation opportunities; as the number of selected facts increases, some more aggregation opportunities arise, which is why the facts per word ratio of the two systems improves.

Figure 4 provides an alternative view of the behavior of the three systems. In this case, we group together all the texts of each system (regardless of the $M$ or $\lambda _1$ values that were used to generate them) that report 2, 3, 4, 5, or 6 facts (horizontal axis of Fig. 4 ). For each group (and each system), we show (vertical axis of Fig. 4 ) the average number of reported facts per text, divided by the average number of words of the texts in the group. Again, Fig. 4 shows that ilpnlg produces clearly more compact texts than pipeline and pipelineshort, with the difference between the latter two systems being very small. In all the experiments of this section, the ilp solver (used in ilpnlg) was very fast (average: 0.08 sec, worst: 0.14 sec per text).

We show below sample texts generated by pipeline and pipelineshort (both with $M = 4$ ) and ilpnlg (with $\lambda _1 = 0.3$ ).

pipeline: This Sauternes has strong flavor. It is made from Sauvignon Blanc and Semillon grapes and it is produced by Chateau D'ychem.

pipelineshort: This is a strong Sauternes. It is made from Sauvignon Blanc and Semillon grapes and it is produced by Chateau D'ychem.

ilpnlg: This is a strong Sauternes. It is made from Sauvignon Blanc and Semillon grapes by Chateau D'ychem. 

pipeline: This Riesling has sweet taste and it is full bodied. It is made by Schloss Volrad.

pipelineshort: This is a full sweet Riesling. It is produced by Schloss Volrad.

ilpnlg: This is a full sweet moderate Riesling. 

In the first group of generated texts above, pipeline and pipelineshort use different verbs for the grapes and producer, whereas ilpnlg uses the same verb, which leads to a more compressive aggregation; all the texts of the first group describe the same wine and report four facts each. In the second group of generated texts above, ilpnlg has chosen to report the (moderate) flavor of the wine instead of the producer, and uses the same verb (`is') for all the facts, leading to a shorter sentence; again all the texts of the second group describe the same wine and report four facts each. Recall that we treat all (non-redundant) facts as equally important in our experiments. In both groups of texts, some facts are not aggregated because they belong in different topical sections.

We also wanted to investigate the effect of the higher facts per word ratio of ilpnlg on the perceived quality of the generated texts, compared to the texts of the pipeline systems. We were concerned that the more compressive aggregations of ilpnlg might lead to sentences sounding less fluent or unnatural, though aggregation is often used to produce more fluent texts. We were also concerned that the more compact texts of ilpnlg might be perceived as being more difficult to understand (less clear) or less well-structured. To investigate these issues, we showed the $52 \times 2 = 104$ texts of pipelineshort ( $M=4$ ) and ilpnlg ( $\lambda _1 = 0.3$ ) to 6 computer science students (undergraduates and graduates), who were not involved in the work of this article; they were all fluent, though not native English speakers. We did not use pipeline in this experiment, since its facts per word ratio was similar to that of pipelineshort. Each one of the 104 texts was given to exactly one student. Each student was given approximately 9 randomly selected texts of each system. The owl statements that the texts were generated from were not shown, and the students did not know which system had generated each text. Each student was shown all of his/her texts in random order, regardless of the system that generated them. The students were asked to score each text by stating how strongly they agreed or disagreed with statements $S_1$ – $S_3$ below. A scale from 1 to 5 was used (1: strong disagreement, 3: ambivalent, 5: strong agreement).

( $S_1$ ) Sentence fluency: The sentences of the text are fluent, i.e., each sentence on its own is grammatical and sounds natural. When two or more smaller sentences are combined to form a single, longer sentence, the resulting longer sentence is also grammatical and sounds natural.

( $S_2$ ) Text structure: The order of the sentences is appropriate. The text presents information by moving reasonably from one topic to another.

( $S_3$ ) Clarity: The text is easy to understand, if the reader is familiar with basic wine terms. 

The students were also asked to provide an overall score (1–5) per text. We did not score referring expressions, since both systems use the same component for them. We note that although both systems use the same text planner, in pipelineshort (and all the pipeline variants) the text planner is invoked once, whereas in ilpnlg (and ilpnlgextend) it is invoked at different stages before and after using the ilp model (Section "The Systems of our Experiments" ), which is why we collected text structure scores too.

Table 1 shows the average scores of the two systems with 95% confidence intervals. For each criterion, the best score is shown in bold. The sentence fluency and overall scores of ilpnlg are slightly higher than those of pipelineshort, whereas pipelineshort obtained a slightly higher score for text structure and clarity. The differences, however, are very small, especially in clarity, and we detected no statistically significant difference between the two systems in any of the criteria. Hence, there was no evidence in these experiments that the higher facts per word ratio of ilpnlg comes at the expense of lower perceived text quality. We investigated these issues further in a second set of experiments, discussed in the next section, where the generated texts were longer.

## Experiments with the Consumer Electronics Ontology

In the second set of experiments, we used the Consumer Electronics Ontology, with the manually authored domain-dependent generation resources (e.g., text plans, nl names, sentence plans) of our previous work BIBREF10 . As in the previous section, we added more sentence plans to ensure that three sentence plans were available for almost every relation; for some relations we could not think of enough sentence plans. Again, a single nl name was available per individual and class.

We generated English texts with ilpnlg, pipeline, pipelineshort for the 30 development individuals (Section "The Ontologies of our Experiments" ), using $M = 3, 6, 9, \dots , 21$ in the two pipeline systems, and different values of $\lambda _1$ ( $\lambda _2 = 1 - \lambda _1$ ) in ilpnlg. All three systems were allowed to form aggregated sentences with up to $B_{max} = 39$ distinct elements; this was the number of distinct elements of the longest aggregated sentence in the experiments of our previous work BIBREF10 , where pipeline was allowed to combine up to three simple (expressing one fact each) sentences to form an aggregated one. There are 14 available facts ( $|F|$ ) on average and a maximum of 21 facts for each one of the 30 development individuals, compared to the 5 available facts on average and the maximum of 6 facts of the Wine Ontology. Hence, the texts of the Consumer Electronics Ontology are much longer, when they report all the available facts. In ilpnlg, we would have to set the maximum number of fact subsets to $m = 10$ , which was the maximum number of (aggregated) sentences in the texts of pipeline and pipelineshort. The number of variables of our ilp model, however, grows exponentially to $m$ and $|F|$ (Fig. 5 – 5 ), though the effect of $|F|$ is weaker.

Figure 5 shows the average time the ilp solver took for different values of $m$ in the experiments with the Consumer Electronics ontology; the results are averaged over the 30 development individuals and also for $\lambda _1 = 0.4, 0.5, 0.6$ . For $m=4$ , the solver took 1 minute and 47 seconds on average per text; recall that $|F|$ is also much larger now, compared to the experiments of the previous section. For $m=5$ , the solver was so slow that we aborted the experiment. Figure 5 shows the average solver times for different numbers of available facts $|F|$ , for $m = 3$ ; in this case, we modified the set of available facts ( $F$ ) of every individual to contain $3, 6, 9, 12, 15, 18, 21$ facts. The results are again averaged over the 30 development individuals and for $\lambda _1 = 0.4, 0.5, 0.6$ . Although the times of Fig. 5 also grow exponentially to $\lambda _1 = 0.4, 0.5, 0.6$0 , they remain under 4 seconds, showing that the main factor to the complexity of ilpnlg is $\lambda _1 = 0.4, 0.5, 0.6$1 , the number of fact subsets, i.e., the maximum allowed number of (aggregated) sentences of each text.

To efficiently generate texts with larger $m$ values, we developed ilpnlgapprox, the approximation of ilpnlg that considers each fact subset separately (Section "Computational Complexity and Approximations" ). Figures 6 – 6 show the average solver times of ilpnlgapprox for different values of $m$ and $|F|$ , respectively; all the other settings are as in Fig. 5 – 5 . The solver times now grow approximately linearly to $m$ and $|F|$ and are under 0.3 seconds in all cases.

In Figure 7 , we compare ilpnlg to ilpnlgapprox, by showing their average fact per word ratios, computed as in Fig. 3 (Section "Experiments with the Wine Ontology" ). We set $m = 3$ in ilpnlg to keep the solving times low; in ilpnlgapprox we experimented with both $m = 3$ (the value used in ilpnlg) and $m = 10$ (the value that was actually needed). In all cases, $B_{max} = 39$ . The facts per word ratios of all three systems are very similar. We conclude that ilpnlgapprox achieves very similar results to ilpnlg in much less time.

Figures 8 and 9 show the facts per word ratios of ilpnlgapprox ( $m = 10$ ), pipeline, and pipelineshort, computed in two ways, as in Section "Experiments with the Wine Ontology" , for the texts of the 30 development individuals. Again, pipelineshort achieves slightly better results than pipeline. The behavior of ilpnlgapprox in Figure 8 is very similar to the behavior of ilpnlg on the Wine Ontology (Fig. 3 ); for $\lambda _1 \le 0.3$ it produces empty texts, while for $\lambda _1 \ge 0.4$ it performs better than the other systems. ilpnlgapprox obtains the highest facts per word ratio for $\lambda _1 = 0.45$ , where it selects the facts and sentence plans that lead to the most compressive aggregations. For greater values of $\lambda _1$ , it selects additional facts whose sentence plans do not aggregate that well, which is why the ratio declines. The two pipeline systems select facts and sentence plans that offer very few aggregation opportunities; as the number of selected facts increases, some more aggregation opportunities arise, which is why the facts per word ratio of the two systems improves (more clearly in Fig. 9 ). Figure 9 also shows that ilpnlgapprox generates more compact texts than pipeline and pipelineshort.

We show below three example texts produced by pipeline, pipelineshort (both with $M = 6$ ), and ilpnlgapprox ( $\lambda _1 = 0.45$ , $m=10$ ). Each text reports six facts, but ilpnlgapprox has selected facts and sentence plans that allow more compressive aggregations. Recall that we treat all the facts as equally important. If importance scores are also available (e.g., if dimensions are less important), they can be added as multipliers $\mathit {imp}(f_i)$ of $\alpha _i$ in the objective function (Eq. 25 ) of the ilp model.

pipeline: SonySony DCR-TRV270 requires minimum illumination of 4.0 lux and its display is 2.5 in. It features a Sports scene mode, it includes a microphone and an IR remote control. Its weight is 780.0 grm.

pipelineshort: Sony DCR-TRV270 requires minimum illumination of 4.0 lux and its display is 2.5 in. It features a Sports scene mode, it includes a microphone and an IR remote control. It weighs 780.0 grm.

ilpnlgapprox: Sony DCR-TRV270 has a microphone and an IR remote control. It is 98.0 mm high, 85.0 mm wide, 151.0 mm deep and it weighs 780.0 grm. 

We showed the $30 \times 2 = 60$ texts of pipelineshort ( $M=6$ ) and ilpnlgapprox ( $\lambda _1 = 0.45$ , $m=10$ ) to the same six students that participated in the experiments with the Wine Ontology (Section "Experiments with the Wine Ontology" ). Again, each text was given to exactly one student. Each student was given approximately 5 randomly selected texts of each system. The owl statements were not shown, and the students did not know which system had generated each text. Each student was shown all of his/her texts in random order, regardless of the system that generated them. The students were asked to score each text by stating how strongly they agreed or disagreed with statements $S_1$ – $S_3$ , as in Section "Experiments with the Wine Ontology" . They were also asked to provide an overall score (1–5) per text.

Table 2 shows the average scores of the two systems with 95% confidence intervals. For each criterion, the best score is shown in bold; the confidence interval of the best score is also shown in bold, if it does not overlap with the confidence interval of the other system. Unlike the Wine Ontology experiments (Table 1 ), the scores of our ilp approach (with the approximation of ilpnlgapprox) are now higher than those of pipelineshort in all of the criteria, and the differences are also larger, though we found the differences to be statistically significant only for clarity and overall quality. We attribute these larger differences, compared to the Wine Ontology experiments, to the fact that the texts are now longer and the sentence plans more varied, which often makes the texts of pipelineshort sound verbose and, hence, more difficult to follow, compared to the more compact texts of ilpnlgapprox, which sound more concise.

Overall, the human scores of the experiments with the Wine and Consumer Electronics ontologies suggest that the higher facts per word ratios of our ilp approach do not come at the expense of lower perceived text quality. On the contrary, the texts of the ilp approach may be perceived as clearer and overall better than those of the pipeline, when the texts report many facts.

## Experiments with the Disease Ontology

In a third set of experiments, we generated texts for the 200 `development' classes (Section "The Ontologies of our Experiments" ) of the Disease Ontology, using the manually authored domain-dependent generation resources (e.g., text plans, nl names, sentence plans) of Evaggelakaki Evaggelakaki2014, but with additional sentence plans we constructed to ensure that there were three alternative sentence plans per relation. We generated texts with ilpnlg, pipeline, and pipelineshort, for $M = 2, 3, 4, \dots , 7$ in the two pipeline systems, and different values of $\lambda _1$ ( $\lambda _2 = 1 - \lambda _1$ ) in ilpnlg. All three systems were allowed to form aggregated sentences with up to $B_{max} = 30$ distinct elements; this was the number of distinct elements of the longest aggregated sentence in the experiments of Evaggelakaki Evaggelakaki2014, where pipeline was allowed to combine up to three simple (expressing one fact each) sentences to form an aggregated one. There are 3.7 available facts ( $|F|$ ) on average and a maximum of 7 facts for each one of the 200 classes. In ilpnlg, we set $m = 4$ , which was the maximum number of (aggregated) sentences in the texts of pipeline and pipelineshort. We did not use ilpnlgapprox, since ilpnlg was reasonably fast (average solver time: 0.11 sec per text, worst: 0.90 sec per text), because of the smaller values of $m$ and $|F|$ , compared to the experiments of the Consumer Electronics ontology.

Figures 10 and 11 show the facts per word ratios of ilpnlg, pipeline, and pipelineshort, computed in two ways, as in Section "Experiments with the Wine Ontology" , for the texts of the 200 classes. pipelineshort achieves only slightly better results than pipeline in both figures. Also, Fig. 11 shows that ilpnlg produces more compact texts than the two pipeline systems. In Figure 10 , however, the difference between ilpnlg and the two pipeline systems is less clear. For small $\lambda _1$ values, ilpnlg produces empty texts, because it focuses on minimizing the number of distinct elements of each text. For $\lambda _1 \ge 0.125$ , it performs only marginally better than pipelineshort, unlike previous experiments (cf. Fig. 3 and 8 ). We attribute this difference to the fact that ilpnlg does not take into account the lengths of the nl names, which vary a lot in the Disease Ontology; nor does it take into account that the $O$ of many facts $\left<S,R,O\right>$ is a conjunction. These issues were addressed in our extended ilp model (Section "Our Extended ILP Model" ), which is used in ilpnlgextend.

We then generated texts for the 200 classes again, this time with pipeline, pipelineshort* (both with $M = 2, 3, \dots , 7$ , $W_{max} = 54$ ) and ilpnlgextend ( $m$ = 4, $W_{max} = 54$ ); we modified pipeline and pipelineshort to count words (instead of elements) when comparing against ilpnlgextend, which is why we report $W_{max}$ in all three systems. Similarly to how $B_{max}$ was previously selected, $W_{max}=54$ was the number of words of the longest aggregated sentence in the experiments of Evaggelakaki Evaggelakaki2014. Figures 12 and 13 show the new facts per word ratios, for the texts of the 200 classes. In Figure 12 , for $\lambda _1 \le 0.06$ , ilpnlgextend produces empty texts, because it focuses on minimizing the lengths of the texts. For $\lambda _1 \ge 0.12$ , ilpnlgextend now performs clearly better than the pipeline systems, obtaining the highest facts per word ratio for $\lambda _1 = 0.14$ ; notice that we now compare to pipelineshort*, which is a better baseline for ilpnlgextend than pipelineshort (Section "The Systems of our Experiments" ). Figure 13 also confirms that ilpnlgextend outperforms the pipeline systems. The ilp solver was actually slightly faster with ilpnlgextend (average: 0.09 sec, worst: 0.65 sec per text) compared to ilpnlg (average: 0.11 sec, worst: 0.90 sec per text).

We show below three example texts produced by pipeline, pipelineshort* (both with $M = 3$ ), and ilpnlgextend ( $\lambda _1 = 0.14$ ). Each text reports three facts, but ilpnlgextend has selected facts with fewer and shorter nl names, and sentence plans that lead to better sentence aggregation. Recall that we treat all facts as equally important in these experiments, but that our ilp models can also handle importance scores (e.g., treating facts reporting symptoms as more important than facts about is-a relations).

pipeline: Nephropathia epidemica can be found in the kidneys. It can often cause myalgia, nausea, renal failure, vomiting, abdominal pain, headaches, internal hemorrhage and back pain, and it results in infections.

pipelineshort*: Nephropathia epidemica is a kind of hemorrhagic fever with renal syndrome. It originates from bank voles and it is caused by the puumala virus.

ilpnlgextend: Nephropathia epidemica results in infections. It often originates from bank voles from the puumala virus. 

## Further Experiments with the Wine Ontology

The experiments of the previous section tested the ability of ilpnlgextend to take into account the different lengths of nl names and the fact that some facts $\left<S,R,O\right>$ involve conjunctions (or disjunctions) in their $O$ . They did not, however, test the ability of ilpnlgextend to cope with multiple alternative nl names per individual or class. The Consumer Electronics and Disease Ontologies were inappropriate in this respect, because the names of electronic products tend to be unique and we did not have the expertise to create alternative names of diseases, as already noted. Instead, we returned to the Wine Ontology, which had been used in Section "Experiments with the Wine Ontology" with a single nl name per individual and class. We now added more nl names to the Wine Ontology to ensure that approximately three nl names on average (with a minimum of 2 and a maximum of 5) were available for each one of the individual and classes we generated texts for. We generated texts for the 52 wine individuals and 24 of the wine classes of the Wine Ontology, using pipeline, pipelineshort*, and ilpnlgextend.

All three systems were allowed to form aggregated sentences with up to $W_{max} = 26$ words; again, we modified pipeline and pipelineshort to count words (instead of elements) when comparing against ilpnlgextend, which is why we report $W_{max}$ for all three systems. Similarly to Section "Experiments with the Disease Ontology" , $W_{max}$ was set to the number of words of the longest aggregated sentence in the experiments of our previous work BIBREF10 , where pipeline was allowed to combine up to three simple (expressing one fact each) sentences to form an aggregated one. In ilpnlgextend, we used different values for $\lambda _1$ ( $\lambda _2 = 1 - \lambda _1$ ), setting $m = 3$ , as in Section "Experiments with the Wine Ontology" . In pipeline and pipelineshort*, we used $M = 2, 3, \dots , 7$ . For each $M$ value, the texts of pipeline for the 76 individuals and classes were generated 10 times (not 3, unlike all the previous experiments with pipeline); each time, we used one of the different alternative sentence plans for each relation and one of the different alternative nl names for the individual or class the text was being generated for, since pipeline cannot select among alternative nl names (and sentence plans) by itself.

Figures 14 and 15 show the facts per word ratios, computed in two ways, as in Section "Experiments with the Wine Ontology" . In Fig. 14 , for $\lambda _1 < 0.04$ , ilpnlgextend produces empty texts, because it focuses on minimizing the length of each text. For $\lambda _1 \ge 0.08$ , it performs clearly better than the other systems. For $\lambda _1 = 0.12$ , it obtains the highest facts per word ratio by selecting the facts and sentence plans that lead to the shortest (in words) aggregated sentences, and nl names that indirectly express facts (not requiring separate sentences). For greater values of $\lambda _1$ , ilpnlgextend selects additional facts whose sentence plans do not aggregate that well or that cannot be indirectly expressed via nl names, which is why the ratio of ilpnlgextend declines. We note that the highest average facts per word ratio of ilpnlgapprox (0.37, for $\lambda _1 = 0.12$ ) of Fig. 14 is higher than the highest average ratio (0.33, for $\lambda _1 = 0.3$ ) we had obtained in Section "Experiments with the Wine Ontology" with ilpnlg (Fig. 3 ). Also, the overall values of $\lambda _1$ are now smaller. This is due to the larger number of factors in the right part of the objective function (Eq. 33 ) of ilpnlgextend. Figure 15 confirms that ilpnlgextend outperforms the pipelines. In the experiments of this section with ilpnlgextend, the ilp solver was very fast (average: 0.06 sec, worst: 0.64 sec per text).

We show below texts produced by pipeline, pipelineshort* (both with $M = 4$ ), and ilpnlgextend ( $\lambda _1 = 0.12$ ). All texts describe the same wine and report four facts.

pipeline: This Sauvignon Blanc is dry and medium. It is made by Stonleigh and it is produced in New Zealand.

pipelineshort*: This delicate tasting and dry Sauvignon Blanc wine originates from New

Zealand.

ilpnlgextend: This Stonleigh Sauvignon Blanc is dry, delicate and medium. 

ilpnlgextend chose an nl name that avoids expressing the maker as a separate sentence, and used the same verb (“is”) to express the other three facts, allowing a single aggregated sentence to be formed. It also avoided expressing the origin (New Zealand), which would require a long sentence that would not aggregate well with the others.

## Related Work

Marciniak and Strube Marciniak2005b proposed an ilp approach to language processing problems where the decisions of classifiers that consider different, but co-dependent, subtasks need to be combined. They applied their approach to the generation of multi-sentence route directions, by training classifiers (whose decisions affect the generated text) on a parallel corpus consisting of semantic representations and route directions. The classifiers control the ordering and lexicalization of phrases and a simple form of aggregation (mainly the choice of connectives between the phrases). Marciniak and Strube aimed to generate fluent and grammatically correct texts; by contrast, our ilp models employ manually authored linguistic resources that guarantee fluent and grammatical texts (as also confirmed by our experiments), and make no decisions directly affecting fluency or grammaticality. Instead, our models make decisions related to content selection, lexicalization, aggregation (using more complex rules than Marciniak and Strube), and a limited form of referring expression generation (in the case of our extended model), aiming to produce more compact texts, without invoking classifiers.

Barzilay and Lapata Barzilay2005 treated content selection as an optimization problem. Given a pool of facts (database entries) and scores indicating the importance of including or excluding each fact or pair of facts, their method selects the facts to express by solving an optimization problem similar to energy minimization. A solution is found by applying a minimal cut partition algorithm to a graph representing the pool of facts and the importance scores. The importance scores of single facts are obtained via supervised machine learning (AdaBoost) from a dataset of (sports) facts and news articles expressing them. The importance scores of pairs of facts depend on parameters tuned on the same dataset using Simulated Annealing. Our ilp models are simpler, in that they allow importance scores to be associated only with single facts, not pairs of facts. On the other hand, our models jointly perform content selection, lexicalization, aggregation, and (limited) referring expression generation, not just content selection.

In other work, Barzilay and Lapata Barzilay2006 consider sentence aggregation. Given a set of facts (again database entries) that a content selection stage has produced, aggregation is viewed as the problem of partitioning the facts into optimal subsets (similar to the buckets of our ilp models). Sentences expressing facts of the same subset are aggregated to form a longer sentence. The optimal partitioning maximizes the pairwise similarity of the facts in each subset, subject to constraints that limit the number of subsets and the number of facts in each subset. A Maximum Entropy classifier predicts the semantic similarity of each pair of facts, and an ilp model is used to find the optimal partitioning. By contrast, our ilp models aggregate sentences by minimizing the distinct elements of each subset, to maximize the aggregation opportunities in each subset, taking care not to aggregate together sentences expressing facts from different topics; an external text planner partitions the available facts into topical sections. Again, our models have broader scope, in the sense that they (jointly) perform content selection, lexicalization, aggregation, and (limited) referring expression generation, not just aggregation.

Althaus et al. Althaus2004 show that the ordering of a set of sentences to maximize local (sentence-to-sentence) coherence is equivalent to the traveling salesman problem and, hence, np-complete. They also provide an ilp formulation of the problem, which can be solved efficiently in practice using branch-and-cut with cutting planes. Our models do not order the sentences (or facts) of the generated texts, relying on an external text planner instead. It would be particularly interesting to add sentence (or fact) ordering to our models, along the lines of Althaus et al. in future work.

Kuznetsova et al. Kuznetsova2012 use ilp to generate image captions. They train classifiers to detect the objects in each image. Having identified the objects of a given image, they retrieve phrases from the captions of a corpus of images, focusing on the captions of objects that are similar (color, texture, shape) to the ones in the given image. To select which objects of the image to report (a kind of content selection) and in what order, Kuznetsova et al. maximize (via ilp) the mean of the confidence scores of the object detection classifiers and the sum of the co-occurrence probabilities of the objects that will be reported in adjacent positions in the caption. The co-occurrence probabilities are estimated from a corpus of captions. Having decided which objects to report and their order, a second ilp model decides which phrases to use for each object (a kind of lexicalization) and orders the phrases. The second ilp model maximizes the confidence of the phrase retrieval algorithm and the local cohesion between subsequent phrases. Although generating image captions is very different to generating texts from ontologies, it may be possible to use ideas from the work of Kuznetsova et al. related to ordering objects (in our case, facts) and phrases in future extensions of our models.

Joint optimization ilp models have also been used in multi-document text summarization and sentence compression BIBREF41 , BIBREF42 , BIBREF43 , BIBREF44 , BIBREF45 , where the input is text, not formal knowledge representations. Statistical methods to jointly perform content selection, lexicalization, and surface realization have also been proposed in nlg BIBREF46 , BIBREF47 , BIBREF48 , but they are currently limited to generating single sentences from flat records, as opposed to generating multi-sentence texts from ontologies.

To the best of our knowldge, our work is the first to consider content selection, lexicalization, sentence aggregation, and a limited form of referring expression generation as an ilp joint optimization problem in multi-sentence concept-to-text generation. An earlier form of our work has already been published BIBREF49 , BIBREF50 , but without the extended version of our ilp model (Section "Our Extended ILP Model" ), without the experiments on the Disease Ontology (Section "Experiments with the Disease Ontology" ), without the further experiments on the Wine Ontology (Section "Further Experiments with the Wine Ontology" ), with facts per word ratios grouped only by $M$ and $\lambda _1$ values (without the results of Fig. 4 , 9 , 13 , 15 ), and with much fewer details.

## Conclusions and Future Work

We presented an ilp model that jointly considers decisions in content selection, lexicalization, and sentence aggregation to avoid greedy local decisions and produce more compact texts. An extended version of the ilp model predicts more accurately the lengths of the generated texts and also performs a limited form of referring expression generation, by considering alternative nl names and how they can indirectly express facts. We also defined an approximation of our models that generates separately each (possibly aggregated) sentence of the final text and is more efficient when longer texts are generated. The ilp models (and approximations) of this article were embedded in Naturalowl, a state of the art publicly available nlg system for owl ontologies that used a pipeline architecture in its original form. Experiments with three ontologies confirmed that our models can express more facts per word, with no deterioration in the perceived quality of the generated texts or with improved perceived quality, compared to texts generated by a pipeline architecture. Our experiments also showed that our ilp methods (or their approximations) are efficient enough to be used in practice.

The work of this article is the first to consider content selection, lexicalization, sentence aggregation, and a limited form of referring expression generation as an ilp joint optimization problem in multi-sentence concept-to-text generation. Previous work in nlg employed a pipeline architecture, considered fewer and different processing stages, was concerned with generating single sentences, or had very different inputs and goals. Our work could be extended to consider additional generation stages (e.g., text planning, or more referring expression generation decisions). It would also be interesting to combine the ilp models with other user modeling components that would assign interest scores to message triples. Another valuable direction would be to combine ilp models for concept-to-text generation and multi-document summarization, to produce texts summarizing both structured and unstructured information. 
