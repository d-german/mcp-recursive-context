{
  "tasks": [
    {
      "id": "40dc5d60-03cc-4dd4-b8ae-227ea0547a03",
      "name": "Create AdvancedAnalysisModels.cs with immutable records",
      "description": "**WHAT**: Create a new file \u0060src/RecursiveContext.Mcp.Server/Models/AdvancedAnalysisModels.cs\u0060 containing all the immutable record types needed for the 5 new analysis tools:\n\n1. \u0060CompoundMatchResult\u0060 - Result for compound pattern matching with count, matched lines, and samples\n2. \u0060ConsecutiveRun\u0060 - Represents a run of consecutive matching lines (startLine, length, sampleLines)\n3. \u0060ConsecutiveRunResult\u0060 - Result containing longest run and all runs list\n4. \u0060AggregateGroup\u0060 - Group with key, count, and optional sample match\n5. \u0060PatternAggregateResult\u0060 - Result with groups list, total count, pattern used\n6. \u0060DistributedSample\u0060 - Sample with line number, position percentage, and match text\n7. \u0060DistributedSampleResult\u0060 - Result with samples list and distribution info\n8. \u0060FileComparisonEntry\u0060 - Entry for a single file with path, count, and optional ratio\n9. \u0060CrossFileComparisonResult\u0060 - Result with file entries and comparison summary\n\n**WHY**: Following the project\u0027s immutable record pattern (see Models.cs), these DTOs provide type-safe, immutable return types for all 5 tools. Centralizing models in a dedicated file maintains separation of concerns and makes it easy to share types across the service and tool layers.\n\n\uD83D\uDCCB CODE QUALITY CHECKLIST:\n\u25A1 Single Responsibility: Does this class/method do one thing?\n\u25A1 Open/Closed: Is this open for extension, closed for modification?\n\u25A1 Liskov Substitution: Are derived classes substitutable for base classes?\n\u25A1 Interface Segregation: Are interfaces specific rather than general-purpose?\n\u25A1 Dependency Inversion: Are dependencies injected, not created?\n\u25A1 Cyclomatic Complexity: Is complexity around 5 or less?\n\u25A1 Pure Functions: Are there unnecessary side effects?\n\u25A1 Immutability: Can data structures be immutable?\n\u25A1 Static Methods: Should any methods be static (no instance state)?\n\u25A1 Railway-Oriented: Use Result\u003CT\u003E with Bind/Map/Tap instead of try-catch where appropriate",
      "status": "Completed",
      "dependencies": [],
      "createdAt": "2026-01-18T20:09:37.9611929-06:00",
      "updatedAt": "2026-01-18T20:10:36.1862321-06:00",
      "completedAt": "2026-01-18T20:10:36.1862321-06:00",
      "summary": "Created AdvancedAnalysisModels.cs with 10 immutable record types: CompoundMatchResult, CompoundMatchSample, ConsecutiveRun, ConsecutiveRunResult, AggregateGroup, PatternAggregateResult, DistributedSample, DistributedSampleResult, FileComparisonEntry, CrossFileComparisonResult. All records use init-only properties via positional parameters, use ImmutableArray\u003CT\u003E for collections, and have XML documentation. Build succeeded with 0 errors and 0 warnings.",
      "relatedFiles": [
        {
          "path": "src/RecursiveContext.Mcp.Server/Models/Models.cs",
          "type": "REFERENCE",
          "description": "Reference for existing model patterns"
        },
        {
          "path": "src/RecursiveContext.Mcp.Server/Models/AdvancedAnalysisModels.cs",
          "type": "TO_MODIFY",
          "description": "New file to create"
        }
      ],
      "analysisResult": "Creating 5 new advanced analysis tools for the RecursiveContext.Mcp.Server project as proposed in the Serena memory. These tools will enable complex pattern matching, aggregation, consecutive run detection, distributed sampling, and cross-file comparison - eliminating the need for AI to fall back to Python/PowerShell for complex analysis queries. Following the existing project patterns: IAdvancedAnalysisService interface, AdvancedAnalysisService implementation with DI registration, immutable models, MCP tool classes with Description attributes, and xUnit tests.",
      "verificationCriteria": "- File compiles without errors\n- All records use init-only properties\n- ImmutableArray\u003CT\u003E used for collections\n- XML documentation on all public types\n- No mutable state"
    },
    {
      "id": "b65c9f3b-7357-4f7e-bb6f-78d215bdc2c9",
      "name": "Create IAdvancedAnalysisService interface",
      "description": "**WHAT**: Add a new interface \u0060IAdvancedAnalysisService\u0060 to \u0060src/RecursiveContext.Mcp.Server/Services/Interfaces.cs\u0060 with 5 method signatures:\n\n1. \u0060CountCompoundPatternAsync(string path, string[] patterns, string matchMode, bool includeSamples, int maxSamples, CancellationToken ct)\u0060 - Returns \u0060Result\u003CCompoundMatchResult\u003E\u0060\n2. \u0060FindConsecutiveRunsAsync(string path, string pattern, int minRunLength, bool returnLongestOnly, int maxRuns, CancellationToken ct)\u0060 - Returns \u0060Result\u003CConsecutiveRunResult\u003E\u0060\n3. \u0060AggregatePatternMatchesAsync(string path, string pattern, string groupBy, int topN, bool includeSamples, CancellationToken ct)\u0060 - Returns \u0060Result\u003CPatternAggregateResult\u003E\u0060\n4. \u0060SampleMatchesDistributedAsync(string path, string pattern, int sampleCount, string distribution, CancellationToken ct)\u0060 - Returns \u0060Result\u003CDistributedSampleResult\u003E\u0060\n5. \u0060ComparePatternAcrossFilesAsync(string[] paths, string pattern, bool computeRatio, CancellationToken ct)\u0060 - Returns \u0060Result\u003CCrossFileComparisonResult\u003E\u0060\n\n**WHY**: The interface defines the contract for advanced analysis operations, following the project\u0027s Dependency Inversion principle. All 5 tools will depend on this abstraction rather than the concrete implementation, enabling testability through mocking and future extensibility.\n\n\uD83D\uDCCB CODE QUALITY CHECKLIST:\n\u25A1 Single Responsibility: Does this class/method do one thing?\n\u25A1 Open/Closed: Is this open for extension, closed for modification?\n\u25A1 Liskov Substitution: Are derived classes substitutable for base classes?\n\u25A1 Interface Segregation: Are interfaces specific rather than general-purpose?\n\u25A1 Dependency Inversion: Are dependencies injected, not created?\n\u25A1 Cyclomatic Complexity: Is complexity around 5 or less?\n\u25A1 Pure Functions: Are there unnecessary side effects?\n\u25A1 Immutability: Can data structures be immutable?\n\u25A1 Static Methods: Should any methods be static (no instance state)?\n\u25A1 Railway-Oriented: Use Result\u003CT\u003E with Bind/Map/Tap instead of try-catch where appropriate",
      "status": "Completed",
      "dependencies": [
        {
          "taskId": "40dc5d60-03cc-4dd4-b8ae-227ea0547a03"
        }
      ],
      "createdAt": "2026-01-18T20:09:37.9762443-06:00",
      "updatedAt": "2026-01-18T20:11:07.8079001-06:00",
      "completedAt": "2026-01-18T20:11:07.8079001-06:00",
      "summary": "Added IAdvancedAnalysisService interface to Interfaces.cs with 5 methods: CountCompoundPatternAsync, FindConsecutiveRunsAsync, AggregatePatternMatchesAsync, SampleMatchesDistributedAsync, ComparePatternAcrossFilesAsync. All methods return Task\u003CResult\u003CT\u003E\u003E for railway-oriented programming, accept CancellationToken, and have full XML documentation. Build succeeded with 0 errors and 0 warnings.",
      "relatedFiles": [
        {
          "path": "src/RecursiveContext.Mcp.Server/Services/Interfaces.cs",
          "type": "TO_MODIFY",
          "description": "Add new interface"
        },
        {
          "path": "src/RecursiveContext.Mcp.Server/Models/AdvancedAnalysisModels.cs",
          "type": "REFERENCE",
          "description": "Return types for methods"
        }
      ],
      "analysisResult": "Creating 5 new advanced analysis tools for the RecursiveContext.Mcp.Server project as proposed in the Serena memory. These tools will enable complex pattern matching, aggregation, consecutive run detection, distributed sampling, and cross-file comparison - eliminating the need for AI to fall back to Python/PowerShell for complex analysis queries. Following the existing project patterns: IAdvancedAnalysisService interface, AdvancedAnalysisService implementation with DI registration, immutable models, MCP tool classes with Description attributes, and xUnit tests.",
      "verificationCriteria": "- Interface compiles without errors\n- All methods return Task\u003CResult\u003CT\u003E\u003E for railway-oriented programming\n- All methods accept CancellationToken\n- XML documentation on interface and all methods\n- Parameters follow existing naming conventions"
    },
    {
      "id": "f4aa28c7-3cd0-41af-8e09-d55496f9edd2",
      "name": "Create AdvancedAnalysisService implementation",
      "description": "**WHAT**: Create a new file \u0060src/RecursiveContext.Mcp.Server/Services/AdvancedAnalysisService.cs\u0060 implementing \u0060IAdvancedAnalysisService\u0060 with all 5 methods:\n\n1. **CountCompoundPatternAsync**: Match lines against multiple patterns with modes \u0022all\u0022 (AND), \u0022any\u0022 (OR), \u0022sequence\u0022 (patterns appear in order on line)\n2. **FindConsecutiveRunsAsync**: Scan file line-by-line, track consecutive matching lines, return runs of at least minRunLength\n3. **AggregatePatternMatchesAsync**: Group matches by regex capture group or first word, count each group, return top N\n4. **SampleMatchesDistributedAsync**: Get samples distributed across file using \u0022even\u0022, \u0022random\u0022, \u0022first\u0022, or \u0022last\u0022 strategies\n5. **ComparePatternAcrossFilesAsync**: Count pattern in each file, optionally compute relative ratios\n\n**WHY**: This service encapsulates the complex analysis logic, following Single Responsibility by focusing only on advanced pattern analysis. Injecting PathResolver and IGuardrailService follows existing patterns (see ContentAnalysisService). Using Result\u003CT\u003E monad enables clean error handling without exceptions.\n\n\uD83D\uDCCB CODE QUALITY CHECKLIST:\n\u25A1 Single Responsibility: Does this class/method do one thing?\n\u25A1 Open/Closed: Is this open for extension, closed for modification?\n\u25A1 Liskov Substitution: Are derived classes substitutable for base classes?\n\u25A1 Interface Segregation: Are interfaces specific rather than general-purpose?\n\u25A1 Dependency Inversion: Are dependencies injected, not created?\n\u25A1 Cyclomatic Complexity: Is complexity around 5 or less?\n\u25A1 Pure Functions: Are there unnecessary side effects?\n\u25A1 Immutability: Can data structures be immutable?\n\u25A1 Static Methods: Should any methods be static (no instance state)?\n\u25A1 Railway-Oriented: Use Result\u003CT\u003E with Bind/Map/Tap instead of try-catch where appropriate",
      "status": "Completed",
      "dependencies": [
        {
          "taskId": "b65c9f3b-7357-4f7e-bb6f-78d215bdc2c9"
        }
      ],
      "createdAt": "2026-01-18T20:09:37.9907708-06:00",
      "updatedAt": "2026-01-18T20:12:09.7380149-06:00",
      "completedAt": "2026-01-18T20:12:09.7380149-06:00",
      "summary": "Created AdvancedAnalysisService.cs implementing IAdvancedAnalysisService with all 5 methods: CountCompoundPatternAsync (AND/OR/SEQUENCE modes), FindConsecutiveRunsAsync (finds runs of matching lines), AggregatePatternMatchesAsync (groups matches by key), SampleMatchesDistributedAsync (even/random/first/last distribution), ComparePatternAcrossFilesAsync (cross-file comparison with ratios). Uses Result\u003CT\u003E monad consistently, ConfigureAwait(false) on all awaits, injects PathResolver and IGuardrailService, static helper methods for pure functions. Build succeeded with 0 errors and 0 warnings.",
      "relatedFiles": [
        {
          "path": "src/RecursiveContext.Mcp.Server/Services/AdvancedAnalysisService.cs",
          "type": "TO_MODIFY",
          "description": "New file to create"
        },
        {
          "path": "src/RecursiveContext.Mcp.Server/Services/ContentAnalysisService.cs",
          "type": "REFERENCE",
          "description": "Pattern for service implementation"
        },
        {
          "path": "src/RecursiveContext.Mcp.Server/Services/Interfaces.cs",
          "type": "REFERENCE",
          "description": "Interface to implement"
        }
      ],
      "analysisResult": "Creating 5 new advanced analysis tools for the RecursiveContext.Mcp.Server project as proposed in the Serena memory. These tools will enable complex pattern matching, aggregation, consecutive run detection, distributed sampling, and cross-file comparison - eliminating the need for AI to fall back to Python/PowerShell for complex analysis queries. Following the existing project patterns: IAdvancedAnalysisService interface, AdvancedAnalysisService implementation with DI registration, immutable models, MCP tool classes with Description attributes, and xUnit tests.",
      "verificationCriteria": "- File compiles without errors\n- All 5 interface methods implemented\n- Uses Result\u003CT\u003E monad consistently\n- Uses ConfigureAwait(false) on all awaits\n- Injects PathResolver and IGuardrailService\n- Static helper methods for pure functions\n- Cyclomatic complexity ~5 or less per method"
    },
    {
      "id": "05aca5ef-c7cd-4af9-b83a-9d6c04680877",
      "name": "Register AdvancedAnalysisService in DI container",
      "description": "**WHAT**: Modify \u0060src/RecursiveContext.Mcp.Server/Server/ServerServices.cs\u0060 to register \u0060IAdvancedAnalysisService\u0060 with \u0060AdvancedAnalysisService\u0060 implementation:\n\n\u0060\u0060\u0060csharp\nservices.AddSingleton\u003CIAdvancedAnalysisService, AdvancedAnalysisService\u003E();\n\u0060\u0060\u0060\n\nAdd this in the \u0022Analysis services\u0022 section alongside the existing ContentAnalysisService registration.\n\n**WHY**: Without DI registration, the MCP tools cannot receive the service through constructor injection. Following the existing singleton pattern ensures one instance handles all requests, which is appropriate since the service is stateless and thread-safe.\n\n\uD83D\uDCCB CODE QUALITY CHECKLIST:\n\u25A1 Single Responsibility: Does this class/method do one thing?\n\u25A1 Open/Closed: Is this open for extension, closed for modification?\n\u25A1 Liskov Substitution: Are derived classes substitutable for base classes?\n\u25A1 Interface Segregation: Are interfaces specific rather than general-purpose?\n\u25A1 Dependency Inversion: Are dependencies injected, not created?\n\u25A1 Cyclomatic Complexity: Is complexity around 5 or less?\n\u25A1 Pure Functions: Are there unnecessary side effects?\n\u25A1 Immutability: Can data structures be immutable?\n\u25A1 Static Methods: Should any methods be static (no instance state)?\n\u25A1 Railway-Oriented: Use Result\u003CT\u003E with Bind/Map/Tap instead of try-catch where appropriate",
      "status": "Completed",
      "dependencies": [
        {
          "taskId": "f4aa28c7-3cd0-41af-8e09-d55496f9edd2"
        }
      ],
      "createdAt": "2026-01-18T20:09:38.0065697-06:00",
      "updatedAt": "2026-01-18T20:12:50.5791426-06:00",
      "completedAt": "2026-01-18T20:12:50.5791426-06:00",
      "summary": "Added DI registration for IAdvancedAnalysisService in ServerServices.cs alongside other analysis services. The line \u0027services.AddSingleton\u003CIAdvancedAnalysisService, AdvancedAnalysisService\u003E();\u0027 was added in the Analysis services section. Build succeeded with 0 errors and 0 warnings.",
      "relatedFiles": [
        {
          "path": "src/RecursiveContext.Mcp.Server/Server/ServerServices.cs",
          "type": "TO_MODIFY",
          "description": "Add DI registration"
        }
      ],
      "analysisResult": "Creating 5 new advanced analysis tools for the RecursiveContext.Mcp.Server project as proposed in the Serena memory. These tools will enable complex pattern matching, aggregation, consecutive run detection, distributed sampling, and cross-file comparison - eliminating the need for AI to fall back to Python/PowerShell for complex analysis queries. Following the existing project patterns: IAdvancedAnalysisService interface, AdvancedAnalysisService implementation with DI registration, immutable models, MCP tool classes with Description attributes, and xUnit tests.",
      "verificationCriteria": "- Registration added in correct section\n- Uses AddSingleton pattern\n- Project compiles without errors"
    },
    {
      "id": "1dc2d1eb-e0ec-4e01-91b9-a02f2c573c07",
      "name": "Create CountCompoundPatternTool",
      "description": "**WHAT**: Create a new file \u0060src/RecursiveContext.Mcp.Server/Tools/Analysis/CountCompoundPatternTool.cs\u0060 exposing the \u0060count_compound_pattern\u0060 MCP tool:\n\n- Tool name: \u0060count_compound_pattern\u0060\n- Description: \u0022Count lines matching multiple regex patterns. Supports AND (all patterns match), OR (any pattern matches), or SEQUENCE (patterns appear in order) modes.\u0022\n- Parameters: path, patterns (string array), matchMode (\u0022all\u0022|\u0022any\u0022|\u0022sequence\u0022), includeSamples (default: false), maxSamples (default: 5)\n\n**WHY**: This tool enables complex queries like \u0022lines where character speaks a question\u0022 without Python fallback. The matchMode parameter provides flexibility for different use cases while keeping a single tool interface.\n\n\uD83D\uDCCB CODE QUALITY CHECKLIST:\n\u25A1 Single Responsibility: Does this class/method do one thing?\n\u25A1 Open/Closed: Is this open for extension, closed for modification?\n\u25A1 Liskov Substitution: Are derived classes substitutable for base classes?\n\u25A1 Interface Segregation: Are interfaces specific rather than general-purpose?\n\u25A1 Dependency Inversion: Are dependencies injected, not created?\n\u25A1 Cyclomatic Complexity: Is complexity around 5 or less?\n\u25A1 Pure Functions: Are there unnecessary side effects?\n\u25A1 Immutability: Can data structures be immutable?\n\u25A1 Static Methods: Should any methods be static (no instance state)?\n\u25A1 Railway-Oriented: Use Result\u003CT\u003E with Bind/Map/Tap instead of try-catch where appropriate",
      "status": "Completed",
      "dependencies": [
        {
          "taskId": "05aca5ef-c7cd-4af9-b83a-9d6c04680877"
        }
      ],
      "createdAt": "2026-01-18T20:09:38.0206998-06:00",
      "updatedAt": "2026-01-18T20:13:11.8754996-06:00",
      "completedAt": "2026-01-18T20:13:11.8754996-06:00",
      "summary": "Created CountCompoundPatternTool.cs with [McpServerToolType] and [McpServerTool] attributes. Tool name: count_compound_pattern. Static class with static method, [Description] on class, method, and all 6 parameters (path, patterns, matchMode, includeSamples, maxSamples, ct). Uses ToolResponseFormatter.FormatResult. Build succeeded with 0 errors and 0 warnings.",
      "relatedFiles": [
        {
          "path": "src/RecursiveContext.Mcp.Server/Tools/Analysis/CountCompoundPatternTool.cs",
          "type": "TO_MODIFY",
          "description": "New tool file to create"
        },
        {
          "path": "src/RecursiveContext.Mcp.Server/Tools/Analysis/CountPatternMatchesTool.cs",
          "type": "REFERENCE",
          "description": "Pattern for tool structure"
        }
      ],
      "analysisResult": "Creating 5 new advanced analysis tools for the RecursiveContext.Mcp.Server project as proposed in the Serena memory. These tools will enable complex pattern matching, aggregation, consecutive run detection, distributed sampling, and cross-file comparison - eliminating the need for AI to fall back to Python/PowerShell for complex analysis queries. Following the existing project patterns: IAdvancedAnalysisService interface, AdvancedAnalysisService implementation with DI registration, immutable models, MCP tool classes with Description attributes, and xUnit tests.",
      "verificationCriteria": "- File compiles without errors\n- [McpServerToolType] and [McpServerTool] attributes present\n- [Description] attributes on class, method, and all parameters\n- Static class with static method\n- Returns string via ToolResponseFormatter.FormatResult"
    },
    {
      "id": "f631b3d1-740b-4d5d-a504-117d8c363fde",
      "name": "Create FindConsecutiveRunsTool",
      "description": "**WHAT**: Create a new file \u0060src/RecursiveContext.Mcp.Server/Tools/Analysis/FindConsecutiveRunsTool.cs\u0060 exposing the \u0060find_consecutive_runs\u0060 MCP tool:\n\n- Tool name: \u0060find_consecutive_runs\u0060\n- Description: \u0022Find runs of consecutive lines matching a regex pattern. Useful for finding longest speeches, repeated sections, or blocks of similar content.\u0022\n- Parameters: path, pattern, minRunLength (default: 2), returnLongestOnly (default: true), maxRuns (default: 10)\n\n**WHY**: This tool enables unique analysis like \u0022which character has the longest consecutive speech\u0022 that is impossible with simple pattern counting. Finding consecutive matching lines is a common text analysis need.\n\n\uD83D\uDCCB CODE QUALITY CHECKLIST:\n\u25A1 Single Responsibility: Does this class/method do one thing?\n\u25A1 Open/Closed: Is this open for extension, closed for modification?\n\u25A1 Liskov Substitution: Are derived classes substitutable for base classes?\n\u25A1 Interface Segregation: Are interfaces specific rather than general-purpose?\n\u25A1 Dependency Inversion: Are dependencies injected, not created?\n\u25A1 Cyclomatic Complexity: Is complexity around 5 or less?\n\u25A1 Pure Functions: Are there unnecessary side effects?\n\u25A1 Immutability: Can data structures be immutable?\n\u25A1 Static Methods: Should any methods be static (no instance state)?\n\u25A1 Railway-Oriented: Use Result\u003CT\u003E with Bind/Map/Tap instead of try-catch where appropriate",
      "status": "Completed",
      "dependencies": [
        {
          "taskId": "05aca5ef-c7cd-4af9-b83a-9d6c04680877"
        }
      ],
      "createdAt": "2026-01-18T20:09:38.0393502-06:00",
      "updatedAt": "2026-01-18T20:13:33.8169949-06:00",
      "completedAt": "2026-01-18T20:13:33.8169949-06:00",
      "summary": "Created FindConsecutiveRunsTool.cs with [McpServerToolType] and [McpServerTool] attributes. Tool name: find_consecutive_runs. Static class with static method, [Description] on class, method, and all parameters. Uses ToolResponseFormatter.FormatResult. Build succeeded with 0 errors and 0 warnings.",
      "relatedFiles": [
        {
          "path": "src/RecursiveContext.Mcp.Server/Tools/Analysis/FindConsecutiveRunsTool.cs",
          "type": "TO_MODIFY",
          "description": "New tool file to create"
        },
        {
          "path": "src/RecursiveContext.Mcp.Server/Tools/Analysis/CountPatternMatchesTool.cs",
          "type": "REFERENCE",
          "description": "Pattern for tool structure"
        }
      ],
      "analysisResult": "Creating 5 new advanced analysis tools for the RecursiveContext.Mcp.Server project as proposed in the Serena memory. These tools will enable complex pattern matching, aggregation, consecutive run detection, distributed sampling, and cross-file comparison - eliminating the need for AI to fall back to Python/PowerShell for complex analysis queries. Following the existing project patterns: IAdvancedAnalysisService interface, AdvancedAnalysisService implementation with DI registration, immutable models, MCP tool classes with Description attributes, and xUnit tests.",
      "verificationCriteria": "- File compiles without errors\n- [McpServerToolType] and [McpServerTool] attributes present\n- [Description] attributes on class, method, and all parameters\n- Static class with static method\n- Returns string via ToolResponseFormatter.FormatResult"
    },
    {
      "id": "51e1e569-3bfb-4559-862a-a25c1839ee0a",
      "name": "Create AggregatePatternMatchesTool",
      "description": "**WHAT**: Create a new file \u0060src/RecursiveContext.Mcp.Server/Tools/Analysis/AggregatePatternMatchesTool.cs\u0060 exposing the \u0060aggregate_pattern_matches\u0060 MCP tool:\n\n- Tool name: \u0060aggregate_pattern_matches\u0060\n- Description: \u0022Group and count pattern matches, returning top N groups. Useful for word frequency, categorization, or breakdown analysis.\u0022\n- Parameters: path, pattern (regex with optional capture group), groupBy (\u0022captureGroup1\u0022|\u0022firstWord\u0022|\u0022fullMatch\u0022), topN (default: 10), includeSamples (default: true)\n\n**WHY**: This is the highest priority tool as grouped analysis is the most common complex query type. It enables queries like \u0022break down biblical words by word and show top 3\u0022 without Python fallback.\n\n\uD83D\uDCCB CODE QUALITY CHECKLIST:\n\u25A1 Single Responsibility: Does this class/method do one thing?\n\u25A1 Open/Closed: Is this open for extension, closed for modification?\n\u25A1 Liskov Substitution: Are derived classes substitutable for base classes?\n\u25A1 Interface Segregation: Are interfaces specific rather than general-purpose?\n\u25A1 Dependency Inversion: Are dependencies injected, not created?\n\u25A1 Cyclomatic Complexity: Is complexity around 5 or less?\n\u25A1 Pure Functions: Are there unnecessary side effects?\n\u25A1 Immutability: Can data structures be immutable?\n\u25A1 Static Methods: Should any methods be static (no instance state)?\n\u25A1 Railway-Oriented: Use Result\u003CT\u003E with Bind/Map/Tap instead of try-catch where appropriate",
      "status": "Completed",
      "dependencies": [
        {
          "taskId": "05aca5ef-c7cd-4af9-b83a-9d6c04680877"
        }
      ],
      "createdAt": "2026-01-18T20:09:38.0543533-06:00",
      "updatedAt": "2026-01-18T20:14:01.6441911-06:00",
      "completedAt": "2026-01-18T20:14:01.6441911-06:00",
      "summary": "Created AggregatePatternMatchesTool.cs with [McpServerToolType] and [McpServerTool] attributes. Tool name: aggregate_pattern_matches. Static class with static method, [Description] on class, method, and all parameters. Uses ToolResponseFormatter.FormatResult. Build succeeded with 0 errors and 0 warnings.",
      "relatedFiles": [
        {
          "path": "src/RecursiveContext.Mcp.Server/Tools/Analysis/AggregatePatternMatchesTool.cs",
          "type": "TO_MODIFY",
          "description": "New tool file to create"
        },
        {
          "path": "src/RecursiveContext.Mcp.Server/Tools/Analysis/CountPatternMatchesTool.cs",
          "type": "REFERENCE",
          "description": "Pattern for tool structure"
        }
      ],
      "analysisResult": "Creating 5 new advanced analysis tools for the RecursiveContext.Mcp.Server project as proposed in the Serena memory. These tools will enable complex pattern matching, aggregation, consecutive run detection, distributed sampling, and cross-file comparison - eliminating the need for AI to fall back to Python/PowerShell for complex analysis queries. Following the existing project patterns: IAdvancedAnalysisService interface, AdvancedAnalysisService implementation with DI registration, immutable models, MCP tool classes with Description attributes, and xUnit tests.",
      "verificationCriteria": "- File compiles without errors\n- [McpServerToolType] and [McpServerTool] attributes present\n- [Description] attributes on class, method, and all parameters\n- Static class with static method\n- Returns string via ToolResponseFormatter.FormatResult"
    },
    {
      "id": "c937e843-b7ca-46e2-9d11-0aa98859b28b",
      "name": "Create SampleMatchesDistributedTool",
      "description": "**WHAT**: Create a new file \u0060src/RecursiveContext.Mcp.Server/Tools/Analysis/SampleMatchesDistributedTool.cs\u0060 exposing the \u0060sample_matches_distributed\u0060 MCP tool:\n\n- Tool name: \u0060sample_matches_distributed\u0060\n- Description: \u0022Get diverse sample matches spread across the file. Useful for getting examples from different sections of large documents.\u0022\n- Parameters: path, pattern, sampleCount (default: 5), distribution (\u0022even\u0022|\u0022random\u0022|\u0022first\u0022|\u0022last\u0022)\n\n**WHY**: Current sampling takes first N matches, which may all be from the beginning of a file. Distributed sampling provides more representative examples from different parts of the document, improving analysis quality.\n\n\uD83D\uDCCB CODE QUALITY CHECKLIST:\n\u25A1 Single Responsibility: Does this class/method do one thing?\n\u25A1 Open/Closed: Is this open for extension, closed for modification?\n\u25A1 Liskov Substitution: Are derived classes substitutable for base classes?\n\u25A1 Interface Segregation: Are interfaces specific rather than general-purpose?\n\u25A1 Dependency Inversion: Are dependencies injected, not created?\n\u25A1 Cyclomatic Complexity: Is complexity around 5 or less?\n\u25A1 Pure Functions: Are there unnecessary side effects?\n\u25A1 Immutability: Can data structures be immutable?\n\u25A1 Static Methods: Should any methods be static (no instance state)?\n\u25A1 Railway-Oriented: Use Result\u003CT\u003E with Bind/Map/Tap instead of try-catch where appropriate",
      "status": "Completed",
      "dependencies": [
        {
          "taskId": "05aca5ef-c7cd-4af9-b83a-9d6c04680877"
        }
      ],
      "createdAt": "2026-01-18T20:09:38.0714536-06:00",
      "updatedAt": "2026-01-18T20:14:22.3526769-06:00",
      "completedAt": "2026-01-18T20:14:22.3526769-06:00",
      "summary": "Created SampleMatchesDistributedTool.cs with [McpServerToolType] and [McpServerTool] attributes. Tool name: sample_matches_distributed. Static class with static method, [Description] on class, method, and all parameters. Uses ToolResponseFormatter.FormatResult. Build succeeded with 0 errors and 0 warnings.",
      "relatedFiles": [
        {
          "path": "src/RecursiveContext.Mcp.Server/Tools/Analysis/SampleMatchesDistributedTool.cs",
          "type": "TO_MODIFY",
          "description": "New tool file to create"
        },
        {
          "path": "src/RecursiveContext.Mcp.Server/Tools/Analysis/CountPatternMatchesTool.cs",
          "type": "REFERENCE",
          "description": "Pattern for tool structure"
        }
      ],
      "analysisResult": "Creating 5 new advanced analysis tools for the RecursiveContext.Mcp.Server project as proposed in the Serena memory. These tools will enable complex pattern matching, aggregation, consecutive run detection, distributed sampling, and cross-file comparison - eliminating the need for AI to fall back to Python/PowerShell for complex analysis queries. Following the existing project patterns: IAdvancedAnalysisService interface, AdvancedAnalysisService implementation with DI registration, immutable models, MCP tool classes with Description attributes, and xUnit tests.",
      "verificationCriteria": "- File compiles without errors\n- [McpServerToolType] and [McpServerTool] attributes present\n- [Description] attributes on class, method, and all parameters\n- Static class with static method\n- Returns string via ToolResponseFormatter.FormatResult"
    },
    {
      "id": "cba18b4a-64f5-489b-8ade-c3071972df94",
      "name": "Create ComparePatternAcrossFilesTool",
      "description": "**WHAT**: Create a new file \u0060src/RecursiveContext.Mcp.Server/Tools/Analysis/ComparePatternAcrossFilesTool.cs\u0060 exposing the \u0060compare_pattern_across_files\u0060 MCP tool:\n\n- Tool name: \u0060compare_pattern_across_files\u0060\n- Description: \u0022Compare pattern match counts across multiple files. Useful for comparing word usage or content patterns between documents.\u0022\n- Parameters: paths (string array), pattern, computeRatio (default: false)\n\n**WHY**: While this could be done with multiple count_pattern_matches calls, a dedicated tool provides cleaner output with comparison summary and optional ratio computation, reducing token usage and improving user experience.\n\n\uD83D\uDCCB CODE QUALITY CHECKLIST:\n\u25A1 Single Responsibility: Does this class/method do one thing?\n\u25A1 Open/Closed: Is this open for extension, closed for modification?\n\u25A1 Liskov Substitution: Are derived classes substitutable for base classes?\n\u25A1 Interface Segregation: Are interfaces specific rather than general-purpose?\n\u25A1 Dependency Inversion: Are dependencies injected, not created?\n\u25A1 Cyclomatic Complexity: Is complexity around 5 or less?\n\u25A1 Pure Functions: Are there unnecessary side effects?\n\u25A1 Immutability: Can data structures be immutable?\n\u25A1 Static Methods: Should any methods be static (no instance state)?\n\u25A1 Railway-Oriented: Use Result\u003CT\u003E with Bind/Map/Tap instead of try-catch where appropriate",
      "status": "Completed",
      "dependencies": [
        {
          "taskId": "05aca5ef-c7cd-4af9-b83a-9d6c04680877"
        }
      ],
      "createdAt": "2026-01-18T20:09:38.0852414-06:00",
      "updatedAt": "2026-01-18T20:14:43.0840846-06:00",
      "completedAt": "2026-01-18T20:14:43.0840846-06:00",
      "summary": "Created ComparePatternAcrossFilesTool.cs with [McpServerToolType] and [McpServerTool] attributes. Tool name: compare_pattern_across_files. Static class with static method, [Description] on class, method, and all parameters. Uses ToolResponseFormatter.FormatResult. Build succeeded with 0 errors and 0 warnings.",
      "relatedFiles": [
        {
          "path": "src/RecursiveContext.Mcp.Server/Tools/Analysis/ComparePatternAcrossFilesTool.cs",
          "type": "TO_MODIFY",
          "description": "New tool file to create"
        },
        {
          "path": "src/RecursiveContext.Mcp.Server/Tools/Analysis/CountPatternMatchesTool.cs",
          "type": "REFERENCE",
          "description": "Pattern for tool structure"
        }
      ],
      "analysisResult": "Creating 5 new advanced analysis tools for the RecursiveContext.Mcp.Server project as proposed in the Serena memory. These tools will enable complex pattern matching, aggregation, consecutive run detection, distributed sampling, and cross-file comparison - eliminating the need for AI to fall back to Python/PowerShell for complex analysis queries. Following the existing project patterns: IAdvancedAnalysisService interface, AdvancedAnalysisService implementation with DI registration, immutable models, MCP tool classes with Description attributes, and xUnit tests.",
      "verificationCriteria": "- File compiles without errors\n- [McpServerToolType] and [McpServerTool] attributes present\n- [Description] attributes on class, method, and all parameters\n- Static class with static method\n- Returns string via ToolResponseFormatter.FormatResult"
    },
    {
      "id": "f74e0f3b-ed81-4788-a203-45f417fcbb70",
      "name": "Create AdvancedAnalysisServiceTests",
      "description": "**WHAT**: Create a new test file \u0060tests/RecursiveContext.Mcp.Server.Tests/Services/AdvancedAnalysisServiceTests.cs\u0060 with comprehensive unit tests for all 5 service methods:\n\n1. CountCompoundPatternAsync tests:\n   - Test \u0022all\u0022 mode (AND logic)\n   - Test \u0022any\u0022 mode (OR logic)\n   - Test \u0022sequence\u0022 mode\n   - Test with includeSamples true/false\n   - Test invalid pattern handling\n\n2. FindConsecutiveRunsAsync tests:\n   - Test finding single run\n   - Test finding multiple runs\n   - Test minRunLength filtering\n   - Test returnLongestOnly flag\n\n3. AggregatePatternMatchesAsync tests:\n   - Test groupBy captureGroup1\n   - Test groupBy firstWord\n   - Test topN limiting\n   - Test includeSamples\n\n4. SampleMatchesDistributedAsync tests:\n   - Test \u0022even\u0022 distribution\n   - Test \u0022random\u0022 distribution\n   - Test \u0022first\u0022 and \u0022last\u0022 distributions\n\n5. ComparePatternAcrossFilesAsync tests:\n   - Test comparing two files\n   - Test computeRatio flag\n   - Test handling missing files\n\n**WHY**: Unit tests ensure the service logic is correct and provides a safety net for future changes. Following xUnit patterns already established in the project (see ContentAnalysisServiceTests.cs).\n\n\uD83D\uDCCB CODE QUALITY CHECKLIST:\n\u25A1 Single Responsibility: Does this class/method do one thing?\n\u25A1 Open/Closed: Is this open for extension, closed for modification?\n\u25A1 Liskov Substitution: Are derived classes substitutable for base classes?\n\u25A1 Interface Segregation: Are interfaces specific rather than general-purpose?\n\u25A1 Dependency Inversion: Are dependencies injected, not created?\n\u25A1 Cyclomatic Complexity: Is complexity around 5 or less?\n\u25A1 Pure Functions: Are there unnecessary side effects?\n\u25A1 Immutability: Can data structures be immutable?\n\u25A1 Static Methods: Should any methods be static (no instance state)?\n\u25A1 Railway-Oriented: Use Result\u003CT\u003E with Bind/Map/Tap instead of try-catch where appropriate",
      "status": "Completed",
      "dependencies": [
        {
          "taskId": "f4aa28c7-3cd0-41af-8e09-d55496f9edd2"
        }
      ],
      "createdAt": "2026-01-18T20:09:38.1181989-06:00",
      "updatedAt": "2026-01-18T20:16:09.3135332-06:00",
      "completedAt": "2026-01-18T20:16:09.3135332-06:00",
      "summary": "Created AdvancedAnalysisServiceTests.cs with 22 comprehensive unit tests covering all 5 service methods: CountCompoundPatternAsync (5 tests), FindConsecutiveRunsAsync (4 tests), AggregatePatternMatchesAsync (4 tests), SampleMatchesDistributedAsync (4 tests), ComparePatternAcrossFilesAsync (4 tests), plus error handling tests. All tests pass using xUnit [Fact] pattern with temp files for file-based testing.",
      "relatedFiles": [
        {
          "path": "tests/RecursiveContext.Mcp.Server.Tests/Services/AdvancedAnalysisServiceTests.cs",
          "type": "TO_MODIFY",
          "description": "New test file to create"
        },
        {
          "path": "tests/RecursiveContext.Mcp.Server.Tests/Services/ContentAnalysisServiceTests.cs",
          "type": "REFERENCE",
          "description": "Pattern for test structure"
        }
      ],
      "analysisResult": "Creating 5 new advanced analysis tools for the RecursiveContext.Mcp.Server project as proposed in the Serena memory. These tools will enable complex pattern matching, aggregation, consecutive run detection, distributed sampling, and cross-file comparison - eliminating the need for AI to fall back to Python/PowerShell for complex analysis queries. Following the existing project patterns: IAdvancedAnalysisService interface, AdvancedAnalysisService implementation with DI registration, immutable models, MCP tool classes with Description attributes, and xUnit tests.",
      "verificationCriteria": "- All tests pass\n- Tests cover all 5 methods\n- Tests cover success and failure paths\n- Uses xUnit [Fact] and [Theory] appropriately\n- Uses temp files for file-based testing"
    },
    {
      "id": "f5f3100c-332e-4b32-8056-9196c9e67a3a",
      "name": "Build solution and fix compilation errors",
      "description": "**WHAT**: Run \u0060dotnet build\u0060 on the solution and fix any compilation errors that arise from the new code.\n\n**WHY**: This is a critical integration verification step. All the new files must compile together without errors before running tests. Any issues with namespaces, missing usings, or type mismatches need to be resolved.\n\n\uD83D\uDCCB CODE QUALITY CHECKLIST:\n\u25A1 Single Responsibility: Does this class/method do one thing?\n\u25A1 Open/Closed: Is this open for extension, closed for modification?\n\u25A1 Liskov Substitution: Are derived classes substitutable for base classes?\n\u25A1 Interface Segregation: Are interfaces specific rather than general-purpose?\n\u25A1 Dependency Inversion: Are dependencies injected, not created?\n\u25A1 Cyclomatic Complexity: Is complexity around 5 or less?\n\u25A1 Pure Functions: Are there unnecessary side effects?\n\u25A1 Immutability: Can data structures be immutable?\n\u25A1 Static Methods: Should any methods be static (no instance state)?\n\u25A1 Railway-Oriented: Use Result\u003CT\u003E with Bind/Map/Tap instead of try-catch where appropriate",
      "status": "Completed",
      "dependencies": [
        {
          "taskId": "f74e0f3b-ed81-4788-a203-45f417fcbb70"
        },
        {
          "taskId": "1dc2d1eb-e0ec-4e01-91b9-a02f2c573c07"
        },
        {
          "taskId": "f631b3d1-740b-4d5d-a504-117d8c363fde"
        },
        {
          "taskId": "51e1e569-3bfb-4559-862a-a25c1839ee0a"
        },
        {
          "taskId": "c937e843-b7ca-46e2-9d11-0aa98859b28b"
        },
        {
          "taskId": "cba18b4a-64f5-489b-8ade-c3071972df94"
        }
      ],
      "createdAt": "2026-01-18T20:09:38.134193-06:00",
      "updatedAt": "2026-01-18T20:16:23.0072033-06:00",
      "completedAt": "2026-01-18T20:16:23.0072033-06:00",
      "summary": "Full solution build succeeded with 0 errors and 0 warnings. All new files (AdvancedAnalysisModels.cs, AdvancedAnalysisService.cs, IAdvancedAnalysisService interface, 5 tool files, and test file) compile correctly together.",
      "relatedFiles": [
        {
          "path": "src/RecursiveContext.Mcp.Server/RecursiveContext.Mcp.Server.csproj",
          "type": "REFERENCE",
          "description": "Main project file"
        }
      ],
      "analysisResult": "Creating 5 new advanced analysis tools for the RecursiveContext.Mcp.Server project as proposed in the Serena memory. These tools will enable complex pattern matching, aggregation, consecutive run detection, distributed sampling, and cross-file comparison - eliminating the need for AI to fall back to Python/PowerShell for complex analysis queries. Following the existing project patterns: IAdvancedAnalysisService interface, AdvancedAnalysisService implementation with DI registration, immutable models, MCP tool classes with Description attributes, and xUnit tests.",
      "verificationCriteria": "- \u0060dotnet build\u0060 succeeds with no errors\n- No warnings (project has TreatWarningsAsErrors=true)\n- All new files are included in compilation"
    },
    {
      "id": "637a42c2-5737-42be-bb66-3e3137f2d566",
      "name": "Run all unit tests and fix failures",
      "description": "**WHAT**: Run \u0060dotnet test\u0060 to execute all unit tests including the new AdvancedAnalysisServiceTests and fix any test failures.\n\n**WHY**: Running the full test suite ensures no regressions were introduced and that all new functionality works as expected. Test failures indicate bugs that need to be fixed before the feature is complete.\n\n\uD83D\uDCCB CODE QUALITY CHECKLIST:\n\u25A1 Single Responsibility: Does this class/method do one thing?\n\u25A1 Open/Closed: Is this open for extension, closed for modification?\n\u25A1 Liskov Substitution: Are derived classes substitutable for base classes?\n\u25A1 Interface Segregation: Are interfaces specific rather than general-purpose?\n\u25A1 Dependency Inversion: Are dependencies injected, not created?\n\u25A1 Cyclomatic Complexity: Is complexity around 5 or less?\n\u25A1 Pure Functions: Are there unnecessary side effects?\n\u25A1 Immutability: Can data structures be immutable?\n\u25A1 Static Methods: Should any methods be static (no instance state)?\n\u25A1 Railway-Oriented: Use Result\u003CT\u003E with Bind/Map/Tap instead of try-catch where appropriate",
      "status": "Completed",
      "dependencies": [
        {
          "taskId": "f5f3100c-332e-4b32-8056-9196c9e67a3a"
        }
      ],
      "createdAt": "2026-01-18T20:09:38.1500898-06:00",
      "updatedAt": "2026-01-18T20:16:38.2505483-06:00",
      "completedAt": "2026-01-18T20:16:38.2505483-06:00",
      "summary": "All 227 unit tests passed: 205 existing tests (no regressions) \u002B 22 new AdvancedAnalysisServiceTests. Zero failures. Full test suite confirms all new functionality works correctly and existing functionality is unchanged.",
      "relatedFiles": [
        {
          "path": "tests/RecursiveContext.Mcp.Server.Tests/RecursiveContext.Mcp.Server.Tests.csproj",
          "type": "REFERENCE",
          "description": "Test project file"
        }
      ],
      "analysisResult": "Creating 5 new advanced analysis tools for the RecursiveContext.Mcp.Server project as proposed in the Serena memory. These tools will enable complex pattern matching, aggregation, consecutive run detection, distributed sampling, and cross-file comparison - eliminating the need for AI to fall back to Python/PowerShell for complex analysis queries. Following the existing project patterns: IAdvancedAnalysisService interface, AdvancedAnalysisService implementation with DI registration, immutable models, MCP tool classes with Description attributes, and xUnit tests.",
      "verificationCriteria": "- All existing tests pass (no regressions)\n- All new AdvancedAnalysisServiceTests pass\n- Zero test failures"
    },
    {
      "id": "2eb4076b-c6b0-407d-8168-03ccc0a6af59",
      "name": "Update project memory with new tools documentation",
      "description": "**WHAT**: Update the Serena memory file \u0060proposed_new_analysis_tools\u0060 to reflect that the tools have been implemented. Change status from \u0027proposed\u0027 to \u0027implemented\u0027 and add any notes about implementation decisions.\n\n**WHY**: Keeping project memories up-to-date ensures future conversations have accurate context about what has been built. This prevents duplicate work and provides a reference for how the tools work.\n\n\uD83D\uDCCB CODE QUALITY CHECKLIST:\n\u25A1 Single Responsibility: Does this class/method do one thing?\n\u25A1 Open/Closed: Is this open for extension, closed for modification?\n\u25A1 Liskov Substitution: Are derived classes substitutable for base classes?\n\u25A1 Interface Segregation: Are interfaces specific rather than general-purpose?\n\u25A1 Dependency Inversion: Are dependencies injected, not created?\n\u25A1 Cyclomatic Complexity: Is complexity around 5 or less?\n\u25A1 Pure Functions: Are there unnecessary side effects?\n\u25A1 Immutability: Can data structures be immutable?\n\u25A1 Static Methods: Should any methods be static (no instance state)?\n\u25A1 Railway-Oriented: Use Result\u003CT\u003E with Bind/Map/Tap instead of try-catch where appropriate",
      "status": "Completed",
      "dependencies": [
        {
          "taskId": "637a42c2-5737-42be-bb66-3e3137f2d566"
        }
      ],
      "createdAt": "2026-01-18T20:09:38.166907-06:00",
      "updatedAt": "2026-01-18T20:17:13.35892-06:00",
      "completedAt": "2026-01-18T20:17:13.35892-06:00",
      "summary": "Updated project memory: deleted \u0027proposed_new_analysis_tools\u0027 and created \u0027implemented_advanced_analysis_tools\u0027 with full documentation of all 5 implemented tools, architecture, implementation decisions, and test coverage.",
      "relatedFiles": [],
      "analysisResult": "Creating 5 new advanced analysis tools for the RecursiveContext.Mcp.Server project as proposed in the Serena memory. These tools will enable complex pattern matching, aggregation, consecutive run detection, distributed sampling, and cross-file comparison - eliminating the need for AI to fall back to Python/PowerShell for complex analysis queries. Following the existing project patterns: IAdvancedAnalysisService interface, AdvancedAnalysisService implementation with DI registration, immutable models, MCP tool classes with Description attributes, and xUnit tests.",
      "verificationCriteria": "- Memory file updated with implementation status\n- Any design decisions documented"
    },
    {
      "id": "07be8f24-8bda-4d84-b189-5c6ce15d1d2d",
      "name": "Create ICompiledRegexCache Service",
      "description": "**WHAT**: Create a new ICompiledRegexCache interface and implementation that caches compiled Regex objects by pattern string using ConcurrentDictionary. Extract the existing CompileRegex() helper methods from AdvancedAnalysisService, ContentAnalysisService, and any other services into this shared cache service.\n\n**WHY**: Currently, the same regex patterns are recompiled on every tool call. Regex.Compiled is expensive on first use. By caching compiled regex objects, we eliminate redundant compilation overhead for frequently-used patterns (like word boundaries, character names, verse patterns in stress tests). This is a DRY refactor that consolidates duplicate CompileRegex() implementations across 3\u002B services.\n\n\uD83D\uDCCB CODE QUALITY CHECKLIST:\n\u25A1 Single Responsibility: Cache only handles regex compilation/retrieval\n\u25A1 Open/Closed: Interface allows future cache implementations\n\u25A1 Liskov Substitution: N/A (no inheritance)\n\u25A1 Interface Segregation: Single-purpose ICompiledRegexCache\n\u25A1 Dependency Inversion: Services depend on interface, not concrete cache\n\u25A1 Cyclomatic Complexity: GetOrCompile should be ~2\n\u25A1 Pure Functions: GetOrAdd is effectively pure\n\u25A1 Immutability: Regex objects are immutable once compiled\n\u25A1 Static Methods: N/A\n\u25A1 Railway-Oriented: Return Result\u003CRegex\u003E for invalid patterns",
      "status": "Pending",
      "dependencies": [],
      "createdAt": "2026-01-19T08:41:45.8558076-06:00",
      "updatedAt": "2026-01-19T08:41:45.8558076-06:00",
      "relatedFiles": [
        {
          "path": "src/RecursiveContext.Mcp.Server/Services/Interfaces.cs",
          "type": "TO_MODIFY",
          "description": "Add ICompiledRegexCache interface"
        },
        {
          "path": "src/RecursiveContext.Mcp.Server/Services/Caching/CompiledRegexCache.cs",
          "type": "OTHER",
          "description": "New cache implementation"
        },
        {
          "path": "src/RecursiveContext.Mcp.Server/Services/AdvancedAnalysisService.cs",
          "type": "TO_MODIFY",
          "description": "Remove CompileRegex, inject cache"
        },
        {
          "path": "src/RecursiveContext.Mcp.Server/Services/ContentAnalysisService.cs",
          "type": "TO_MODIFY",
          "description": "Remove CompileRegex, inject cache"
        },
        {
          "path": "src/RecursiveContext.Mcp.Server/Server/ServerServices.cs",
          "type": "TO_MODIFY",
          "description": "Register cache as singleton"
        }
      ],
      "analysisResult": "Comprehensive optimization analysis for recursive-context MCP server. Identified 9 optimization opportunities across parallelization (1 method), memory (14 file-load locations), caching (regex \u002B file content), and new tools (batch patterns). All proposals maintain backward compatibility with existing 227 tests, follow Railway-oriented programming patterns, and reuse existing architectural patterns like Parallel.ForEachAsync from AggregationService.",
      "verificationCriteria": "- ICompiledRegexCache interface defined with GetOrCompile method returning Result\u003CRegex\u003E\n- CompiledRegexCache implementation uses ConcurrentDictionary\u003Cstring, Regex\u003E\n- All services using CompileRegex now inject and use ICompiledRegexCache\n- Existing unit tests pass (no regressions)\n- New unit tests for cache hit/miss scenarios"
    },
    {
      "id": "791d7d79-50c2-4cf6-9ea0-8dfbbf6bdf4e",
      "name": "Parallelize ComparePatternAcrossFilesAsync",
      "description": "**WHAT**: Refactor the ComparePatternAcrossFilesAsync method in AdvancedAnalysisService to use Parallel.ForEachAsync instead of sequential foreach loop. Use ConcurrentBag\u003CFileComparisonEntry\u003E for thread-safe result collection.\n\n**WHY**: Currently, ComparePatternAcrossFilesAsync (lines 201-239) processes files sequentially in a foreach loop. When comparing patterns across multiple large files (like shakespeare.txt and bible.txt in stress tests), this is inefficient. The AggregationService.AggregateMatchesAsync already demonstrates the correct Parallel.ForEachAsync pattern - we should apply the same pattern here for consistency and 2-4x speedup on multi-core systems.\n\n\uD83D\uDCCB CODE QUALITY CHECKLIST:\n\u25A1 Single Responsibility: Method still does one thing - compare patterns\n\u25A1 Open/Closed: No API change, just implementation\n\u25A1 Liskov Substitution: N/A\n\u25A1 Interface Segregation: N/A\n\u25A1 Dependency Inversion: N/A\n\u25A1 Cyclomatic Complexity: Should remain ~5\n\u25A1 Pure Functions: File reading has side effects (I/O)\n\u25A1 Immutability: Results collected in ConcurrentBag, then converted to ImmutableArray\n\u25A1 Static Methods: N/A\n\u25A1 Railway-Oriented: Maintain Result\u003CT\u003E return type",
      "status": "Pending",
      "dependencies": [],
      "createdAt": "2026-01-19T08:41:45.8925736-06:00",
      "updatedAt": "2026-01-19T08:41:45.8925736-06:00",
      "relatedFiles": [
        {
          "path": "src/RecursiveContext.Mcp.Server/Services/AdvancedAnalysisService.cs",
          "type": "TO_MODIFY",
          "description": "Refactor ComparePatternAcrossFilesAsync lines 201-239"
        },
        {
          "path": "src/RecursiveContext.Mcp.Server/Services/AggregationService.cs",
          "type": "REFERENCE",
          "description": "Copy Parallel.ForEachAsync pattern from lines 68-96"
        }
      ],
      "analysisResult": "Comprehensive optimization analysis for recursive-context MCP server. Identified 9 optimization opportunities across parallelization (1 method), memory (14 file-load locations), caching (regex \u002B file content), and new tools (batch patterns). All proposals maintain backward compatibility with existing 227 tests, follow Railway-oriented programming patterns, and reuse existing architectural patterns like Parallel.ForEachAsync from AggregationService.",
      "verificationCriteria": "- ComparePatternAcrossFilesAsync uses Parallel.ForEachAsync\n- Uses ConcurrentBag for thread-safe collection\n- ParallelOptions with MaxDegreeOfParallelism = Environment.ProcessorCount\n- Results sorted for deterministic output (matching AggregationService pattern)\n- Existing ComparePatternAcrossFilesAsync tests pass\n- Performance improvement measurable with multi-file comparison"
    },
    {
      "id": "2f2d85b6-a1d1-4938-961c-3c0487fab9d3",
      "name": "Create IFileStreamingService for Line Streaming",
      "description": "**WHAT**: Create a new IFileStreamingService interface with a ReadLinesAsync method that returns IAsyncEnumerable\u003Cstring\u003E using File.ReadLinesAsync (.NET 8\u002B). This provides streaming file reading without loading entire file into memory.\n\n**WHY**: Currently, 14 locations use File.ReadAllLinesAsync which loads entire files into memory. For 5MB\u002B files like shakespeare.txt, this creates large string[] allocations causing GC pressure. Streaming reads lines on-demand, reducing peak memory usage and allowing early termination when a search limit is reached. This is critical for scaling to 100MB\u002B files.\n\n\uD83D\uDCCB CODE QUALITY CHECKLIST:\n\u25A1 Single Responsibility: Service only streams lines\n\u25A1 Open/Closed: Interface allows mock implementations for testing\n\u25A1 Liskov Substitution: N/A\n\u25A1 Interface Segregation: Separate from IFileSystemService (different concern)\n\u25A1 Dependency Inversion: Services depend on IFileStreamingService interface\n\u25A1 Cyclomatic Complexity: ~2 for streaming method\n\u25A1 Pure Functions: I/O is inherently side-effecting\n\u25A1 Immutability: Yields strings (immutable)\n\u25A1 Static Methods: N/A\n\u25A1 Railway-Oriented: Wrap in Result for path validation errors",
      "status": "Pending",
      "dependencies": [],
      "createdAt": "2026-01-19T08:41:45.9118664-06:00",
      "updatedAt": "2026-01-19T08:41:45.9118664-06:00",
      "relatedFiles": [
        {
          "path": "src/RecursiveContext.Mcp.Server/Services/Interfaces.cs",
          "type": "TO_MODIFY",
          "description": "Add IFileStreamingService interface"
        },
        {
          "path": "src/RecursiveContext.Mcp.Server/Services/Streaming/FileStreamingService.cs",
          "type": "OTHER",
          "description": "New streaming implementation"
        },
        {
          "path": "src/RecursiveContext.Mcp.Server/Server/ServerServices.cs",
          "type": "TO_MODIFY",
          "description": "Register streaming service"
        }
      ],
      "analysisResult": "Comprehensive optimization analysis for recursive-context MCP server. Identified 9 optimization opportunities across parallelization (1 method), memory (14 file-load locations), caching (regex \u002B file content), and new tools (batch patterns). All proposals maintain backward compatibility with existing 227 tests, follow Railway-oriented programming patterns, and reuse existing architectural patterns like Parallel.ForEachAsync from AggregationService.",
      "verificationCriteria": "- IFileStreamingService interface with ReadLinesAsync returning IAsyncEnumerable\u003Cstring\u003E\n- FileStreamingService uses File.ReadLinesAsync internally\n- Path validation using existing _pathResolver pattern\n- Unit tests verify streaming behavior\n- Memory profiling shows reduced allocations vs ReadAllLinesAsync"
    },
    {
      "id": "6d4ecd56-c93c-4a9b-9f44-f98f85a9b442",
      "name": "Refactor ContentAnalysisService to Use Streaming",
      "description": "**WHAT**: Refactor CountPatternMatchesAsync, SearchWithContextAsync, and CountLinesAsync in ContentAnalysisService to use IFileStreamingService instead of File.ReadAllLinesAsync where beneficial. For operations that need random access (like context lines), keep buffered approach.\n\n**WHY**: ContentAnalysisService has 3 File.ReadAllLinesAsync calls (lines 39, 87, 123). CountPatternMatchesAsync and CountLinesAsync can fully stream since they process line-by-line. SearchWithContextAsync needs context lines before/after, so it may need to buffer or use a sliding window. Streaming reduces memory for the counting operations.\n\n\uD83D\uDCCB CODE QUALITY CHECKLIST:\n\u25A1 Single Responsibility: Each method still does one analysis\n\u25A1 Open/Closed: Internal change, API unchanged\n\u25A1 Liskov Substitution: N/A\n\u25A1 Interface Segregation: Uses IFileStreamingService\n\u25A1 Dependency Inversion: Injected streaming service\n\u25A1 Cyclomatic Complexity: Should remain ~5 per method\n\u25A1 Pure Functions: I/O side effects\n\u25A1 Immutability: Results are immutable records\n\u25A1 Static Methods: N/A\n\u25A1 Railway-Oriented: Maintain Result\u003CT\u003E returns",
      "status": "Pending",
      "dependencies": [],
      "createdAt": "2026-01-19T08:41:45.9257574-06:00",
      "updatedAt": "2026-01-19T08:41:45.9257574-06:00",
      "relatedFiles": [
        {
          "path": "src/RecursiveContext.Mcp.Server/Services/ContentAnalysisService.cs",
          "type": "TO_MODIFY",
          "description": "Refactor 3 methods to use streaming"
        },
        {
          "path": "src/RecursiveContext.Mcp.Server/Services/Streaming/FileStreamingService.cs",
          "type": "REFERENCE",
          "description": "Use IFileStreamingService"
        }
      ],
      "analysisResult": "Comprehensive optimization analysis for recursive-context MCP server. Identified 9 optimization opportunities across parallelization (1 method), memory (14 file-load locations), caching (regex \u002B file content), and new tools (batch patterns). All proposals maintain backward compatibility with existing 227 tests, follow Railway-oriented programming patterns, and reuse existing architectural patterns like Parallel.ForEachAsync from AggregationService.",
      "verificationCriteria": "- CountPatternMatchesAsync uses streaming for counting\n- CountLinesAsync uses streaming enumeration\n- SearchWithContextAsync uses appropriate approach for context\n- All existing ContentAnalysisService tests pass\n- Memory profiling shows improvement for large files"
    },
    {
      "id": "4c9122f8-06ff-4280-8e07-ab5ea3809fa3",
      "name": "Refactor AdvancedAnalysisService to Use Streaming",
      "description": "**WHAT**: Refactor the 5 File.ReadAllLinesAsync calls in AdvancedAnalysisService (lines 39, 81, 114, 173, 225) to use IFileStreamingService where beneficial. Evaluate each method for streaming viability.\n\n**WHY**: AdvancedAnalysisService has the most file-loading operations (5 total). Some methods like AggregatePatternMatchesAsync need to group matches which benefits from full file access, while others like the inner loop of ComparePatternAcrossFilesAsync just count matches and can stream. Selective streaming where appropriate reduces memory without sacrificing functionality.\n\n\uD83D\uDCCB CODE QUALITY CHECKLIST:\n\u25A1 Single Responsibility: Each method maintains single purpose\n\u25A1 Open/Closed: API unchanged\n\u25A1 Liskov Substitution: N/A\n\u25A1 Interface Segregation: Uses streaming service\n\u25A1 Dependency Inversion: Injected services\n\u25A1 Cyclomatic Complexity: Target ~5\n\u25A1 Pure Functions: Some helper methods are pure\n\u25A1 Immutability: Immutable result records\n\u25A1 Static Methods: Keep existing static helpers\n\u25A1 Railway-Oriented: Maintain Result\u003CT\u003E",
      "status": "Pending",
      "dependencies": [],
      "createdAt": "2026-01-19T08:41:45.9473966-06:00",
      "updatedAt": "2026-01-19T08:41:45.9473966-06:00",
      "relatedFiles": [
        {
          "path": "src/RecursiveContext.Mcp.Server/Services/AdvancedAnalysisService.cs",
          "type": "TO_MODIFY",
          "description": "Refactor 5 methods to use streaming where appropriate"
        }
      ],
      "analysisResult": "Comprehensive optimization analysis for recursive-context MCP server. Identified 9 optimization opportunities across parallelization (1 method), memory (14 file-load locations), caching (regex \u002B file content), and new tools (batch patterns). All proposals maintain backward compatibility with existing 227 tests, follow Railway-oriented programming patterns, and reuse existing architectural patterns like Parallel.ForEachAsync from AggregationService.",
      "verificationCriteria": "- Each of 5 methods evaluated for streaming viability\n- Streaming applied where line-by-line processing is sufficient\n- Buffered approach kept where random access needed\n- All 22 AdvancedAnalysisService tests pass\n- Memory profiling shows improvement"
    },
    {
      "id": "731596e9-fea5-4010-8dd3-2dc36d30eabc",
      "name": "Add File Content Caching with IMemoryCache",
      "description": "**WHAT**: Create IFileContentCache interface and implementation using Microsoft.Extensions.Caching.Memory.IMemoryCache. Cache file contents by (path, lastModified) key with configurable expiration and size limits. Integrate with file reading services.\n\n**WHY**: In stress tests, the same large files (shakespeare.txt, bible.txt) are read multiple times for different analyses. Caching file content eliminates redundant I/O. IMemoryCache provides LRU eviction and memory pressure handling. Key includes lastModified to invalidate stale cache entries.\n\n\uD83D\uDCCB CODE QUALITY CHECKLIST:\n\u25A1 Single Responsibility: Cache only handles content caching\n\u25A1 Open/Closed: Interface allows alternative implementations\n\u25A1 Liskov Substitution: N/A\n\u25A1 Interface Segregation: Separate from regex cache\n\u25A1 Dependency Inversion: Services depend on interface\n\u25A1 Cyclomatic Complexity: ~3 for cache lookup with fallback\n\u25A1 Pure Functions: Cache lookup is not pure (state)\n\u25A1 Immutability: Cached content is string[] (reference type)\n\u25A1 Static Methods: N/A\n\u25A1 Railway-Oriented: Return Result\u003Cstring[]\u003E",
      "status": "Pending",
      "dependencies": [],
      "createdAt": "2026-01-19T08:41:45.9656337-06:00",
      "updatedAt": "2026-01-19T08:41:45.9656337-06:00",
      "relatedFiles": [
        {
          "path": "src/RecursiveContext.Mcp.Server/Services/Interfaces.cs",
          "type": "TO_MODIFY",
          "description": "Add IFileContentCache interface"
        },
        {
          "path": "src/RecursiveContext.Mcp.Server/Services/Caching/FileContentCache.cs",
          "type": "OTHER",
          "description": "New cache implementation"
        },
        {
          "path": "src/RecursiveContext.Mcp.Server/Server/ServerServices.cs",
          "type": "TO_MODIFY",
          "description": "Register cache and IMemoryCache"
        },
        {
          "path": "src/RecursiveContext.Mcp.Server/RecursiveContext.Mcp.Server.csproj",
          "type": "TO_MODIFY",
          "description": "Add Microsoft.Extensions.Caching.Memory if not present"
        }
      ],
      "analysisResult": "Comprehensive optimization analysis for recursive-context MCP server. Identified 9 optimization opportunities across parallelization (1 method), memory (14 file-load locations), caching (regex \u002B file content), and new tools (batch patterns). All proposals maintain backward compatibility with existing 227 tests, follow Railway-oriented programming patterns, and reuse existing architectural patterns like Parallel.ForEachAsync from AggregationService.",
      "verificationCriteria": "- IFileContentCache interface with GetOrLoadAsync method\n- FileContentCache uses IMemoryCache with configurable options\n- Cache key includes file path and last modified time\n- Size-based eviction configured\n- Unit tests for cache hit/miss/invalidation"
    }
  ]
}